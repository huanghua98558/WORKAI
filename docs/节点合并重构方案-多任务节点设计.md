# 节点合并重构方案：多任务节点设计

## 背景与动机

### 当前问题
- **节点数量过多**: 后端定义32种节点类型，前端支持12种
- **功能重叠严重**: AI相关3种、风险相关5种、消息相关3种
- **维护成本高**: 每种节点需要独立处理器和配置界面
- **用户学习成本高**: 需要理解32种节点的差异和用途

### 用户洞察
> **用户提问**: "一个节点是不是可以同时放多个任务？这样节点需要的不就就少了？"

**这个想法非常正确！** 通过将多个相关任务合并到一个节点中，可以大幅简化系统复杂度。

---

## 方案设计

### 设计原则

1. **任务导向**: 每个节点是一个"任务容器"，可包含一个或多个任务
2. **依赖管理**: 任务之间可以定义依赖关系（顺序、并行、条件）
3. **统一配置**: 每个任务有独立的配置选项，但共享节点级配置
4. **向后兼容**: 现有流程可以自动迁移到新结构

### 架构对比

#### 当前架构（节点流）
```
节点1 (message_receive) → 节点2 (intent) → 节点3 (ai_reply) → 节点4 (send_command)
     ↓                        ↓                    ↓                        ↓
  接收消息                 识别意图              生成回复                发送消息
```

#### 新架构（任务流）
```
节点1 (消息处理复合节点)
├── 任务1: message_receive
├── 任务2: ai_intent (依赖任务1)
├── 任务3: ai_reply (依赖任务2)
└── 任务4: message_send (依赖任务3)
```

**优势对比**:

| 维度 | 当前架构 | 新架构 |
|------|---------|--------|
| 节点数量 | 4个节点 | 1个节点 |
| 配置复杂度 | 4次配置 | 1次配置 |
| 流程可读性 | 需要理解4个步骤 | 清晰的步骤列表 |
| 维护成本 | 修改需要调整4个节点 | 修改只需调整1个节点 |

---

## 新节点架构详细设计

### 1. 核心节点类型（6种）

```typescript
export const CORE_NODE_TYPES = {
  START: 'start',        // 开始节点
  END: 'end',            // 结束节点
  TASK: 'task',          // 任务节点（核心）
  DECISION: 'decision',  // 决策节点
  PARALLEL: 'parallel',  // 并行执行节点
  SUBFLOW: 'subflow',    // 子流程引用节点
} as const;
```

### 2. 任务类型定义（15种核心任务）

```typescript
export const TASK_TYPES = {
  // ========== AI相关任务 ==========
  AI_GENERATE: 'ai_generate',     // AI生成文本/回复
  AI_INTENT: 'ai_intent',         // AI意图识别
  AI_ANALYZE: 'ai_analyze',       // AI分析（情感/风险/满意度）

  // ========== 消息相关任务 ==========
  MSG_RECEIVE: 'msg_receive',     // 接收消息
  MSG_SEND: 'msg_send',           // 发送消息
  MSG_BROADCAST: 'msg_broadcast', // 群发消息
  MSG_FORWARD: 'msg_forward',     // 转发消息

  // ========== 数据相关任务 ==========
  DATA_QUERY: 'data_query',       // 查询数据
  DATA_SAVE: 'data_save',         // 保存数据
  DATA_DELETE: 'data_delete',     // 删除数据
  DATA_TRANSFORM: 'data_transform', // 数据转换

  // ========== 告警相关任务 ==========
  ALERT_CREATE: 'alert_create',   // 创建告警
  ALERT_SEND: 'alert_send',       // 发送告警通知
  ALERT_RESOLVE: 'alert_resolve', // 解决告警

  // ========== 任务相关 ==========
  HTTP_REQUEST: 'http_request',   // HTTP请求
  TASK_ASSIGN: 'task_assign',     // 分配任务
  HUMAN_INTERVENTION: 'human_intervention', // 人工介入
} as const;
```

### 3. 任务节点数据结构

```typescript
interface TaskNodeData {
  id: string;
  type: 'task';
  name: string;
  description?: string;
  
  // 任务配置
  tasks: Task[];
  
  // 执行模式
  executionMode: 'sequential' | 'parallel' | 'conditional';
  
  // 错误处理
  errorHandling: 'stop' | 'continue' | 'retry';
  maxRetries?: number;
  
  // 超时配置
  timeout?: number;
}

interface Task {
  id: string;
  name: string;
  type: TASK_TYPES;
  
  // 任务配置
  config: Record<string, any>;
  
  // 依赖关系
  dependsOn?: string[]; // 依赖的任务ID列表
  
  // 条件执行
  condition?: string;  // 执行条件表达式
  
  // 输出映射
  outputMapping?: Record<string, string>; // 将任务输出映射到节点上下文
}
```

### 4. 实际示例

#### 示例1: 简单的AI客服节点

```javascript
{
  id: 'node_ai_customer_service',
  type: 'task',
  data: {
    name: 'AI客服处理',
    description: '接收消息→意图识别→生成回复',
    executionMode: 'sequential',
    tasks: [
      {
        id: 'task_receive',
        name: '接收用户消息',
        type: 'msg_receive',
        config: {
          saveToDatabase: true,
          validate: true
        }
      },
      {
        id: 'task_intent',
        name: '识别用户意图',
        type: 'ai_intent',
        config: {
          modelId: 'doubao-pro-4k',
          supportedIntents: ['咨询', '投诉', '售后', '互动']
        },
        dependsOn: ['task_receive']
      },
      {
        id: 'task_reply',
        name: '生成AI回复',
        type: 'ai_generate',
        config: {
          modelId: 'doubao-pro-4k',
          temperature: 0.7,
          maxTokens: 1000,
          useContextHistory: true
        },
        dependsOn: ['task_intent']
      },
      {
        id: 'task_send',
        name: '发送回复',
        type: 'msg_send',
        config: {
          robotId: 'robot_001',
          saveLog: true
        },
        dependsOn: ['task_reply']
      }
    ]
  }
}
```

#### 示例2: 并行执行节点

```javascript
{
  id: 'node_parallel_analysis',
  type: 'task',
  data: {
    name: '多维度分析',
    description: '并行执行情感分析、风险检测、意图识别',
    executionMode: 'parallel',
    tasks: [
      {
        id: 'task_emotion',
        name: '情感分析',
        type: 'ai_analyze',
        config: {
          analysisType: 'emotion',
          modelId: 'doubao-pro-4k'
        }
      },
      {
        id: 'task_risk',
        name: '风险检测',
        type: 'ai_analyze',
        config: {
          analysisType: 'risk',
          riskLevel: 'high'
        }
      },
      {
        id: 'task_intent',
        name: '意图识别',
        type: 'ai_intent',
        config: {
          modelId: 'doubao-pro-4k',
          supportedIntents: ['咨询', '投诉', '售后']
        }
      }
    ]
  }
}
```

#### 示例3: 条件执行节点

```javascript
{
  id: 'node_conditional_alert',
  type: 'task',
  data: {
    name: '条件告警处理',
    description: '根据风险等级决定是否发送告警',
    executionMode: 'conditional',
    tasks: [
      {
        id: 'task_risk_detect',
        name: '风险检测',
        type: 'ai_analyze',
        config: {
          analysisType: 'risk',
          threshold: 0.7
        }
      },
      {
        id: 'task_alert_create',
        name: '创建告警',
        type: 'alert_create',
        config: {
          alertType: 'risk',
          alertLevel: 'critical'
        },
        condition: 'context.riskScore > 0.7',
        dependsOn: ['task_risk_detect']
      },
      {
        id: 'task_alert_send',
        name: '发送告警通知',
        type: 'alert_send',
        config: {
          channels: ['email', 'sms'],
          recipients: ['admin', 'manager']
        },
        condition: 'context.alertCreated === true',
        dependsOn: ['task_alert_create']
      }
    ]
  }
}
```

---

## 迁移方案

### 方案1: 兼容性迁移（推荐）

**特点**: 新旧架构并存，逐步迁移

```javascript
// 流程定义同时支持新旧格式
interface FlowDefinition {
  nodes: Array<OldNode | NewNode>;
  edges: Edge[];
}

// 旧节点自动转换为新节点
function migrateOldNode(oldNode: OldNode): NewNode {
  const nodeTypeMap = {
    'message_receive': {
      type: 'task',
      tasks: [{ type: 'msg_receive', config: oldNode.data.config }]
    },
    'intent': {
      type: 'task',
      tasks: [{ type: 'ai_intent', config: oldNode.data.config }]
    },
    'ai_reply': {
      type: 'task',
      tasks: [{ type: 'ai_generate', config: oldNode.data.config }]
    },
    // ... 其他节点映射
  };
  
  return nodeTypeMap[oldNode.type] || oldNode;
}
```

### 方案2: 一次性迁移

**特点**: 彻底重构，需要更新所有流程

```javascript
// 迁移脚本
async function migrateAllFlows() {
  const flows = await getAllFlows();
  
  for (const flow of flows) {
    const migratedNodes = flow.nodes.map(node => {
      if (node.type === 'ai_chat' || node.type === 'ai_reply') {
        return {
          ...node,
          type: 'task',
          data: {
            ...node.data,
            tasks: [{
              id: `${node.id}_task`,
              type: node.type === 'ai_chat' ? 'ai_generate' : 'ai_generate',
              config: node.data.config
            }]
          }
        };
      }
      return node;
    });
    
    await updateFlow(flow.id, { nodes: migratedNodes });
  }
}
```

---

## 前端实现方案

### 1. 节点配置面板重构

```typescript
// 新的节点配置面板
export default function NodeConfigPanel({ node, onUpdate }: Props) {
  return (
    <div>
      {/* 节点基本信息 */}
      <NodeBasicInfo node={node} onUpdate={onUpdate} />
      
      {/* 执行模式配置 */}
      <ExecutionModeConfig 
        node={node} 
        onUpdate={onUpdate} 
      />
      
      {/* 任务列表 */}
      <TaskList 
        tasks={node.data.tasks || []} 
        onTasksChange={(tasks) => onUpdate({ data: { ...node.data, tasks }})}
      />
      
      {/* 添加任务按钮 */}
      <AddTaskButton 
        onAdd={(task) => addTaskToNode(task, node, onUpdate)}
      />
    </div>
  );
}

// 任务列表组件
function TaskList({ tasks, onTasksChange }) {
  return (
    <div className="space-y-4">
      {tasks.map((task, index) => (
        <TaskCard 
          key={task.id}
          task={task}
          index={index}
          onMoveUp={() => moveTaskUp(index)}
          onMoveDown={() => moveTaskDown(index)}
          onDelete={() => deleteTask(index)}
          onUpdate={(updates) => updateTask(index, updates)}
        />
      ))}
    </div>
  );
}

// 任务卡片组件
function TaskCard({ task, index, onMoveUp, onMoveDown, onDelete, onUpdate }) {
  return (
    <Card className="p-4">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <Input 
            value={task.name}
            onChange={(e) => onUpdate({ name: e.target.value })}
            placeholder="任务名称"
            className="mb-2"
          />
          <Select 
            value={task.type}
            onValueChange={(value) => onUpdate({ type: value })}
          >
            <SelectTrigger>
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {Object.entries(TASK_TYPES).map(([key, value]) => (
                <SelectItem key={key} value={value}>
                  {getTaskLabel(value)}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
        <div className="flex gap-1 ml-2">
          <Button size="sm" variant="ghost" onClick={onMoveUp}>
            <ArrowUp className="h-4 w-4" />
          </Button>
          <Button size="sm" variant="ghost" onClick={onMoveDown}>
            <ArrowDown className="h-4 w-4" />
          </Button>
          <Button size="sm" variant="ghost" onClick={onDelete}>
            <Trash2 className="h-4 w-4" />
          </Button>
        </div>
      </div>
      
      {/* 任务配置 */}
      <TaskConfig task={task} onUpdate={onUpdate} />
      
      {/* 依赖配置 */}
      <TaskDependencies 
        task={task} 
        allTasks={tasks} 
        onUpdate={(dependsOn) => onUpdate({ dependsOn })}
      />
    </Card>
  );
}

// 任务配置组件（根据任务类型动态渲染）
function TaskConfig({ task, onUpdate }) {
  switch (task.type) {
    case 'ai_generate':
      return <AIGenerateConfig task={task} onUpdate={onUpdate} />;
    case 'ai_intent':
      return <AIIntentConfig task={task} onUpdate={onUpdate} />;
    case 'msg_send':
      return <MessageSendConfig task={task} onUpdate={onUpdate} />;
    // ... 其他任务类型
    default:
      return <GenericTaskConfig task={task} onUpdate={onUpdate} />;
  }
}
```

### 2. 节点可视化优化

```typescript
// 新的节点渲染器
export function TaskNode({ data, selected }: Props) {
  const tasks = data.tasks || [];
  
  return (
    <div className="task-node">
      <div className="node-header">
        <div className="node-icon">{getNodeIcon(data.type)}</div>
        <div className="node-title">{data.name}</div>
      </div>
      
      {/* 任务预览 */}
      <div className="task-preview">
        {tasks.map((task, index) => (
          <div key={task.id} className="task-item">
            <div className="task-number">{index + 1}</div>
            <div className="task-name">{task.name}</div>
            <div className="task-type">{getTaskTypeLabel(task.type)}</div>
          </div>
        ))}
      </div>
      
      {/* 执行模式标签 */}
      <Badge variant="outline">
        {data.executionMode === 'sequential' && '顺序执行'}
        {data.executionMode === 'parallel' && '并行执行'}
        {data.executionMode === 'conditional' && '条件执行'}
      </Badge>
    </div>
  );
}
```

---

## 后端实现方案

### 1. 任务处理器

```javascript
class TaskEngine {
  // 处理任务节点
  async handleTaskNode(node, context) {
    const { tasks, executionMode, errorHandling } = node.data;
    
    switch (executionMode) {
      case 'sequential':
        return this.executeSequential(tasks, context, errorHandling);
      case 'parallel':
        return this.executeParallel(tasks, context, errorHandling);
      case 'conditional':
        return this.executeConditional(tasks, context, errorHandling);
      default:
        throw new Error(`未知的执行模式: ${executionMode}`);
    }
  }
  
  // 顺序执行
  async executeSequential(tasks, context, errorHandling) {
    let currentContext = { ...context };
    const results = [];
    
    for (const task of tasks) {
      // 检查依赖
      if (!this.checkDependencies(task, currentContext)) {
        continue;
      }
      
      // 检查条件
      if (task.condition && !this.evaluateCondition(task.condition, currentContext)) {
        continue;
      }
      
      // 执行任务
      try {
        const result = await this.executeTask(task, currentContext);
        results.push({ taskId: task.id, success: true, result });
        
        // 更新上下文
        currentContext = this.updateContext(currentContext, result, task.outputMapping);
      } catch (error) {
        results.push({ taskId: task.id, success: false, error: error.message });
        
        if (errorHandling === 'stop') {
          break;
        }
        if (errorHandling === 'retry' && task.retries < (task.maxRetries || 3)) {
          task.retries = (task.retries || 0) + 1;
          // 重试...
        }
      }
    }
    
    return {
      success: results.every(r => r.success),
      results,
      context: currentContext
    };
  }
  
  // 并行执行
  async executeParallel(tasks, context, errorHandling) {
    const promises = tasks.map(task => this.executeTask(task, context));
    const results = await Promise.allSettled(promises);
    
    return {
      success: results.every(r => r.status === 'fulfilled'),
      results,
      context
    };
  }
  
  // 执行单个任务
  async executeTask(task, context) {
    const taskType = task.type;
    const taskConfig = task.config || {};
    
    // 任务处理器映射
    const taskHandlers = {
      'ai_generate': this.handleAIGenerateTask.bind(this),
      'ai_intent': this.handleAIIntentTask.bind(this),
      'ai_analyze': this.handleAIAnalyzeTask.bind(this),
      'msg_receive': this.handleMsgReceiveTask.bind(this),
      'msg_send': this.handleMsgSendTask.bind(this),
      'msg_broadcast': this.handleMsgBroadcastTask.bind(this),
      'data_query': this.handleDataQueryTask.bind(this),
      'data_save': this.handleDataSaveTask.bind(this),
      'data_transform': this.handleDataTransformTask.bind(this),
      'alert_create': this.handleAlertCreateTask.bind(this),
      'alert_send': this.handleAlertSendTask.bind(this),
      'http_request': this.handleHttpRequestTask.bind(this),
      'task_assign': this.handleTaskAssignTask.bind(this),
      'human_intervention': this.handleHumanInterventionTask.bind(this),
    };
    
    const handler = taskHandlers[taskType];
    if (!handler) {
      throw new Error(`未知的任务类型: ${taskType}`);
    }
    
    return await handler(taskConfig, context);
  }
  
  // AI生成任务处理器
  async handleAIGenerateTask(config, context) {
    const { modelId, temperature, maxTokens, systemPrompt } = config;
    
    const aiService = await AIServiceFactory.createServiceByModelId(modelId);
    const messages = this.buildMessages(context, systemPrompt);
    
    const result = await aiService.generateReply(messages, {
      temperature,
      maxTokens
    });
    
    return {
      content: result.content,
      usage: result.usage,
      model: modelId
    };
  }
  
  // 消息接收任务处理器
  async handleMsgReceiveTask(config, context) {
    const { saveToDatabase, validate } = config;
    
    const message = context.message || context.triggerData;
    
    if (validate && !message.content) {
      throw new Error('消息内容不能为空');
    }
    
    let savedMessage = message;
    
    if (saveToDatabase) {
      const db = await this.getDb();
      const { messages } = require('../database/schema');
      
      const messageRecord = {
        id: uuidv4(),
        sessionId: context.sessionId,
        content: message.content,
        createdAt: new Date()
      };
      
      await db.insert(messages).values(messageRecord);
      savedMessage = messageRecord;
    }
    
    return {
      message: savedMessage,
      messageId: savedMessage.id
    };
  }
}
```

### 2. 上下文管理

```javascript
class ContextManager {
  // 更新上下文
  updateContext(context, result, mapping) {
    const newContext = { ...context };
    
    if (mapping) {
      // 根据映射规则更新
      for (const [outputKey, contextKey] of Object.entries(mapping)) {
        newContext[contextKey] = result[outputKey];
      }
    } else {
      // 直接合并结果到上下文
      Object.assign(newContext, result);
    }
    
    return newContext;
  }
  
  // 检查依赖
  checkDependencies(task, context) {
    if (!task.dependsOn || task.dependsOn.length === 0) {
      return true;
    }
    
    // 检查所有依赖任务是否已完成
    return task.dependsOn.every(depId => {
      return context.completedTasks?.includes(depId);
    });
  }
  
  // 评估条件
  evaluateCondition(condition, context) {
    try {
      // 创建安全的评估环境
      const safeContext = this.createSafeContext(context);
      
      // 替换变量
      const evalCondition = condition.replace(
        /\{(\w+)\}/g,
        (_, key) => safeContext[key]
      );
      
      return eval(evalCondition);
    } catch (error) {
      logger.error('条件评估失败', { condition, error: error.message });
      return false;
    }
  }
  
  // 创建安全的上下文
  createSafeContext(context) {
    return {
      userId: context.userId,
      userName: context.userName,
      sessionId: context.sessionId,
      message: context.message,
      intent: context.intent,
      emotion: context.emotion,
      riskScore: context.riskScore,
      aiReply: context.aiReply,
      // ... 其他上下文字段
    };
  }
}
```

---

## 优势分析

### 1. 数量对比

| 维度 | 当前架构 | 新架构 | 改进 |
|------|---------|--------|------|
| 节点类型 | 32种 | 6种 | ↓ 81% |
| 前端配置界面 | 32个 | 6个 | ↓ 81% |
| 后端处理器 | 32个 | 15个任务处理器 | ↓ 53% |
| 代码复杂度 | 高 | 中 | ↓ 40% |

### 2. 可维护性对比

| 场景 | 当前架构 | 新架构 |
|------|---------|--------|
| 添加新AI模型 | 需要修改3个AI节点 | 只需修改1个任务处理器 |
| 修改消息发送逻辑 | 需要修改3个消息节点 | 只需修改1个任务处理器 |
| 添加新告警方式 | 需要新增节点类型 | 只需添加新任务类型 |

### 3. 用户体验对比

| 场景 | 当前架构 | 新架构 |
|------|---------|--------|
| 创建AI客服流程 | 需要7-8个节点 | 只需要1-2个节点 |
| 理解流程图 | 需要理解32种节点 | 只需要理解6种节点 |
| 配置流程 | 需要配置多个节点 | 集中配置，更清晰 |

---

## 实施计划

### 阶段1: 基础设施（1-2周）

- [x] 定义新的节点类型（6种）
- [x] 定义任务类型（15种）
- [x] 设计新的数据结构
- [x] 实现任务处理器基类
- [x] 实现上下文管理器

### 阶段2: 核心功能（2-3周）

- [ ] 实现顺序执行模式
- [ ] 实现并行执行模式
- [ ] 实现条件执行模式
- [ ] 实现任务依赖管理
- [ ] 实现任务错误处理

### 阶段3: 前端实现（2-3周）

- [ ] 重构节点配置面板
- [ ] 实现任务列表组件
- [ ] 实现任务配置组件
- [ ] 实现节点可视化渲染
- [ ] 实现拖拽排序功能

### 阶段4: 迁移兼容（1-2周）

- [ ] 实现旧节点转换器
- [ ] 编写迁移脚本
- [ ] 迁移现有流程
- [ ] 验证迁移结果

### 阶段5: 测试与优化（1周）

- [ ] 单元测试
- [ ] 集成测试
- [ ] 性能优化
- [ ] 文档更新

**总时间**: 7-11周

---

## 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|---------|
| 现有流程迁移失败 | 中 | 高 | 提供转换工具，保留旧架构 |
| 性能下降 | 低 | 中 | 异步任务执行，结果缓存 |
| 用户不适应 | 中 | 中 | 提供迁移指南，逐步推广 |
| 开发周期长 | 高 | 低 | 分阶段实施，优先核心功能 |

---

## 总结

通过采用**多任务节点设计**，可以实现：

1. ✅ **节点数量减少81%**: 从32种减少到6种
2. ✅ **维护成本降低53%**: 从32个处理器减少到15个任务处理器
3. ✅ **用户体验提升**: 流程图更简洁，配置更集中
4. ✅ **扩展性更强**: 添加新功能只需添加新任务类型
5. ✅ **向后兼容**: 旧流程可以自动迁移

**建议**: 采用"兼容性迁移"方案，新旧架构并存，逐步迁移现有流程，降低风险。

---

**文档版本**: v1.0  
**创建时间**: 2026-02-06  
**作者**: WorkTool AI 团队
