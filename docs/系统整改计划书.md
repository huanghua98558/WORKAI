# WorkTool AI 中枢系统 - 整改计划书

## 1. 项目概述

### 1.1 项目背景
WorkTool AI 中枢系统经过全面分析，发现了在架构设计、性能、安全、代码质量、可维护性、扩展性、监控和用户体验等多个方面存在需要改进的问题。本计划书旨在系统性地解决这些问题，提升系统的整体质量。

### 1.2 整改目标
- **安全加固**：实现完善的认证授权、输入验证和敏感信息保护
- **性能优化**：提升系统响应速度、并发能力和资源利用率
- **架构优化**：提高系统的可维护性、可扩展性和灵活性
- **代码质量**：提高代码的可读性、可测试性和健壮性
- **监控完善**：建立全面的系统监控和告警机制
- **用户体验**：改善前端性能和错误提示，提升用户体验

### 1.3 整改范围
本次整改涵盖以下方面：
- ✅ 架构设计优化
- ✅ 性能优化
- ✅ 安全加固
- ✅ 代码质量提升
- ✅ 可维护性改进
- ✅ 扩展性增强
- ✅ 监控和告警
- ✅ 数据库优化
- ✅ 用户体验优化

**排除范围**：
- ❌ 自动化部署（CI/CD）
- ❌ 负载均衡
- ❌ 环境隔离和容器化

---

## 2. 整改原则

### 2.1 原则一：安全优先
所有整改必须遵循最小权限原则和安全第一原则，任何可能引入安全风险的改动都必须经过严格审查。

### 2.2 原则二：渐进式改进
按照优先级分阶段实施，优先解决 P0 和 P1 级别问题，避免一次性大规模改动导致风险。

### 2.3 原则三：向后兼容
所有改动必须保证向后兼容，不破坏现有功能，确保平滑过渡。

### 2.4 原则四：可测试性
每个改进都应该有相应的测试用例，确保改动正确且可回归。

### 2.5 原则六：可回滚
每个阶段的改动都应该有回滚方案，一旦出现问题可以快速恢复。

---

## 3. 整改阶段划分

### 3.1 第一阶段：安全加固（P0）
**时间估算**：2-3 周
**目标**：解决最严重的安全问题，建立安全防护体系

**主要任务**：
1. 实现认证授权系统
2. 完善输入验证
3. 敏感信息防护
4. 数据库备份
5. CORS 配置优化

### 3.2 第二阶段：核心性能优化（P0-P1）
**时间估算**：3-4 周
**目标**：提升系统性能，解决瓶颈

**主要任务**：
1. 数据库查询优化
2. Redis 使用优化
3. AI 请求优化
4. 统一错误处理

### 3.3 第三阶段：架构和代码质量（P1）
**时间估算**：4-6 周
**目标**：优化架构，提升代码质量

**主要任务**：
1. 前后端分离优化
2. 统一状态管理
3. 类型定义完善
4. 单元测试添加
5. 代码重复消除

### 3.4 第四阶段：扩展性和可维护性（P1-P2）
**时间估算**：4-5 周
**目标**：提高系统的可扩展性和可维护性

**主要任务**：
1. 告警规则引擎优化
2. 日志系统完善
3. 配置管理优化
4. 文档完善
5. 健康检查完善

### 3.5 第五阶段：监控和体验优化（P1-P2）
**时间估算**：3-4 周
**目标**：建立监控体系，提升用户体验

**主要任务**：
1. 系统监控实现
2. WebSocket 连接优化
3. 前端性能优化
4. 错误提示优化
5. 数据归档策略

### 3.6 第六阶段：UI设计完善（P1）
**时间估算**：3-4 周
**目标**：完善UI设计，提升视觉效果和交互体验

**主要任务**：
1. 统一设计规范和主题系统
2. 组件库升级和扩展
3. 响应式设计优化
4. 暗色模式实现
5. 交互动效和过渡效果
6. 数据可视化组件完善

### 3.7 第七阶段：高级特性（P2）
**时间估算**：4-6 周
**目标**：实现高级特性，增强系统能力

**主要任务**：
1. 消息队列引入
2. 通知方式扩展
3. AI 模型切换

---

## 4. 第一阶段：安全加固（2-3 周）

### 4.1 实现认证授权系统

#### 任务 1.1：JWT 认证实现
**优先级**：P0  
**工作量**：5 天

**实施步骤**：
1. 设计认证架构
   - 选择 JWT 方案（无状态）
   - 定义 Token 格式和过期时间
   - 设计 Refresh Token 机制

2. 实现认证中间件
   ```javascript
   // server/middleware/auth.js
   module.exports = async function authMiddleware(request, reply, done) {
     const token = request.headers.authorization?.replace('Bearer ', '');
     if (!token) {
       return reply.code(401).send({ error: 'Unauthorized' });
     }
     // 验证 token
     try {
       const decoded = jwt.verify(token, process.env.JWT_SECRET);
       request.user = decoded;
       done();
     } catch (error) {
       reply.code(401).send({ error: 'Invalid token' });
     }
   };
   ```

3. 实现登录接口
   ```javascript
   // server/routes/auth.api.js
   fastify.post('/auth/login', async (request, reply) => {
     const { username, password } = request.body;
     // 验证用户名密码
     // 生成 JWT token
     const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, {
       expiresIn: '24h'
     });
     return { token, user };
   });
   ```

4. 集成到现有 API
   - 添加认证中间件到需要保护的接口
   - 定义公开接口白名单

**验收标准**：
- ✅ 可以成功登录并获取 Token
- ✅ 使用 Token 可以访问受保护的接口
- ✅ 无效 Token 返回 401
- ✅ Token 过期后需要重新登录

**测试用例**：
- 正常登录测试
- 错误密码测试
- 无效 Token 测试
- 过期 Token 测试

---

#### 任务 1.2：RBAC 权限控制实现
**优先级**：P0  
**工作量**：5 天

**实施步骤**：
1. 设计权限模型
   - 定义角色（admin, operator, viewer）
   - 定义权限（read, write, delete, manage）
   - 角色权限映射表

2. 创建权限表
   ```sql
   CREATE TABLE users (
     id VARCHAR(36) PRIMARY KEY,
     username VARCHAR(50) UNIQUE NOT NULL,
     password_hash VARCHAR(255) NOT NULL,
     role VARCHAR(20) NOT NULL,
     created_at TIMESTAMP DEFAULT NOW(),
     updated_at TIMESTAMP DEFAULT NOW()
   );
   
   CREATE TABLE roles (
     id VARCHAR(36) PRIMARY KEY,
     name VARCHAR(20) UNIQUE NOT NULL,
     permissions JSONB NOT NULL
   );
   ```

3. 实现权限检查中间件
   ```javascript
   // server/middleware/permission.js
   const rolePermissions = {
     admin: ['read', 'write', 'delete', 'manage'],
     operator: ['read', 'write'],
     viewer: ['read']
   };
   
   module.exports = function(permissions) {
     return function(request, reply, done) {
       const userRole = request.user.role;
       const userPermissions = rolePermissions[userRole] || [];
       const hasPermission = permissions.every(p => userPermissions.includes(p));
       
       if (!hasPermission) {
         return reply.code(403).send({ error: 'Forbidden' });
       }
       done();
     };
   };
   ```

4. 应用权限控制
   - 为每个 API 路由添加权限要求
   - 前端根据权限控制界面显示

**验收标准**：
- ✅ 不同角色有不同的权限
- ✅ 越权访问返回 403
- ✅ 前端根据权限显示/隐藏功能

**测试用例**：
- 不同角色权限测试
- 越权访问测试
- 权限修改后生效测试

---

#### 任务 1.3：审计日志实现
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 创建审计日志表
   ```sql
   CREATE TABLE audit_logs (
     id VARCHAR(36) PRIMARY KEY,
     user_id VARCHAR(36),
     action VARCHAR(50) NOT NULL,
     resource VARCHAR(100),
     details JSONB,
     ip_address VARCHAR(50),
     user_agent TEXT,
     created_at TIMESTAMP DEFAULT NOW()
   );
   ```

2. 实现审计中间件
   ```javascript
   // server/middleware/audit.js
   module.exports = function auditMiddleware(action) {
     return async function(request, reply, done) {
       const startTime = Date.now();
       const originalSend = reply.send;
       
       reply.send = function(data) {
         if (reply.statusCode < 400) {
           // 记录审计日志
           db.insert(auditLogs).values({
             userId: request.user?.id,
             action: action,
             resource: request.url,
             details: { method: request.method, body: request.body },
             ipAddress: request.ip,
             userAgent: request.headers['user-agent']
           });
         }
         return originalSend.call(this, data);
       };
       done();
     };
   };
   ```

3. 集成到敏感操作
   - 登录/登出
   - 规则创建/删除/修改
   - 通知配置修改

**验收标准**：
- ✅ 所有敏感操作都被记录
- ✅ 可以查询审计日志
- ✅ 日志包含完整信息

**测试用例**：
- 审计日志记录测试
- 审计日志查询测试

---

### 4.2 完善输入验证

#### 任务 1.4：统一输入验证
**优先级**：P0  
**工作量**：5 天

**实施步骤**：
1. 定义统一的 Schema
   ```javascript
   // server/schemas/alerts.js
   const { z } = require('zod');
   
   const alertRuleSchema = z.object({
     id: z.string().uuid().optional(),
     intentType: z.enum(['service', 'help', 'chat', 'welcome', 'risk', 'spam', 'admin', 'keyword']),
     ruleName: z.string().min(1).max(255),
     isEnabled: z.boolean().default(true),
     alertLevel: z.enum(['critical', 'warning', 'info']),
     threshold: z.number().int().min(1).max(100),
     cooldownPeriod: z.number().int().min(1).max(86400),
     messageTemplate: z.string().max(5000).optional(),
     keywords: z.string().max(1000).optional()
   });
   
   module.exports = { alertRuleSchema };
   ```

2. 创建验证中间件
   ```javascript
   // server/middleware/validate.js
   module.exports = function validate(schema) {
     return function(request, reply, done) {
       try {
         const validated = schema.parse(request.body);
         request.validatedBody = validated;
         done();
       } catch (error) {
         reply.code(400).send({
           error: 'Validation error',
           details: error.errors
         });
       }
     };
   };
   ```

3. 应用到所有 API
   - 为每个 API 添加对应的 Schema
   - 统一错误处理

4. XSS 防护
   ```javascript
   // server/lib/sanitize.js
   const sanitizeHtml = require('sanitize-html');
   
   module.exports = function sanitize(input) {
     if (typeof input === 'string') {
       return sanitizeHtml(input, {
         allowedTags: [],
         allowedAttributes: {}
       });
     }
     return input;
   };
   ```

**验收标准**：
- ✅ 所有 API 输入都经过验证
- ✅ 非法输入返回明确的错误信息
- ✅ XSS 攻击被防护
- ✅ SQL 注入被防护（Drizzle ORM 已支持）

**测试用例**：
- 正常输入测试
- 非法输入测试
- XSS 攻击测试
- SQL 注入测试

---

### 4.3 敏感信息防护

#### 任务 1.5：错误信息脱敏
**优先级**：P0  
**工作量**：2 天

**实施步骤**：
1. 定义环境变量
   ```javascript
   const isProduction = process.env.NODE_ENV === 'production';
   ```

2. 统一错误处理
   ```javascript
   // server/middleware/error-handler.js
   module.exports = function errorHandler(error, request, reply) {
     if (isProduction) {
       reply.code(error.statusCode || 500).send({
         error: error.message || 'Internal Server Error',
         code: error.code || 'INTERNAL_ERROR'
       });
     } else {
       reply.code(error.statusCode || 500).send({
         error: error.message,
         stack: error.stack,
         details: error.details
       });
     }
     
     // 记录详细日志到服务器
     logger.error('Error occurred', {
       error: error.message,
       stack: error.stack,
       request: {
         url: request.url,
         method: request.method,
         body: request.body
       }
     });
   };
   ```

3. 敏感字段过滤
   ```javascript
   // server/lib/filter-sensitive.js
   const sensitiveFields = ['password', 'token', 'secret', 'apiKey', 'privateKey'];
   
   module.exports = function filterSensitive(data) {
     const filtered = { ...data };
     sensitiveFields.forEach(field => {
       if (filtered[field]) {
         filtered[field] = '***';
       }
     });
     return filtered;
   };
   ```

**验收标准**：
- ✅ 生产环境不返回详细错误信息
- ✅ 敏感字段在日志和响应中被过滤
- ✅ 错误码统一规范

**测试用例**：
- 生产环境错误返回测试
- 开发环境错误返回测试
- 敏感字段过滤测试

---

### 4.4 数据库备份

#### 任务 1.6：自动备份实现
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 创建备份脚本
   ```bash
   # scripts/backup-db.sh
   #!/bin/bash
   
   BACKUP_DIR="/backups"
   DATE=$(date +%Y%m%d_%H%M%S)
   DB_URL=${DATABASE_URL}
   
   # 全量备份
   pg_dump $DB_URL > $BACKUP_DIR/full_$DATE.sql
   
   # 压缩
   gzip $BACKUP_DIR/full_$DATE.sql
   
   # 删除7天前的备份
   find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete
   
   echo "Backup completed: full_$DATE.sql.gz"
   ```

2. 配置定时任务
   ```bash
   # 添加到 crontab
   0 2 * * * /workspace/projects/scripts/backup-db.sh >> /var/log/backup.log 2>&1
   ```

3. 备份验证脚本
   ```bash
   # scripts/verify-backup.sh
   #!/bin/bash
   
   BACKUP_FILE=$1
   gunzip -c $BACKUP_FILE | head -20
   ```

**验收标准**：
- ✅ 每天自动备份数据库
- ✅ 备份文件可正常恢复
- ✅ 备份文件自动清理

**测试用例**：
- 备份脚本执行测试
- 备份恢复测试
- 备份清理测试

---

### 4.5 CORS 配置优化

#### 任务 1.7：CORS 安全配置
**优先级**：P1  
**工作量**：0.5 天

**实施步骤**：
1. 更新 CORS 配置
   ```javascript
   // server/app.js
   fastify.register(cors, {
     origin: function(origin, callback) {
       const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:5000'];
       if (!origin) return callback(null, true);
       if (allowedOrigins.indexOf(origin) !== -1) {
         callback(null, true);
       } else {
         callback(new Error('Not allowed by CORS'), false);
       }
     },
     credentials: true,
     methods: ['GET', 'POST', 'PUT', 'DELETE'],
     allowedHeaders: ['Content-Type', 'Authorization'],
     maxAge: 86400
   });
   ```

**验收标准**：
- ✅ 只有允许的域名可以访问
- ✅ 其他域名被拒绝

**测试用例**：
- 允许域名访问测试
- 拒绝域名访问测试

---

## 5. 第二阶段：核心性能优化（3-4 周）

### 5.1 数据库查询优化

#### 任务 2.1：添加索引
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 分析慢查询
   ```sql
   -- 查看慢查询
   SELECT query, mean_exec_time, calls 
   FROM pg_stat_statements 
   ORDER BY mean_exec_time DESC 
   LIMIT 10;
   ```

2. 添加必要的索引
   ```sql
   -- alert_history 表
   CREATE INDEX idx_alert_history_created_at_level ON alert_history(created_at, alert_level);
   CREATE INDEX idx_alert_history_session_id ON alert_history(session_id);
   
   -- session_messages 表
   CREATE INDEX idx_session_messages_session_created ON session_messages(session_id, created_at);
   
   -- execution_steps 表
   CREATE INDEX idx_execution_steps_processing ON execution_steps(processing_id, step_order);
   
   -- notification_methods 表
   CREATE INDEX idx_notification_methods_rule_enabled ON notification_methods(alert_rule_id, is_enabled);
   ```

3. 验证索引效果
   ```sql
   EXPLAIN ANALYZE SELECT * FROM alert_history WHERE created_at > '2026-02-01';
   ```

**验收标准**：
- ✅ 慢查询响应时间降低 > 50%
- ✅ EXPLAIN 显示使用索引
- ✅ 数据库 CPU 使用率降低

**测试用例**：
- 查询性能测试
- 索引使用验证测试

---

#### 任务 2.2：优化 N+1 查询
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 识别 N+1 查询
   ```javascript
   // 示例：查询告警规则及其通知方式
   const rules = await db.select().from(alertRules);
   
   // ❌ N+1 查询
   for (const rule of rules) {
     const methods = await db.select()
       .from(notificationMethods)
       .where(eq(notificationMethods.alertRuleId, rule.id));
   }
   
   // ✅ 使用 JOIN
   const rulesWithMethods = await db
     .select()
     .from(alertRules)
     .leftJoin(notificationMethods, eq(alertRules.id, notificationMethods.alertRuleId));
   ```

2. 批量查询优化
   ```javascript
   // 使用 IN 查询替代循环查询
   const ruleIds = rules.map(r => r.id);
   const allMethods = await db.select()
     .from(notificationMethods)
     .where(inArray(notificationMethods.alertRuleId, ruleIds));
   
   // 组装数据
   const methodsMap = new Map();
   allMethods.forEach(m => {
     if (!methodsMap.has(m.alertRuleId)) {
       methodsMap.set(m.alertRuleId, []);
     }
     methodsMap.get(m.alertRuleId).push(m);
   });
   ```

**验收标准**：
- ✅ 消除所有 N+1 查询
- ✅ 查询次数明显减少
- ✅ 响应时间降低

**测试用例**：
- 查询次数统计测试
- 性能对比测试

---

#### 任务 2.3：实现分页和限制
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 定义分页参数
   ```javascript
   const paginationSchema = z.object({
     page: z.number().int().min(1).default(1),
     pageSize: z.number().int().min(1).max(100).default(20)
   });
   ```

2. 实现分页查询
   ```javascript
   async function getAlertRulesPaginated(page, pageSize) {
     const db = await getDb();
     const offset = (page - 1) * pageSize;
     
     const rules = await db.select()
       .from(alertRules)
       .limit(pageSize)
       .offset(offset);
     
     const [{ count }] = await db.select({ count: sql`count(*)` })
       .from(alertRules);
     
     return {
       data: rules,
       pagination: {
         page,
         pageSize,
         total: count,
         totalPages: Math.ceil(count / pageSize)
       }
     };
   }
   ```

3. 限制查询时间范围
   ```javascript
   // 历史记录查询限制最近 90 天
   const ninetyDaysAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
   
   const history = await db.select()
     .from(alertHistory)
     .where(gte(alertHistory.createdAt, ninetyDaysAgo))
     .orderBy(desc(alertHistory.createdAt))
     .limit(100);
   ```

**验收标准**：
- ✅ 所有列表查询都支持分页
- ✅ 历史记录查询限制时间范围
- ✅ 查询性能提升

**测试用例**：
- 分页功能测试
- 边界值测试
- 大数据量测试

---

### 5.2 Redis 使用优化

#### 任务 2.4：强制启用 Redis
**优先级**：P1  
**工作量**：2 天

**实施步骤**：
1. 修改启动检查
   ```javascript
   // server/app.js
   async function checkRedis() {
     try {
       await redisClient.ping();
       logger.info('Redis connection verified');
     } catch (error) {
       logger.error('Redis connection failed, system cannot start');
       process.exit(1);
     }
   }
   
   // 在启动时检查
   await checkRedis();
   ```

2. 实现自动重连
   ```javascript
   redisClient.on('error', (error) => {
     logger.error('Redis error:', error);
   });
   
   redisClient.on('close', async () => {
     logger.warn('Redis connection closed, attempting to reconnect...');
     try {
       await redisClient.connect();
       logger.info('Redis reconnected successfully');
     } catch (error) {
       logger.error('Redis reconnection failed:', error);
       // 重试逻辑
       setTimeout(() => redisClient.connect(), 5000);
     }
   });
   ```

3. 实现健康检查
   ```javascript
   fastify.get('/health/redis', async () => {
     try {
       await redisClient.ping();
       return { status: 'ok', latency: Date.now() - startTime };
     } catch (error) {
       reply.code(503).send({ status: 'error', message: error.message });
     }
   });
   ```

**验收标准**：
- ✅ Redis 不可用时系统拒绝启动
- ✅ 连接断开时自动重连
- ✅ 健康检查正常

**测试用例**：
- Redis 连接失败测试
- 自动重连测试
- 健康检查测试

---

#### 任务 2.5：统一缓存策略
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 定义缓存键规范
   ```javascript
   // server/lib/cache.js
   const CACHE_PREFIX = 'worktool:';
   
   function buildKey(module, identifier) {
     return `${CACHE_PREFIX}${module}:${identifier}`;
   }
   
   // 示例
   buildKey('intent', 'service');  // worktool:intent:service
   buildKey('session', 'session_123');  // worktool:session:session_123
   ```

2. 定义 TTL 策略
   ```javascript
   const TTL = {
     SHORT: 300,      // 5 分钟
     MEDIUM: 1800,    // 30 分钟
     LONG: 3600,      // 1 小时
     VERY_LONG: 86400 // 1 天
   };
   
   const MODULE_TTL = {
     intent: TTL.MEDIUM,
     session: TTL.LONG,
     robot: TTL.SHORT,
     alertRule: TTL.SHORT
   };
   ```

3. 实现缓存封装
   ```javascript
   async function getOrSet(key, ttl, factory) {
     const cached = await redisClient.get(key);
     if (cached) {
       return JSON.parse(cached);
     }
     
     const value = await factory();
     await redisClient.setex(key, ttl, JSON.stringify(value));
     return value;
   }
   
   // 使用示例
   const intent = await getOrSet(
     buildKey('intent', intentType),
     TTL.MEDIUM,
     () => getIntentConfigByType(intentType)
   );
   ```

4. 缓存预热
   ```javascript
   async function warmupCache() {
     logger.info('Starting cache warmup...');
     
     // 预加载常用意图配置
     const intents = ['service', 'help', 'chat', 'risk', 'spam'];
     for (const intent of intents) {
       await getOrSet(buildKey('intent', intent), TTL.MEDIUM, () => 
         getIntentConfigByType(intent)
       );
     }
     
     logger.info('Cache warmup completed');
   }
   
   // 在启动时预热
   await warmupCache();
   ```

**验收标准**：
- ✅ 缓存键命名统一
- ✅ TTL 策略合理
- ✅ 缓存命中率 > 70%

**测试用例**：
- 缓存读写测试
- TTL 过期测试
- 缓存穿透测试

---

### 5.3 AI 请求优化

#### 任务 2.6：实现结果缓存
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 内容哈希
   ```javascript
   const crypto = require('crypto');
   
   function hashContent(content, context) {
     const hashInput = JSON.stringify({ content, context });
     return crypto.createHash('sha256').update(hashInput).digest('hex');
   }
   ```

2. 缓存 AI 结果
   ```javascript
   async function recognizeIntentWithCache(content, context) {
     const cacheKey = `ai:intent:${hashContent(content, context)}`;
     const cached = await redisClient.get(cacheKey);
     
     if (cached) {
       logger.debug('AI intent cache hit', { cacheKey });
       return JSON.parse(cached);
     }
     
     const result = await recognizeIntent(content, context);
     await redisClient.setex(cacheKey, 600, JSON.stringify(result)); // 10 分钟
     return result;
   }
   ```

3. 缓存失效策略
   ```javascript
   // 意图配置更新时清除相关缓存
   async function clearIntentCache(intentType) {
     const pattern = `ai:intent:*`;
     const keys = await redisClient.keys(pattern);
     if (keys.length > 0) {
       await redisClient.del(...keys);
       logger.info(`Cleared ${keys.length} AI intent cache entries`);
     }
   }
   ```

**验收标准**：
- ✅ 相同内容直接返回缓存
- ✅ 缓存命中率 > 40%
- ✅ AI API 调用次数降低

**测试用例**：
- 缓存命中测试
- 缓存失效测试
- API 调用次数统计测试

---

#### 任务 2.7：降级策略
**优先级**：P2  
**工作量**：2 天

**实施步骤**：
1. 实现规则匹配
   ```javascript
   async function recognizeIntentWithFallback(content, context) {
     try {
       return await recognizeIntent(content, context);
     } catch (error) {
       logger.warn('AI recognition failed, using fallback', { error });
       
       // 规则匹配降级
       return matchIntentByRules(content);
     }
   }
   
   function matchIntentByRules(content) {
     // 简单的关键词匹配
     if (content.includes('风险') || content.includes('违规')) {
       return { intent: 'risk', confidence: 0.7 };
     }
     if (content.includes('广告') || content.includes('推广')) {
       return { intent: 'spam', confidence: 0.7 };
     }
     // ...
     return { intent: 'chat', confidence: 0.5 };
   }
   ```

**验收标准**：
- ✅ AI 服务不可用时降级到规则匹配
- ✅ 降级后基本功能可用

**测试用例**：
- AI 服务正常测试
- AI 服务不可用测试
- 降级功能测试

---

### 5.4 统一错误处理

#### 任务 2.8：创建统一错误类
**优先级**：P1  
**工作量**：2 天

**实施步骤**：
1. 定义错误类
   ```javascript
   // server/lib/errors.js
   class AppError extends Error {
     constructor(message, code, statusCode = 500) {
       super(message);
       this.name = 'AppError';
       this.code = code;
       this.statusCode = statusCode;
       this.isOperational = true;
       Error.captureStackTrace(this, this.constructor);
     }
   }
   
   // 预定义错误
   class ValidationError extends AppError {
     constructor(message) {
       super(message, 'VALIDATION_ERROR', 400);
     }
   }
   
   class NotFoundError extends AppError {
     constructor(resource) {
       super(`${resource} not found`, 'NOT_FOUND', 404);
     }
   }
   
   class UnauthorizedError extends AppError {
     constructor(message = 'Unauthorized') {
       super(message, 'UNAUTHORIZED', 401);
     }
   }
   
   class ForbiddenError extends AppError {
     constructor(message = 'Forbidden') {
       super(message, 'FORBIDDEN', 403);
     }
   }
   
   module.exports = {
     AppError,
     ValidationError,
     NotFoundError,
     UnauthorizedError,
     ForbiddenError
   };
   ```

2. 定义错误码
   ```javascript
   const ERROR_CODES = {
     // 认证授权 (1000-1999)
     INVALID_TOKEN: 1001,
     TOKEN_EXPIRED: 1002,
     INVALID_CREDENTIALS: 1003,
     FORBIDDEN: 1004,
     
     // 业务逻辑 (2000-2999)
     VALIDATION_ERROR: 2001,
     NOT_FOUND: 2002,
     DUPLICATE_ENTRY: 2003,
     INVALID_STATE: 2004,
     
     // 系统错误 (3000-3999)
     DATABASE_ERROR: 3001,
     REDIS_ERROR: 3002,
     AI_SERVICE_ERROR: 3003,
     EXTERNAL_API_ERROR: 3004
   };
   ```

**验收标准**：
- ✅ 所有错误使用统一的错误类
- ✅ 错误码规范统一
- ✅ 错误信息清晰

**测试用例**：
- 错误类使用测试
- 错误码规范测试

---

## 6. 第三阶段：架构和代码质量（4-6 周）

### 6.1 前后端分离优化

#### 任务 3.1：API 契约定义
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 创建 TypeScript 类型定义
   ```typescript
   // types/api.d.ts
   export interface AlertRule {
     id: string;
     intentType: IntentType;
     ruleName: string;
     isEnabled: boolean;
     alertLevel: AlertLevel;
     threshold: number;
     cooldownPeriod: number;
     messageTemplate?: string;
     keywords?: string;
     createdAt: string;
     updatedAt: string;
   }
   
   export type IntentType = 'service' | 'help' | 'chat' | 'welcome' | 'risk' | 'spam' | 'admin' | 'keyword';
   export type AlertLevel = 'critical' | 'warning' | 'info';
   
   export interface ApiResponse<T> {
     success: boolean;
     data?: T;
     error?: string;
     code?: string;
   }
   
   export interface PaginatedResponse<T> {
     data: T[];
     pagination: {
       page: number;
       pageSize: number;
       total: number;
       totalPages: number;
     };
   }
   ```

2. 创建 API 客户端
   ```typescript
   // lib/api-client.ts
   import axios, { AxiosInstance } from 'axios';
   
   class ApiClient {
     private client: AxiosInstance;
   
     constructor() {
       this.client = axios.create({
         baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5001',
         timeout: 30000
       });
     
       this.client.interceptors.request.use((config) => {
         const token = localStorage.getItem('token');
         if (token) {
           config.headers.Authorization = `Bearer ${token}`;
         }
         return config;
       });
     }
   
     async get<T>(url: string, params?: any): Promise<ApiResponse<T>> {
       const response = await this.client.get<ApiResponse<T>>(url, { params });
       return response.data;
     }
   
     async post<T>(url: string, data: any): Promise<ApiResponse<T>> {
       const response = await this.client.post<ApiResponse<T>>(url, data);
       return response.data;
     }
   
     async put<T>(url: string, data: any): Promise<ApiResponse<T>> {
       const response = await this.client.put<ApiResponse<T>>(url, data);
       return response.data;
     }
   
     async delete<T>(url: string): Promise<ApiResponse<T>> {
       const response = await this.client.delete<ApiResponse<T>>(url);
       return response.data;
     }
   }
   
   export const apiClient = new ApiClient();
   ```

**验收标准**：
- ✅ API 契约清晰定义
- ✅ 类型安全
- ✅ API 客户端统一封装

**测试用例**：
- API 调用测试
- 类型安全测试
- 错误处理测试

---

### 6.2 统一状态管理

#### 任务 3.2：使用 Zustand 管理状态
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 安装 Zustand
   ```bash
   pnpm add zustand
   ```

2. 创建 Store
   ```typescript
   // store/app-store.ts
   import { create } from 'zustand';
   import { persist } from 'zustand/middleware';
   
   interface AppState {
     // 用户信息
     user: User | null;
     setUser: (user: User | null) => void;
     
     // 机器人列表
     robots: Robot[];
     setRobots: (robots: Robot[]) => void;
     
     // 告警规则
     alertRules: AlertRule[];
     setAlertRules: (rules: AlertRule[]) => void;
     updateAlertRule: (id: string, rule: Partial<AlertRule>) => void;
     
     // WebSocket 连接
     wsConnected: boolean;
     setWsConnected: (connected: boolean) => void;
     
     // 重置
     reset: () => void;
   }
   
   export const useAppStore = create<AppState>()(
     persist(
       (set) => ({
         // 初始状态
         user: null,
         robots: [],
         alertRules: [],
         wsConnected: false,
         
         // Actions
         setUser: (user) => set({ user }),
         setRobots: (robots) => set({ robots }),
         setAlertRules: (alertRules) => set({ alertRules }),
         updateAlertRule: (id, updates) => set((state) => ({
           alertRules: state.alertRules.map((rule) =>
             rule.id === id ? { ...rule, ...updates } : rule
           )
         })),
         setWsConnected: (wsConnected) => set({ wsConnected }),
         reset: () => set({
           user: null,
           robots: [],
           alertRules: [],
           wsConnected: false
         })
       }),
       {
         name: 'app-storage',
         partialize: (state) => ({
           user: state.user,
           robots: state.robots
         })
       }
     )
   );
   ```

3. 在组件中使用
   ```typescript
   // components/AlertRulesList.tsx
   import { useAppStore } from '@/store/app-store';
   
   function AlertRulesList() {
     const alertRules = useAppStore((state) => state.alertRules);
     const setAlertRules = useAppStore((state) => state.setAlertRules);
     
     useEffect(() => {
       loadAlertRules();
     }, []);
     
     async function loadAlertRules() {
       const response = await apiClient.get<AlertRule[]>('/api/alerts/rules');
       if (response.success && response.data) {
         setAlertRules(response.data);
       }
     }
     
     return (
       // ...
     );
   }
   ```

**验收标准**：
- ✅ 全局状态统一管理
- ✅ 状态持久化
- ✅ 组件间状态共享正常

**测试用例**：
- 状态读写测试
- 持久化测试
- 组件共享测试

---

### 6.3 类型定义完善

#### 任务 3.3：后端类型定义
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 使用 JSDoc 完善类型
   ```javascript
   /**
    * @typedef {Object} AlertRule
    * @property {string} id - 规则 ID
    * @property {string} intentType - 意图类型
    * @property {string} ruleName - 规则名称
    * @property {boolean} isEnabled - 是否启用
    * @property {'critical'|'warning'|'info'} alertLevel - 告警级别
    * @property {number} threshold - 触发阈值
    * @property {number} cooldownPeriod - 冷却时间（秒）
    * @property {string} [messageTemplate] - 消息模板
    * @property {string} [keywords] - 关键词
    * @property {string} createdAt - 创建时间
    * @property {string} updatedAt - 更新时间
    */
   
   /**
    * @typedef {Object} ApiResponse
    * @property {boolean} success - 是否成功
    * @property {T} [data] - 返回数据
    * @property {string} [error] - 错误信息
    * @property {string} [code] - 错误码
    * @template T
    */
   
   /**
    * 获取所有告警规则
    * @returns {Promise<ApiResponse<AlertRule[]>>}
    */
   async function getAllAlertRules() {
     // ...
   }
   ```

2. 启用严格模式
   ```javascript
   // jsconfig.json
   {
     "compilerOptions": {
       "checkJs": true,
       "strict": true,
       "noImplicitAny": true,
       "strictNullChecks": true
     }
   }
   ```

**验收标准**：
- ✅ 所有函数都有类型定义
- ✅ 类型检查通过
- ✅ 智能提示正常

**测试用例**：
- 类型检查测试
- 智能提示测试

---

### 6.4 单元测试

#### 任务 3.4：添加测试框架
**优先级**：P2  
**工作量**：7 天

**实施步骤**：
1. 安装测试依赖
   ```bash
   pnpm add -D vitest @vitest/ui jsdom @testing-library/react @testing-library/jest-dom
   ```

2. 配置 Vitest
   ```javascript
   // vitest.config.js
   import { defineConfig } from 'vitest/config';
   import react from '@vitejs/plugin-react';
   
   export default defineConfig({
     plugins: [react()],
     test: {
       globals: true,
       environment: 'jsdom',
       setupFiles: ['./test/setup.js'],
       coverage: {
         provider: 'v8',
         reporter: ['text', 'json', 'html'],
         exclude: ['node_modules/', 'test/']
       }
     }
   });
   ```

3. 编写测试用例
   ```javascript
   // test/alert-config.service.test.js
   import { describe, it, expect, vi, beforeEach } from 'vitest';
   import alertConfigService from '../server/services/alert-config.service.js';
   
   describe('AlertConfigService', () => {
     beforeEach(() => {
       vi.clearAllMocks();
     });
   
     describe('getAllAlertRules', () => {
       it('should return all alert rules', async () => {
         const rules = await alertConfigService.getAllAlertRules();
         expect(Array.isArray(rules)).toBe(true);
         expect(rules.length).toBeGreaterThan(0);
       });
   
       it('should return rules with correct structure', async () => {
         const rules = await alertConfigService.getAllAlertRules();
         if (rules.length > 0) {
           expect(rules[0]).toHaveProperty('id');
           expect(rules[0]).toHaveProperty('intentType');
           expect(rules[0]).toHaveProperty('ruleName');
         }
       });
     });
   
     describe('upsertAlertRule', () => {
       it('should create a new rule', async () => {
         const newRule = {
           intentType: 'test',
           ruleName: 'Test Rule',
           isEnabled: true,
           alertLevel: 'info',
           threshold: 1,
           cooldownPeriod: 300
         };
         
         const result = await alertConfigService.upsertAlertRule(newRule);
         expect(result).toHaveProperty('id');
         expect(result.intentType).toBe('test');
       });
     });
   });
   ```

4. 添加到 package.json
   ```json
   {
     "scripts": {
       "test": "vitest",
       "test:ui": "vitest --ui",
       "test:coverage": "vitest --coverage"
     }
   }
   ```

**验收标准**：
- ✅ 核心功能有测试覆盖
- ✅ 测试覆盖率 > 60%
- ✅ CI/CD 中自动运行测试

**测试用例**：
- 测试执行测试
- 覆盖率测试

---

### 6.5 代码重复消除

#### 任务 3.5：提取公共工具
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 创建工具库
   ```javascript
   // lib/utils.js
   
   // 日期格式化
   export function formatDate(date, format = 'YYYY-MM-DD HH:mm:ss') {
     const d = new Date(date);
     const year = d.getFullYear();
     const month = String(d.getMonth() + 1).padStart(2, '0');
     const day = String(d.getDate()).padStart(2, '0');
     const hours = String(d.getHours()).padStart(2, '0');
     const minutes = String(d.getMinutes()).padStart(2, '0');
     const seconds = String(d.getSeconds()).padStart(2, '0');
     
     return format
       .replace('YYYY', year)
       .replace('MM', month)
       .replace('DD', day)
       .replace('HH', hours)
       .replace('mm', minutes)
       .replace('ss', seconds);
   }
   
   // 防抖
   export function debounce(func, wait) {
     let timeout;
     return function executedFunction(...args) {
       const later = () => {
         clearTimeout(timeout);
         func(...args);
       };
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
     };
   }
   
   // 节流
   export function throttle(func, limit) {
     let inThrottle;
     return function(...args) {
       if (!inThrottle) {
         func.apply(this, args);
         inThrottle = true;
         setTimeout(() => inThrottle = false, limit);
       }
     };
   }
   
   // 深拷贝
   export function deepClone(obj) {
     return JSON.parse(JSON.stringify(obj));
   }
   
   // UUID 生成
   export function generateId() {
     return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
       const r = Math.random() * 16 | 0;
       const v = c === 'x' ? r : (r & 0x3 | 0x8);
       return v.toString(16);
     });
   }
   ```

2. 替换重复代码
   - 搜索并替换所有的日期格式化代码
   - 搜索并替换所有的防抖/节流代码
   - 搜索并替换所有的深拷贝代码

**验收标准**：
- ✅ 公共工具统一封装
- ✅ 重复代码消除
- ✅ 工具函数有单元测试

**测试用例**：
- 工具函数测试
- 替换后功能测试

---

## 7. 第四阶段：扩展性和可维护性（4-5 周）

### 7.1 告警规则引擎优化

#### 任务 4.1：实现动态规则引擎
**优先级**：P1  
**工作量**：7 天

**实施步骤**：
1. 设计规则引擎架构
   ```javascript
   // server/lib/rule-engine.js
   
   class RuleEngine {
     constructor() {
       this.rules = new Map();
       this.loadRules();
     }
   
     async loadRules() {
       const db = await getDb();
       const rules = await db.select().from(alertRules);
       
       this.rules.clear();
       rules.forEach(rule => {
         this.rules.set(rule.id, this.parseRule(rule));
       });
     }
   
     parseRule(rule) {
       return {
         id: rule.id,
         name: rule.ruleName,
         conditions: this.parseConditions(rule),
         actions: this.parseActions(rule),
         metadata: {
           intentType: rule.intentType,
           alertLevel: rule.alertLevel,
           threshold: rule.threshold,
           cooldownPeriod: rule.cooldownPeriod
         }
       };
     }
   
     parseConditions(rule) {
       // 解析条件表达式
       const conditions = [];
       
       // 基于意图类型的条件
       conditions.push({
         field: 'intentType',
         operator: '==',
         value: rule.intentType
       });
       
       // 基于关键词的条件（如果有）
       if (rule.keywords) {
         const keywordList = rule.keywords.split(',').map(k => k.trim());
         conditions.push({
           field: 'content',
           operator: 'containsAny',
           value: keywordList
         });
       }
       
       return conditions;
     }
   
     parseActions(rule) {
       return [
         {
           type: 'triggerAlert',
           config: {
             level: rule.alertLevel,
             messageTemplate: rule.messageTemplate
           }
         }
       ];
     }
   
     async evaluate(context) {
       const results = [];
       
       for (const [ruleId, rule] of this.rules) {
         if (!rule.metadata.isEnabled) continue;
         
         if (this.matchesConditions(rule.conditions, context)) {
           results.push({
             ruleId,
             ruleName: rule.name,
             matched: true
           });
         }
       }
       
       return results;
     }
   
     matchesConditions(conditions, context) {
       return conditions.every(condition => {
         switch (condition.operator) {
           case '==':
             return context[condition.field] === condition.value;
           case 'contains':
             return context[condition.field]?.includes(condition.value);
           case 'containsAny':
             return condition.value.some(v => context[condition.field]?.includes(v));
           default:
             return false;
         }
       });
     }
   
     async executeActions(rule, context) {
       for (const action of rule.actions) {
         switch (action.type) {
           case 'triggerAlert':
             await this.triggerAlert(action.config, context);
             break;
           // 其他动作类型
         }
       }
     }
   
     async triggerAlert(config, context) {
       const alertData = {
         level: config.level,
         message: this.renderTemplate(config.messageTemplate, context),
         ...context
       };
       
       await alertTriggerService.triggerAlert(alertData);
     }
   
     renderTemplate(template, context) {
       return template.replace(/\{(\w+)\}/g, (_, key) => {
         return context[key] || '';
       });
     }
   }
   
   const ruleEngine = new RuleEngine();
   module.exports = ruleEngine;
   ```

2. 支持自定义条件
   ```javascript
   // 支持表达式语言
   const conditions = [
     {
       type: 'expression',
       expression: 'intentType == "risk" && confidence > 0.8'
     }
   ];
   ```

3. 支持自定义动作
   ```javascript
   const actions = [
     {
       type: 'sendNotification',
       config: {
         method: 'robot',
         recipients: ['admin'],
         messageTemplate: '告警: {message}'
       }
     }
   ];
   ```

**验收标准**：
- ✅ 规则动态加载
- ✅ 支持自定义条件
- ✅ 支持自定义动作
- ✅ 规则测试功能

**测试用例**：
- 规则加载测试
- 条件匹配测试
- 动作执行测试

---

### 7.2 日志系统完善

#### 任务 4.2：统一日志格式
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 定义日志结构
   ```javascript
   // server/lib/logger.js
   const LOG_LEVELS = {
     ERROR: 'ERROR',
     WARN: 'WARN',
     INFO: 'INFO',
     DEBUG: 'DEBUG'
   };
   
   function log(level, module, message, context = {}) {
     const logEntry = {
       timestamp: new Date().toISOString(),
       level,
       module,
       message,
       context,
       pid: process.pid,
       hostname: require('os').hostname()
     };
     
     // 输出到控制台
     console.log(JSON.stringify(logEntry));
     
     // 保存到数据库（异步）
     saveLogToDatabase(logEntry).catch(err => {
       console.error('Failed to save log:', err);
     });
   }
   
   module.exports = {
     error: (module, message, context) => log(LOG_LEVELS.ERROR, module, message, context),
     warn: (module, message, context) => log(LOG_LEVELS.WARN, module, message, context),
     info: (module, message, context) => log(LOG_LEVELS.INFO, module, message, context),
     debug: (module, message, context) => log(LOG_LEVELS.DEBUG, module, message, context)
   };
   ```

2. 日志级别控制
   ```javascript
   const currentLevel = process.env.LOG_LEVEL || 'INFO';
   const levelOrder = [LOG_LEVELS.DEBUG, LOG_LEVELS.INFO, LOG_LEVELS.WARN, LOG_LEVELS.ERROR];
   
   function shouldLog(level) {
     return levelOrder.indexOf(level) >= levelOrder.indexOf(currentLevel);
   }
   ```

3. 敏感信息过滤
   ```javascript
   function sanitizeContext(context) {
     const sensitiveKeys = ['password', 'token', 'secret', 'apiKey'];
     const sanitized = { ...context };
     
     sensitiveKeys.forEach(key => {
       if (sanitized[key]) {
         sanitized[key] = '***';
       }
     });
     
     return sanitized;
   }
   ```

**验收标准**：
- ✅ 日志格式统一
- ✅ 日志级别可配置
- ✅ 敏感信息被过滤
- ✅ 日志可查询

**测试用例**：
- 日志格式测试
- 日志级别测试
- 敏感信息过滤测试

---

### 7.3 配置管理优化

#### 任务 4.3：统一配置管理
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 创建配置管理
   ```javascript
   // server/lib/config.js
   const { z } = require('zod');
   
   const configSchema = z.object({
     // 数据库配置
     database: z.object({
       url: z.string().url(),
       poolSize: z.number().int().min(1).max(20).default(10)
     }),
   
     // Redis 配置
     redis: z.object({
       url: z.string().url(),
       keyPrefix: z.string().default('worktool:')
     }),
   
     // AI 配置
     ai: z.object({
       apiKey: z.string(),
       baseURL: z.string().url(),
       model: z.string().default('gpt-4'),
       timeout: z.number().int().min(1000).max(60000).default(30000)
     }),
   
     // WorkTool 配置
     worktool: z.object({
       apiUrl: z.string().url(),
       apiToken: z.string()
     }),
   
     // 安全配置
     security: z.object({
       jwtSecret: z.string().min(32),
      jwtExpiresIn: z.string().default('24h'),
      bcryptRounds: z.number().int().min(10).max(15).default(10)
     }),
   
     // 服务器配置
     server: z.object({
       port: z.number().int().min(1).max(65535).default(5001),
      host: z.string().default('0.0.0.0')
     })
   });
   
   function loadConfig() {
     const rawConfig = {
       database: {
         url: process.env.DATABASE_URL,
         poolSize: parseInt(process.env.DB_POOL_SIZE || '10')
       },
       redis: {
         url: process.env.REDIS_URL || 'redis://localhost:6379',
         keyPrefix: process.env.REDIS_KEY_PREFIX || 'worktool:'
       },
       ai: {
         apiKey: process.env.AI_API_KEY,
         baseURL: process.env.AI_API_BASE_URL || 'https://api.openai.com/v1',
         model: process.env.AI_MODEL || 'gpt-4',
         timeout: parseInt(process.env.AI_TIMEOUT || '30000')
       },
       worktool: {
         apiUrl: process.env.WORKTOOL_API_URL,
         apiToken: process.env.WORKTOOL_API_TOKEN
       },
       security: {
         jwtSecret: process.env.JWT_SECRET,
         jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',
         bcryptRounds: parseInt(process.env.BCRYPT_ROUNDS || '10')
       },
       server: {
         port: parseInt(process.env.PORT || '5001'),
         host: process.env.HOST || '0.0.0.0'
       }
     };
     
     try {
       return configSchema.parse(rawConfig);
     } catch (error) {
       console.error('Config validation failed:', error.errors);
       process.exit(1);
     }
   }
   
   const config = loadConfig();
   module.exports = config;
   ```

2. 配置文档
   ```markdown
   # 环境变量配置
   
   ## 数据库配置
   - DATABASE_URL: PostgreSQL 数据库连接字符串
   - DB_POOL_SIZE: 数据库连接池大小 (默认: 10)
   
   ## Redis 配置
   - REDIS_URL: Redis 连接字符串
   - REDIS_KEY_PREFIX: Redis 键前缀 (默认: worktool:)
   
   ## AI 配置
   - AI_API_KEY: AI 服务 API Key
   - AI_API_BASE_URL: AI 服务地址 (默认: https://api.openai.com/v1)
   - AI_MODEL: AI 模型名称 (默认: gpt-4)
   - AI_TIMEOUT: 请求超时时间，毫秒 (默认: 30000)
   
   ## 安全配置
   - JWT_SECRET: JWT 签名密钥（至少32字符）
   - JWT_EXPIRES_IN: Token 过期时间 (默认: 24h)
   - BCRYPT_ROUNDS: bcrypt 加密轮数 (默认: 10)
   ```

**验收标准**：
- ✅ 配置统一管理
- ✅ 配置有验证
- ✅ 配置文档完整

**测试用例**：
- 配置加载测试
- 配置验证测试
- 缺失配置测试

---

### 7.4 文档完善

#### 任务 4.4：API 文档
**优先级**：P2  
**工作量**：5 天

**实施步骤**：
1. 使用 Swagger
   ```javascript
   // server/app.js
   const swagger = require('@fastify/swagger');
   const swaggerUi = require('@fastify/swagger-ui');
   
   fastify.register(swagger, {
     openapi: {
       openapi: '3.0.0',
       info: {
         title: 'WorkTool AI API',
         version: '1.0.0',
         description: 'WorkTool AI 中枢系统 API 文档'
       },
       servers: [
         {
           url: 'http://localhost:5001',
           description: 'Development server'
         }
       ],
       components: {
         securitySchemes: {
           bearerAuth: {
             type: 'http',
             scheme: 'bearer',
             bearerFormat: 'JWT'
           }
         }
       },
       security: [{
         bearerAuth: []
       }]
     }
   });
   
   fastify.register(swaggerUi, {
     routePrefix: '/docs',
     uiConfig: {
       docExpansion: 'list',
       deepLinking: false
     }
   });
   ```

2. 添加 API 注释
   ```javascript
   /**
    * @route GET /api/alerts/rules
    * @summary 获取所有告警规则
    * @tags 告警管理
    * @security BearerAuth
    * @response 200 - 成功返回
    * @response 401 - 未授权
    * @response 500 - 服务器错误
    */
   fastify.get('/api/alerts/rules', async (request, reply) => {
     // ...
   });
   ```

**验收标准**：
- ✅ API 文档可访问
- ✅ 所有 API 都有文档
- ✅ 文档可以在线测试

**测试用例**：
- 文档访问测试
- API 测试功能测试

---

### 7.5 健康检查完善

#### 任务 4.5：增强健康检查
**优先级**：P1  
**工作量**：2 天

**实施步骤**：
1. 实现详细健康检查
   ```javascript
   fastify.get('/health', async async (request, reply) => {
     const checks = {
       status: 'ok',
       timestamp: new Date().toISOString(),
       checks: {}
     };
   
     // 数据库检查
     try {
       const db = await getDb();
       await db.execute(sql`SELECT 1`);
       checks.checks.database = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.database = { status: 'error', message: error.message };
     }
   
     // Redis 检查
     try {
       await redisClient.ping();
       checks.checks.redis = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.redis = { status: 'error', message: error.message };
     }
   
     // AI 服务检查
     try {
       await aiService.checkHealth();
       checks.checks.ai_service = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.ai_service = { status: 'error', message: error.message };
     }
   
     // WorkTool API 检查
     try {
       await worktoolService.checkHealth();
       checks.checks.worktool_api = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.worktool_api = { status: 'error', message: error.message };
     }
   
     const statusCode = checks.status === 'ok' ? 200 : 503;
     reply.code(statusCode).send(checks);
   });
   ```

**验收标准**：
- ✅ 健康检查包含所有依赖
- ✅ 健康状态准确
- ✅ 响应时间 < 1 秒

**测试用例**：
- 健康检查正常测试
- 依赖故障测试

---

## 8. 第五阶段：监控和体验优化（3-4 周）

### 8.1 系统监控实现

#### 任务 5.1：实现性能监控
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 定义监控指标
   ```javascript
   // server/lib/metrics.js
   const metrics = {
     // 性能指标
     httpRequestDuration: new Map(), // 请求耗时
     aiRequestDuration: new Map(),    // AI 请求耗时
     dbQueryDuration: new Map(),      // 数据库查询耗时
     
     // 业务指标
     messageProcessed: 0,             // 处理的消息数
     alertTriggered: 0,               // 触发的告警数
     aiRequests: 0,                   // AI 请求次数
     failedRequests: 0,               // 失败请求数
     
     // 资源指标
     cpuUsage: 0,
     memoryUsage: 0,
     activeConnections: 0
   };
   
   function recordHttpRequestDuration(duration, endpoint) {
     if (!metrics.httpRequestDuration.has(endpoint)) {
       metrics.httpRequestDuration.set(endpoint, []);
     }
     metrics.httpRequestDuration.get(endpoint).push(duration);
   }
   
   function getMetricsSummary() {
     return {
       performance: {
         avgHttpRequestDuration: calculateAverage(metrics.httpRequestDuration),
         avgAiRequestDuration: calculateAverage(metrics.aiRequestDuration),
         avgDbQueryDuration: calculateAverage(metrics.dbQueryDuration)
       },
       business: {
         messageProcessed: metrics.messageProcessed,
         alertTriggered: metrics.alertTriggered,
         aiRequests: metrics.aiRequests,
         failedRequests: metrics.failedRequests
       },
       resources: {
         cpuUsage: metrics.cpuUsage,
         memoryUsage: metrics.memoryUsage,
         activeConnections: metrics.activeConnections
       }
     };
   }
   
   function calculateAverage(map) {
     let total = 0;
     let count = 0;
     
     for (const values of map.values()) {
       total += values.reduce((a, b) => a + b, 0);
       count += values.length;
     }
     
     return count > 0 ? total / count : 0;
   }
   
   module.exports = {
     metrics,
     recordHttpRequestDuration,
     getMetricsSummary
   };
   ```

2. 集成到 Fastify
   ```javascript
   // server/app.js
   const { metrics, recordHttpRequestDuration } = require('./lib/metrics');
   
   fastify.addHook('onRequest', (request, reply, done) => {
     request.startTime = Date.now();
     done();
   });
   
   fastify.addHook('onResponse', (request, reply, done) => {
     const duration = Date.now() - request.startTime;
     recordHttpRequestDuration(duration, request.url);
     done();
   });
   
   // 监控端点
   fastify.get('/metrics', async (request, reply) => {
     reply.send(getMetricsSummary());
   });
   ```

**验收标准**：
- ✅ 性能指标可查询
- ✅ 业务指标可查询
- ✅ 资源指标可查询

**测试用例**：
- 指标记录测试
- 指标查询测试

---

#### 任务 5.2：告警规则
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 定义告警规则
   ```javascript
   const alertRules = [
     {
       name: 'High Error Rate',
       condition: 'failedRequests / totalRequests > 0.05',
       level: 'critical',
       notification: ['email', 'webhook']
     },
     {
       name: 'Slow Response Time',
       condition: 'avgHttpRequestDuration > 5000',
       level: 'warning',
       notification: ['email']
     },
     {
       name: 'High AI Request Rate',
       condition: 'aiRequests > 1000',
       level: 'info',
       notification: ['email']
     },
     {
       name: 'Database Connection Pool Exhausted',
       condition: 'activeConnections / poolSize > 0.9',
       level: 'critical',
       notification: ['email', 'webhook']
     }
   ];
   ```

2. 实现告警检查
   ```javascript
   async function checkAlerts() {
     const summary = getMetricsSummary();
     
     for (const rule of alertRules) {
       if (evaluateCondition(rule.condition, summary)) {
         await triggerAlert(rule, summary);
       }
     }
   }
   
   function evaluateCondition(condition, context) {
     // 简化的表达式求值
     try {
       // 这里可以使用更安全的表达式求值库
       return eval(condition);
     } catch (error) {
      logger.error('Alert condition evaluation failed:', error);
      return false;
     }
   }
   
   async function triggerAlert(rule, context) {
     logger.warn('Alert triggered', { rule: rule.name, level: rule.level });
     
     // 发送通知
     for (const method of rule.notification) {
       await sendNotification(method, {
         title: `Alert: ${rule.name}`,
         message: `Condition: ${rule.condition}`,
         level: rule.level,
         context
       });
     }
   }
   ```

3. 定时检查
   ```javascript
   // 每分钟检查一次
   setInterval(() => {
     checkAlerts();
   }, 60000);
   ```

**验收标准**：
- ✅ 告警规则正确触发
- ✅ 通知正确发送
- ✅ 避免重复告警

**测试用例**：
- 告警触发测试
- 告警通知测试

---

### 8.2 WebSocket 连接优化

#### 任务 5.3：实现自动重连
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 前端 WebSocket 管理
   ```typescript
   // hooks/use-websocket.ts
   export function useWebSocket(url: string) {
     const [isConnected, setIsConnected] = useState(false);
     const wsRef = useRef<WebSocket | null>(null);
     const reconnectAttempts = useRef(0);
     const maxReconnectAttempts = 5;
     const reconnectDelay = useRef(1000);
   
     const connect = useCallback(() => {
       if (wsRef.current?.readyState === WebSocket.OPEN) {
         return;
       }
   
       const ws = new WebSocket(url);
       wsRef.current = ws;
   
       ws.onopen = () => {
         console.log('WebSocket connected');
         setIsConnected(true);
         reconnectAttempts.current = 0;
         reconnectDelay.current = 1000;
       };
   
       ws.onclose = () => {
         console.log('WebSocket disconnected');
         setIsConnected(false);
         wsRef.current = null;
   
         // 自动重连
         if (reconnectAttempts.current < maxReconnectAttempts) {
           reconnectAttempts.current++;
           const delay = reconnectDelay.current * 2; // 指数退避
           console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts.current})`);
           
           setTimeout(() => {
             connect();
           }, delay);
         } else {
           console.error('Max reconnect attempts reached');
         }
       };
   
       ws.onerror = (error) => {
         console.error('WebSocket error:', error);
       };
   
       ws.onmessage = (event) => {
         // 处理消息
         console.log('WebSocket message:', event.data);
       };
     }, [url]);
   
     useEffect(() => {
       connect();
       
       return () => {
         if (wsRef.current) {
           wsRef.current.close();
         }
       };
     }, [connect]);
   
     const send = useCallback((data: any) => {
       if (wsRef.current?.readyState === WebSocket.OPEN) {
         wsRef.current.send(JSON.stringify(data));
       } else {
         console.warn('WebSocket is not connected');
       }
     }, []);
   
     return { isConnected, send };
   }
   ```

2. 心跳机制
   ```javascript
   // 后端
   fastify.register(async function (fastify) {
     fastify.register(websocket);
     
     const clients = new Set();
     
     fastify.get('/ws', { websocket: true }, (connection, req) => {
       clients.add(connection.socket);
       
       // 心跳检查
       const heartbeatInterval = setInterval(() => {
         connection.socket.ping();
       }, 30000);
     
       connection.socket.on('pong', () => {
         connection.socket.isAlive = true;
       });
     
       connection.socket.on('close', () => {
         clearInterval(heartbeatInterval);
         clients.delete(connection.socket);
       });
     });
     
     // 定期清理死连接
     setInterval(() => {
       clients.forEach(socket => {
         if (!socket.isAlive) {
           socket.terminate();
           clients.delete(socket);
         } else {
           socket.isAlive = false;
           socket.ping();
         }
       });
     }, 60000);
   });
   ```

**验收标准**：
- ✅ 断线自动重连
- ✅ 指数退避策略
- ✅ 心跳机制正常

**测试用例**：
- 断线重连测试
- 心跳测试
- 最大重连次数测试

---

### 8.3 前端性能优化

#### 任务 5.4：代码分割
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 路由级别懒加载
   ```typescript
   // app/monitoring/page.tsx
   import dynamic from 'next/dynamic';
   
   const MonitoringAlertCard = dynamic(() => 
     import('@/components/monitoring/MonitoringAlertCard'), 
     { loading: () => <p>Loading...</p> }
   );
   
   const MonitoringAlertCompact = dynamic(() =>
     import('@/components/monitoring/MonitoringAlertCompact'),
     { loading: () => <p>Loading...</p> }
   );
   ```

2. 组件级别懒加载
   ```typescript
   // components/monitoring/AlertRulesDialog.tsx
   const NotificationSettingsDialog = dynamic(() =>
     import('./NotificationSettingsDialog'),
     { loading: () => <p>Loading...</p> }
   );
   ```

**验收标准**：
- ✅ 首屏加载时间降低
- ✅ 初始包体积减小
- ✅ 懒加载组件正常

**测试用例**：
- 首屏加载测试
- 包体积分析测试
- 懒加载功能测试

---

#### 任务 5.5：图片优化
**优先级**：P2  
**工作量**：1 天

**实施步骤**：
1. 使用 Next.js Image 组件
   ```typescript
   import Image from 'next/image';
   
   <Image
     src="/logo.png"
     alt="Logo"
     width={200}
     height={50}
     priority
   />
   ```

2. 配置图片域名
   ```javascript
   // next.config.js
   module.exports = {
     images: {
       domains: ['example.com'],
       formats: ['image/avif', 'image/webp']
     }
   };
   ```

**验收标准**：
- ✅ 图片使用 CDN
- ✅ 图片格式优化
- ✅ 图片懒加载

**测试用例**：
- 图片加载测试
- 图片格式测试

---

### 8.4 错误提示优化

#### 任务 5.6：友好错误提示
**优先级**：P2  
**工作量**：2 天

**实施步骤**：
1. 定义错误信息映射
   ```typescript
   // lib/error-messages.ts
   const errorMessages: Record<string, string> = {
     // 网络错误
     NETWORK_ERROR: '网络连接失败，请检查网络设置',
     TIMEOUT: '请求超时，请稍后重试',
     
     // 认证错误
     UNAUTHORIZED: '请先登录',
     TOKEN_EXPIRED: '登录已过期，请重新登录',
     FORBIDDEN: '您没有权限执行此操作',
     
     // 业务错误
     VALIDATION_ERROR: '输入数据格式错误',
     NOT_FOUND: '资源不存在',
     DUPLICATE_ENTRY: '数据已存在',
     
     // 系统错误
     INTERNAL_ERROR: '系统错误，请稍后重试',
     DATABASE_ERROR: '数据库错误，请联系管理员',
     AI_SERVICE_ERROR: 'AI 服务暂时不可用，请稍后重试'
   };
   
   export function getErrorMessage(code: string): string {
     return errorMessages[code] || '未知错误';
   }
   ```

2. 统一错误处理
   ```typescript
   // components/ErrorBoundary.tsx
   export function ErrorBoundary({ children, fallback }) {
     return (
       <React.ErrorBoundary
         FallbackComponent={fallback}
         onError={(error) => {
           console.error('Error caught by boundary:', error);
           // 上报错误
           reportError(error);
         }}
       >
         {children}
       </React.ErrorBoundary>
     );
   }
   
   // components/ErrorFallback.tsx
   export function ErrorFallback({ error }) {
     return (
       <div className="p-8 text-center">
         <h2 className="text-2xl font-bold mb-4">出错了</h2>
         <p className="text-gray-600 mb-4">
           {getErrorMessage(error.code) || error.message}
         </p>
         <Button onClick={() => window.location.reload()}>
           重新加载
         </Button>
       </div>
     );
   }
   ```

**验收标准**：
- ✅ 错误信息友好
- ✅ 提供解决方案
- ✅ 错误分类清晰

**测试用例**：
- 错误提示测试
- 错误分类测试

---

### 8.5 数据归档策略

#### 任务 5.7：实现数据归档
**优先级**：P2  
**工作量**：4 天

**实施步骤**：
1. 创建归档表
   ```sql
   CREATE TABLE alert_history_archive (
     LIKE alert_history INCLUDING ALL
   );
   
   CREATE TABLE session_messages_archive (
     LIKE session_messages INCLUDING ALL
   );
   ```

2. 归档脚本
   ```bash
   # scripts/archive-data.sh
   #!/bin/bash
   
   # 归档 90 天前的告警历史
   psql $DATABASE_URL -c "
     INSERT INTO alert_history_archive
     SELECT * FROM alert_history
     WHERE created_at < NOW() - INTERVAL '90 days';
     
     DELETE FROM alert_history
     WHERE created_at < NOW() - INTERVAL '90 days';
   "
   
   # 归档 180 天前的会话消息
   psql $DATABASE_URL -c "
     INSERT INTO session_messages_archive
     SELECT * FROM session_messages
     WHERE created_at < NOW() - INTERVAL '180 days';
     
     DELETE FROM session_messages
     WHERE created_at < NOW() - INTERVAL '180 days';
   "
   
   echo "Archive completed: $(date)"
   ```

3. 定时任务
   ```bash
   # 每周日凌晨 2 点执行
   0 2 * * 0 /workspace/projects/scripts/archive-data.sh >> /var/log/archive.log 2>&1
   ```

**验收标准**：
- ✅ 数据自动归档
- ✅ 归档后查询性能提升
- ✅ 归档数据可恢复

**测试用例**：
- 归档脚本执行测试
- 数据恢复测试
- 性能对比测试

---

## 9. 第六阶段：UI设计完善（3-4 周）

### 9.1 设计规范和主题系统

#### 任务 6.1：创建设计令牌（Design Tokens）
**优先级**：P1  
**工作量**：3 天

**实施步骤**：

1. 创建设计令牌文件
   ```typescript
   // styles/tokens/colors.ts
   export const colorTokens = {
     // 品牌色
     primary: {
       50: '#EEF2FF',
       100: '#E0E7FF',
       200: '#C7D2FE',
       300: '#A5B4FC',
       400: '#818CF8',
       500: '#6366F1',  // 主色
       600: '#4F46E5',
       700: '#4338CA',
       800: '#3730A3',
       900: '#312E81',
       950: '#1E1B4B',
     },
     // 语义色
     semantic: {
       success: {
         50: '#F0FDF4',
         500: '#22C55E',
         900: '#14532D',
       },
       warning: {
         50: '#FFFBEB',
         500: '#F59E0B',
         900: '#78350F',
       },
       error: {
         50: '#FEF2F2',
         500: '#EF4444',
         900: '#7F1D1D',
       },
       info: {
         50: '#F0F9FF',
         500: '#3B82F6',
         900: '#1E3A8A',
       },
     },
     // 中性色
     neutral: {
       50: '#FAFAFA',
       100: '#F5F5F5',
       200: '#E5E5E5',
       300: '#D4D4D4',
       400: '#A3A3A3',
       500: '#737373',
       600: '#525252',
       700: '#404040',
       800: '#262626',
       900: '#171717',
       950: '#0A0A0A',
     },
   };

   // styles/tokens/spacing.ts
   export const spacingTokens = {
     xs: '4px',
     sm: '8px',
     md: '16px',
     lg: '24px',
     xl: '32px',
     '2xl': '48px',
     '3xl': '64px',
   };

   // styles/tokens/typography.ts
   export const typographyTokens = {
     fontFamily: {
       sans: ['Inter', 'system-ui', 'sans-serif'],
       mono: ['JetBrains Mono', 'monospace'],
     },
     fontSize: {
       xs: '0.75rem',    // 12px
       sm: '0.875rem',   // 14px
       base: '1rem',     // 16px
       lg: '1.125rem',   // 18px
       xl: '1.25rem',    // 20px
     },
     fontWeight: {
       normal: 400,
       medium: 500,
       semibold: 600,
       bold: 700,
     },
     lineHeight: {
       tight: 1.25,
       normal: 1.5,
       relaxed: 1.75,
     },
   };

   // styles/tokens/shadows.ts
   export const shadowTokens = {
     sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
     base: '0 1px 3px 0 rgb(0 0 0 / 0.1)',
     md: '0 4px 6px -1px rgb(0 0 0 / 0.1)',
     lg: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
     xl: '0 20px 25px -5px rgb(0 0 0 / 0.1)',
   };

   // styles/tokens/borders.ts
   export const borderTokens = {
     radius: {
       sm: '0.25rem',
       base: '0.5rem',
     lg: '0.75rem',
     xl: '1rem',
     full: '9999px',
     },
     width: {
       thin: '1px',
     base: '2px',
     },
   };

   // styles/tokens/index.ts
   export const designTokens = {
     colors: colorTokens,
     spacing: spacingTokens,
     typography: typographyTokens,
     shadows: shadowTokens,
     borders: borderTokens,
   };
   ```

2. 创建主题系统
   ```typescript
   // styles/theme/light-theme.ts
   import { designTokens } from './tokens';

   export const lightTheme = {
     name: 'light',
     colors: {
       background: designTokens.colors.neutral[50],
       foreground: designTokens.colors.neutral[900],
       primary: designTokens.colors.primary[500],
       primaryForeground: '#FFFFFF',
       card: '#FFFFFF',
     },
   };

   // styles/theme/dark-theme.ts
   export const darkTheme = {
     name: 'dark',
     colors: {
       background: designTokens.colors.neutral[950],
       foreground: designTokens.colors.neutral[50],
       primary: designTokens.colors.primary[500],
       primaryForeground: '#FFFFFF',
       card: designTokens.colors.neutral[900],
     },
   };

   // styles/theme/index.ts
   import { createTheme } from '@mui/material/styles';
   import { lightTheme, darkTheme } from './theme';

   export const themes = {
     light: createTheme({
       palette: {
         mode: 'light',
         ...lightTheme.colors,
       },
       typography: {
         ...designTokens.typography,
       },
     }),
     dark: createTheme({
       palette: {
         mode: 'dark',
         ...darkTheme.colors,
       },
       typography: {
         ...designTokens.typography,
       },
     }),
   };
   ```

3. 在 tailwind.config.ts 中集成
   ```typescript
   // tailwind.config.ts
   import type { Config } from 'tailwindcss';
   import { designTokens } from './styles/tokens';

   const config: Config = {
     content: [
       './src/**/*.{ts,tsx}',
     ],
     theme: {
       extend: {
         colors: {
           primary: designTokens.colors.primary,
           semantic: designTokens.colors.semantic,
           neutral: designTokens.colors.neutral,
         },
         spacing: designTokens.spacing,
         fontFamily: designTokens.typography.fontFamily,
         boxShadow: designTokens.shadows,
         borderRadius: designTokens.borders.radius,
       },
     },
     darkMode: 'class',
     plugins: [],
   };

   export default config;
   ```

**验收标准**：
- ✅ 设计令牌完整定义
- ✅ 主题系统支持切换
- ✅ Tailwind 配置正确集成
- ✅ 组件可使用设计令牌

---

### 9.2 组件库升级和扩展

#### 任务 6.2：扩展现有组件
**优先级**：P1  
**工作量**：5 天

**实施步骤**：

1. 升级 Button 组件
   ```typescript
   // components/ui/button.tsx
   import * as React from 'react';
   import { cva, type VariantProps } from 'class-variance-authority';
   import { cn } from '@/lib/utils';

   const buttonVariants = cva(
     'inline-flex items-center justify-center rounded-md text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
     {
       variants: {
         variant: {
           default: 'bg-primary-500 text-white hover:bg-primary-600 active:bg-primary-700',
           destructive: 'bg-semantic-error-500 text-white hover:bg-semantic-error-600',
           outline: 'border-2 border-neutral-300 bg-transparent hover:bg-neutral-100',
           secondary: 'bg-neutral-200 text-neutral-900 hover:bg-neutral-300',
           ghost: 'hover:bg-neutral-100',
           link: 'text-primary-500 underline-offset-4 hover:underline',
         },
         size: {
           sm: 'h-9 px-3 text-xs',
           default: 'h-10 px-4 py-2',
           lg: 'h-11 px-8',
           icon: 'h-10 w-10',
         },
       },
       defaultVariants: {
         variant: 'default',
         size: 'default',
       },
     }
   );

   export interface ButtonProps
     extends React.ButtonHTMLAttributes<HTMLButtonElement>,
       VariantProps<typeof buttonVariants> {
     asChild?: boolean;
     loading?: boolean;
   }

   const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
     ({ className, variant, size, loading, children, disabled, ...props }, ref) => {
       return (
         <button
           className={cn(buttonVariants({ variant, size, className }))}
           ref={ref}
           disabled={disabled || loading}
           {...props}
         >
           {loading && (
             <svg className="animate-spin -ml-1 mr-2 h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
               <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
               <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
             </svg>
           )}
           {children}
         </button>
       );
     }
   );
   Button.displayName = 'Button';

   export { Button, buttonVariants };
   ```

2. 升级 Card 组件
   ```typescript
   // components/ui/card.tsx
   import * as React from 'react';
   import { cn } from '@/lib/utils';

   const Card = React.forwardRef<
     HTMLDivElement,
     React.HTMLAttributes<HTMLDivElement>
   >(({ className, ...props }, ref) => (
     <div
       ref={ref}
       className={cn(
         'rounded-xl border border-neutral-200 bg-card text-foreground shadow-sm',
         className
       )}
       {...props}
     />
   ));
   Card.displayName = 'Card';

   const CardHeader = React.forwardRef<
     HTMLDivElement,
     React.HTMLAttributes<HTMLDivElement>
   >(({ className, ...props }, ref) => (
     <div
       ref={ref}
       className={cn('flex flex-col space-y-1.5 p-6', className)}
       {...props}
     />
   ));
   CardHeader.displayName = 'CardHeader';

   const CardTitle = React.forwardRef<
     HTMLParagraphElement,
     React.HTMLAttributes<HTMLHeadingElement>
   >(({ className, ...props }, ref) => (
     <h3
       ref={ref}
       className={cn('font-semibold leading-none tracking-tight', className)}
       {...props}
     />
   ));
   CardTitle.displayName = 'CardTitle';

   const CardDescription = React.forwardRef<
     HTMLParagraphElement,
     React.HTMLAttributes<HTMLParagraphElement>
   >(({ className, ...props }, ref) => (
     <p
       ref={ref}
       className={cn('text-sm text-muted-foreground', className)}
       {...props}
     />
   ));
   CardDescription.displayName = 'CardDescription';

   const CardContent = React.forwardRef<
     HTMLDivElement,
     React.HTMLAttributes<HTMLDivElement>
   >(({ className, ...props }, ref) => (
     <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
   ));
   CardContent.displayName = 'CardContent';

   const CardFooter = React.forwardRef<
     HTMLDivElement,
     React.HTMLAttributes<HTMLDivElement>
   >(({ className, ...props }, ref) => (
     <div
       ref={ref}
       className={cn('flex items-center p-6 pt-0', className)}
       {...props}
     />
   ));
   CardFooter.displayName = 'CardFooter';

   export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };
   ```

3. 创建新的数据表格组件
   ```typescript
   // components/ui/data-table.tsx
   import * as React from 'react';
   import { cn } from '@/lib/utils';

   interface DataTableProps<T> {
     data: T[];
     columns: Column<T>[];
     onRowClick?: (row: T) => void;
     className?: string;
   }

   interface Column<T> {
     key: keyof T;
     header: string;
     render?: (value: any, row: T) => React.ReactNode;
     sortable?: boolean;
   }

   function DataTable<T extends Record<string, any>>({
     data,
     columns,
     onRowClick,
     className,
   }: DataTableProps<T>) {
     const [sortColumn, setSortColumn] = React.useState<keyof T | null>(null);
     const [sortDirection, setSortDirection] = React.useState<'asc' | 'desc'>('asc');

     const handleSort = (key: keyof T) => {
       if (sortColumn === key) {
         setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
       } else {
         setSortColumn(key);
         setSortDirection('asc');
       }
     };

     const sortedData = React.useMemo(() => {
       if (!sortColumn) return data;

       return [...data].sort((a, b) => {
         const aVal = a[sortColumn];
         const bVal = b[sortColumn];

         if (typeof aVal === 'string' && typeof bVal === 'string') {
           return sortDirection === 'asc'
             ? aVal.localeCompare(bVal)
             : bVal.localeCompare(aVal);
         }

         if (typeof aVal === 'number' && typeof bVal === 'number') {
           return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
         }

         return 0;
       });
     }, [data, sortColumn, sortDirection]);

     return (
       <div className={cn('w-full overflow-auto', className)}>
         <table className="w-full caption-bottom text-sm">
           <thead className="[&_tr]:border-b">
             <tr>
               {columns.map((column) => (
                 <th
                   key={String(column.key)}
                   className={cn(
                     'h-12 px-4 text-left align-middle font-medium text-muted-foreground',
                     column.sortable && 'cursor-pointer hover:text-foreground'
                   )}
                   onClick={() => column.sortable && handleSort(column.key)}
                 >
                   <div className="flex items-center gap-2">
                     {column.header}
                     {sortColumn === column.key && (
                       <svg
                         className={`h-4 w-4 transition-transform ${
                           sortDirection === 'desc' ? 'rotate-180' : ''
                         }`}
                         fill="none"
                         stroke="currentColor"
                         viewBox="0 0 24 24"
                       >
                         <path
                           strokeLinecap="round"
                           strokeLinejoin="round"
                           strokeWidth={2}
                           d="M5 15l7-7 7 7"
                         />
                       </svg>
                     )}
                   </div>
                 </th>
               ))}
             </tr>
           </thead>
           <tbody className="[&_tr:last-child]:border-0">
             {sortedData.map((row, index) => (
               <tr
                 key={index}
                 className={cn(
                   'border-b transition-colors hover:bg-muted/50',
                   onRowClick && 'cursor-pointer'
                 )}
                 onClick={() => onRowClick?.(row)}
               >
                 {columns.map((column) => (
                   <td key={String(column.key)} className="p-4 align-middle">
                     {column.render
                       ? column.render(row[column.key], row)
                       : String(row[column.key] ?? '')}
                   </td>
                 ))}
               </tr>
             ))}
           </tbody>
         </table>
       </div>
     );
   }

   export { DataTable };
   ```

4. 创建状态卡片组件
   ```typescript
   // components/ui/status-card.tsx
   import * as React from 'react';
   { Card, CardContent } from '@/components/ui/card';
   { cn } from '@/lib/utils';

   interface StatusCardProps {
     title: string;
     value: string | number;
     change?: {
       value: number;
       type: 'increase' | 'decrease';
     };
     icon?: React.ReactNode;
     className?: string;
   }

   export function StatusCard({ title, value, change, icon, className }: StatusCardProps) {
     return (
       <Card className={cn('', className)}>
         <CardContent className="p-6">
           <div className="flex items-center justify-between">
             <div className="flex-1">
               <p className="text-sm font-medium text-muted-foreground">{title}</p>
               <p className="text-3xl font-bold mt-2">{value}</p>
               {change && (
                 <p
                   className={cn(
                     'text-sm mt-2',
                     change.type === 'increase' ? 'text-semantic-success-500' : 'text-semantic-error-500'
                   )}
                 >
                   {change.type === 'increase' ? '↑' : '↓'} {Math.abs(change.value)}%
                 </p>
               )}
             </div>
             {icon && (
               <div className="p-3 bg-primary-50 rounded-lg">
                 {icon}
               </div>
             )}
           </div>
         </CardContent>
       </Card>
     );
   }
   ```

**验收标准**：
- ✅ 组件样式统一
- ✅ 组件支持暗色模式
- ✅ 组件响应式适配
- ✅ 组件可访问性符合标准

---

### 9.3 响应式设计优化

#### 任务 6.3：实现响应式布局
**优先级**：P1  
**工作量**：3 天

**实施步骤**：

1. 创建响应式布局组件
   ```typescript
   // components/layout/responsive-layout.tsx
   import * as React from 'react';
   { cn } from '@/lib/utils';

   interface ResponsiveLayoutProps {
     children: React.ReactNode;
     sidebar?: React.ReactNode;
     header?: React.ReactNode;
     className?: string;
   }

   export function ResponsiveLayout({ children, sidebar, header, className }: ResponsiveLayoutProps) {
     const [isSidebarOpen, setIsSidebarOpen] = React.useState(true);
     const [isMobile, setIsMobile] = React.useState(false);

     React.useEffect(() => {
       const checkMobile = () => setIsMobile(window.innerWidth < 768);
       checkMobile();
       window.addEventListener('resize', checkMobile);
       return () => window.removeEventListener('resize', checkMobile);
     }, []);

     React.useEffect(() => {
       if (isMobile) {
         setIsSidebarOpen(false);
       }
     }, [isMobile]);

     return (
       <div className={cn('flex h-screen bg-background', className)}>
         {/* 侧边栏 */}
         {sidebar && (
           <aside
             className={cn(
               'fixed inset-y-0 left-0 z-50 w-64 bg-card border-r transition-transform duration-300 md:relative',
               isSidebarOpen ? 'translate-x-0' : '-translate-x-full'
             )}
           >
             {sidebar}
           </aside>
         )}

         {/* 主内容区 */}
         <div className="flex-1 flex flex-col overflow-hidden">
           {/* 顶部导航 */}
           {header && (
             <header className="h-16 border-b bg-card flex items-center px-4 md:px-6">
               <button
                 onClick={() => setIsSidebarOpen(!isSidebarOpen)}
                 className="md:hidden p-2 rounded-md hover:bg-muted"
               >
                 <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                   <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                 </svg>
               </button>
               {header}
             </header>
           )}

           {/* 内容区域 */}
           <main className="flex-1 overflow-auto p-4 md:p-6">
             {children}
           </main>
         </div>

         {/* 遮罩层（移动端） */}
         {isSidebarOpen && isMobile && (
           <div
             className="fixed inset-0 bg-black/50 z-40 md:hidden"
             onClick={() => setIsSidebarOpen(false)}
           />
         )}
       </div>
     );
   }
   ```

2. 优化现有页面响应式
   ```typescript
   // 示例：监控仪表盘
   export function MonitoringDashboard() {
     return (
       <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
         <StatusCard title="今日消息" value="1,234" />
         <StatusCard title="活跃用户" value="56" />
         <StatusCard title="告警数" value="12" />
         <StatusCard title="机器人" value="8" />
       </div>
     );
   }
   ```

3. 创建响应式网格系统
   ```typescript
   // components/layout/grid.tsx
   import * as React from 'react';
   { cn } from '@/lib/utils';

   interface GridProps {
     children: React.ReactNode;
     cols?: {
       default?: number;
       sm?: number;
       md?: number;
       lg?: number;
       xl?: number;
       '2xl'?: number;
     };
     gap?: 'sm' | 'md' | 'lg';
     className?: string;
   }

   export function Grid({ children, cols, gap = 'md', className }: GridProps) {
     const gapClasses = {
       sm: 'gap-2',
       md: 'gap-4',
       lg: 'gap-6',
     };

     const colClasses = [
       cols?.default && `grid-cols-${cols.default}`,
       cols?.sm && `sm:grid-cols-${cols.sm}`,
       cols?.md && `md:grid-cols-${cols.md}`,
       cols?.lg && `lg:grid-cols-${cols.lg}`,
       cols?.xl && `xl:grid-cols-${cols.xl}`,
       cols?.['2xl'] && `2xl:grid-cols-${cols['2xl']}`,
     ].filter(Boolean).join(' ');

     return (
       <div className={cn('grid', gapClasses[gap], colClasses, className)}>
         {children}
       </div>
     );
   }
   ```

**验收标准**：
- ✅ 支持手机、平板、桌面设备
- ✅ 侧边栏响应式折叠
- ✅ 内容区域自适应
- ✅ 断点合理（640px, 768px, 1024px, 1280px, 1536px）

---

### 9.4 暗色模式实现

#### 任务 6.4：实现主题切换
**优先级**：P1  
**工作量**：2 天

**实施步骤**：

1. 创建主题上下文
   ```typescript
   // contexts/theme-context.tsx
   'use client';

   import React, { createContext, useContext, useEffect, useState } from 'react';

   type Theme = 'light' | 'dark' | 'system';

   interface ThemeContextType {
     theme: Theme;
     setTheme: (theme: Theme) => void;
     actualTheme: 'light' | 'dark';
   }

   const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

   export function ThemeProvider({ children }: { children: React.ReactNode }) {
     const [theme, setThemeState] = useState<Theme>('system');
     const [actualTheme, setActualTheme] = useState<'light' | 'dark'>('light');

     useEffect(() => {
       const root = window.document.documentElement;
       root.classList.remove('light', 'dark');

       let resolvedTheme: 'light' | 'dark';

       if (theme === 'system') {
         resolvedTheme = window.matchMedia('(prefers-color-scheme: dark)').matches
           ? 'dark'
           : 'light';
       } else {
         resolvedTheme = theme;
       }

       root.classList.add(resolvedTheme);
       setActualTheme(resolvedTheme);
     }, [theme]);

     const setTheme = (newTheme: Theme) => {
       setThemeState(newTheme);
       localStorage.setItem('theme', newTheme);
     };

     // 初始化主题
     useEffect(() => {
       const savedTheme = localStorage.getItem('theme') as Theme;
       if (savedTheme) {
         setThemeState(savedTheme);
       }
     }, []);

     return (
       <ThemeContext.Provider value={{ theme, setTheme, actualTheme }}>
         {children}
       </ThemeContext.Provider>
     );
   }

   export function useTheme() {
     const context = useContext(ThemeContext);
     if (context === undefined) {
       throw new Error('useTheme must be used within a ThemeProvider');
     }
     return context;
   }
   ```

2. 创建主题切换组件
   ```typescript
   // components/theme/theme-toggle.tsx
   'use client';

   import { useTheme } from '@/contexts/theme-context';
   { Button } from '@/components/ui/button';

   export function ThemeToggle() {
     const { theme, setTheme } = useTheme();

     return (
       <div className="flex items-center gap-2">
         <Button
           variant="outline"
           size="sm"
           onClick={() => setTheme('light')}
           className={theme === 'light' ? 'bg-primary-50' : ''}
         >
           <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
           </svg>
         </Button>
         <Button
           variant="outline"
           size="sm"
           onClick={() => setTheme('dark')}
           className={theme === 'dark' ? 'bg-primary-50' : ''}
         >
           <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
           </svg>
         </Button>
         <Button
           variant="outline"
           size="sm"
           onClick={() => setTheme('system')}
           className={theme === 'system' ? 'bg-primary-50' : ''}
         >
           <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
           </svg>
         </Button>
       </div>
     );
   }
   ```

3. 在根布局中应用
   ```typescript
   // app/layout.tsx
   import { ThemeProvider } from '@/contexts/theme-context';

   export default function RootLayout({ children }: { children: React.ReactNode }) {
     return (
       <html lang="zh-CN" suppressHydrationWarning>
         <body>
           <ThemeProvider>{children}</ThemeProvider>
         </body>
       </html>
     );
   }
   ```

**验收标准**：
- ✅ 支持亮色/暗色/自动三种模式
- ✅ 主题切换流畅
- ✅ 主题状态持久化
- ✅ 所有组件支持暗色模式

---

### 9.5 交互动效和过渡效果

#### 任务 6.5：添加动画效果
**优先级**：P2  
**工作量**：2 天

**实施步骤**：

1. 安装动画库
   ```bash
   pnpm add framer-motion
   pnpm add -D @types/framer-motion
   ```

2. 创建动画组件
   ```typescript
   // components/animations/fade-in.tsx
   import { motion } from 'framer-motion';

   export function FadeIn({ children, delay = 0 }: { children: React.ReactNode; delay?: number }) {
     return (
       <motion.div
         initial={{ opacity: 0, y: 20 }}
         animate={{ opacity: 1, y: 0 }}
         transition={{ duration: 0.3, delay }}
       >
         {children}
       </motion.div>
     );
   }

   // components/animations/slide-in.tsx
   export function SlideIn({ 
     children, 
     direction = 'right',
     delay = 0 
   }: { 
     children: React.ReactNode; 
     direction?: 'left' | 'right' | 'up' | 'down'; 
     delay?: number;
   }) {
     const variants = {
       left: { x: -50, opacity: 0 },
       right: { x: 50, opacity: 0 },
       up: { y: -50, opacity: 0 },
       down: { y: 50, opacity: 0 },
     };

     return (
       <motion.div
         initial={variants[direction]}
         animate={{ x: 0, y: 0, opacity: 1 }}
         transition={{ duration: 0.3, delay }}
       >
         {children}
       </motion.div>
     );
   }

   // components/animations/scale-in.tsx
   export function ScaleIn({ children, delay = 0 }: { children: React.ReactNode; delay?: number }) {
     return (
       <motion.div
         initial={{ scale: 0.95, opacity: 0 }}
         animate={{ scale: 1, opacity: 1 }}
         transition={{ duration: 0.2, delay }}
       >
         {children}
       </motion.div>
     );
   }
   ```

3. 添加加载动画
   ```typescript
   // components/animations/loading.tsx
   import { motion } from 'framer-motion';

   export function LoadingSpinner() {
     return (
       <div className="flex items-center justify-center">
         <motion.div
           className="w-8 h-8 border-2 border-primary-500 border-t-transparent rounded-full"
           animate={{ rotate: 360 }}
           transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
         />
       </div>
     );
   }

   export function LoadingSkeleton({ className }: { className?: string }) {
     return (
       <motion.div
         className={cn('bg-muted animate-pulse rounded', className)}
         initial={{ opacity: 0.5 }}
         animate={{ opacity: 1 }}
         transition={{ duration: 0.8, repeat: Infinity, repeatType: 'reverse' }}
       />
     );
   }
   ```

4. 添加过渡效果到组件
   ```typescript
   // 添加到现有的 Modal 组件
   export function Modal({ isOpen, onClose, children }: ModalProps) {
     return (
       <AnimatePresence>
         {isOpen && (
           <>
             <motion.div
               className="fixed inset-0 bg-black/50"
               initial={{ opacity: 0 }}
               animate={{ opacity: 1 }}
               exit={{ opacity: 0 }}
               onClick={onClose}
             />
             <motion.div
               className="fixed inset-0 flex items-center justify-center z-50"
               initial={{ opacity: 0 }}
               animate={{ opacity: 1 }}
               exit={{ opacity: 0 }}
             >
               <motion.div
                 initial={{ scale: 0.95, opacity: 0 }}
                 animate={{ scale: 1, opacity: 1 }}
                 exit={{ scale: 0.95, opacity: 0 }}
                 transition={{ type: 'spring', damping: 20 }}
                 className="bg-card rounded-lg shadow-lg p-6"
               >
                 {children}
               </motion.div>
             </motion.div>
           </>
         )}
       </AnimatePresence>
     );
   }
   ```

**验收标准**：
- ✅ 动画流畅不卡顿
- ✅ 动画性能良好（60fps）
- ✅ 可以禁用动画（降低动画偏好）
- ✅ 动画符合预期效果

---

### 9.6 数据可视化组件完善

#### 任务 6.6：创建图表组件
**优先级**：P2  
**工作量**：4 天

**实施步骤**：

1. 安装图表库
   ```bash
   pnpm add recharts
   pnpm add -D @types/recharts
   ```

2. 创建统计图表组件
   ```typescript
   // components/charts/line-chart.tsx
   import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

   interface LineChartProps {
     data: Array<{ name: string; value: number }>;
     title?: string;
     color?: string;
   }

   export function SimpleLineChart({ data, title, color = '#6366F1' }: LineChartProps) {
     return (
       <div className="w-full">
         {title && <h3 className="text-lg font-semibold mb-4">{title}</h3>}
         <ResponsiveContainer width="100%" height={300}>
           <LineChart data={data}>
             <CartesianGrid strokeDasharray="3 3" />
             <XAxis dataKey="name" />
             <YAxis />
             <Tooltip />
             <Line type="monotone" dataKey="value" stroke={color} strokeWidth={2} />
           </LineChart>
         </ResponsiveContainer>
       </div>
     );
   }

   // components/charts/bar-chart.tsx
   import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

   interface BarChartProps {
     data: Array<{ name: string; value: number }>;
     title?: string;
     color?: string;
   }

   export function SimpleBarChart({ data, title, color = '#6366F1' }: BarChartProps) {
     return (
       <div className="w-full">
         {title && <h3 className="text-lg font-semibold mb-4">{title}</h3>}
         <ResponsiveContainer width="100%" height={300}>
           <BarChart data={data}>
             <CartesianGrid strokeDasharray="3 3" />
             <XAxis dataKey="name" />
             <YAxis />
             <Tooltip />
             <Bar dataKey="value" fill={color} />
           </BarChart>
         </ResponsiveContainer>
       </div>
     );
   }

   // components/charts/pie-chart.tsx
   import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';

   interface PieChartProps {
     data: Array<{ name: string; value: number }>;
     title?: string;
     colors?: string[];
   }

   const DEFAULT_COLORS = ['#6366F1', '#22C55E', '#F59E0B', '#EF4444', '#3B82F6'];

   export function SimplePieChart({ data, title, colors = DEFAULT_COLORS }: PieChartProps) {
     return (
       <div className="w-full">
         {title && <h3 className="text-lg font-semibold mb-4">{title}</h3>}
         <ResponsiveContainer width="100%" height={300}>
           <PieChart>
             <Pie
               data={data}
               cx="50%"
               cy="50%"
               labelLine={false}
               label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
               outerRadius={80}
               fill="#8884d8"
               dataKey="value"
             >
               {data.map((entry, index) => (
                 <Cell key={`cell-${index}`} fill={colors[index % colors.length]} />
               ))}
             </Pie>
             <Tooltip />
             <Legend />
           </PieChart>
         </ResponsiveContainer>
       </div>
     );
   }
   ```

3. 创建趋势卡片组件
   ```typescript
   // components/charts/trend-card.tsx
   import { TrendingUp, TrendingDown } from 'lucide-react';
   { Card, CardContent } from '@/components/ui/card';

   interface TrendCardProps {
     title: string;
     value: string | number;
     change: number;
     chartData?: Array<{ name: string; value: number }>;
   }

   export function TrendCard({ title, value, change, chartData }: TrendCardProps) {
     const isPositive = change >= 0;

     return (
       <Card>
         <CardContent className="p-6">
           <div className="flex items-center justify-between mb-4">
             <div>
               <p className="text-sm text-muted-foreground">{title}</p>
               <p className="text-2xl font-bold mt-1">{value}</p>
             </div>
             <div
               className={`flex items-center gap-1 px-2 py-1 rounded-full ${
                 isPositive ? 'bg-semantic-success-50 text-semantic-success-600' : 'bg-semantic-error-50 text-semantic-error-600'
               }`}
             >
               {isPositive ? <TrendingUp className="w-4 h-4" /> : <TrendingDown className="w-4 h-4" />}
               <span className="text-sm font-medium">{Math.abs(change)}%</span>
             </div>
           </div>
           {chartData && (
             <SimpleLineChart data={chartData} color={isPositive ? '#22C55E' : '#EF4444'} />
           )}
         </CardContent>
       </Card>
     );
   }
   ```

4. 创建实时数据仪表盘
   ```typescript
   // components/dashboard/realtime-dashboard.tsx
   'use client';

   import { useEffect, useState } from 'react';
   { TrendCard } from '@/components/charts/trend-card';
   { SimpleBarChart } from '@/components/charts/bar-chart';
   { SimplePieChart } from '@/components/charts/pie-chart';

   export function RealtimeDashboard() {
     const [data, setData] = useState({
       messages: 1234,
       activeUsers: 56,
       alerts: 12,
       robots: 8,
     });

     useEffect(() => {
       // 模拟实时数据更新
       const interval = setInterval(() => {
         setData(prev => ({
           ...prev,
           messages: prev.messages + Math.floor(Math.random() * 10),
         }));
       }, 5000);

       return () => clearInterval(interval);
     }, []);

     const messageTrend = [
       { name: '周一', value: 120 },
       { name: '周二', value: 150 },
       { name: '周三', value: 180 },
       { name: '周四', value: 140 },
       { name: '周五', value: 200 },
     ];

     const alertDistribution = [
       { name: '严重', value: 3 },
       { name: '警告', value: 5 },
       { name: '信息', value: 4 },
     ];

     return (
       <div className="space-y-6">
         <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
           <TrendCard
             title="今日消息"
             value={data.messages}
             change={12}
             chartData={messageTrend}
           />
           <TrendCard
             title="活跃用户"
             value={data.activeUsers}
             change={8}
           />
           <TrendCard
             title="告警数"
             value={data.alerts}
             change={-5}
           />
           <TrendCard
             title="在线机器人"
             value={data.robots}
             change={0}
           />
         </div>

         <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
           <SimpleBarChart data={messageTrend} title="消息趋势" />
           <SimplePieChart data={alertDistribution} title="告警分布" />
         </div>
       </div>
     );
   }
   ```

**验收标准**：
- ✅ 图表渲染正确
- ✅ 图表响应式适配
- ✅ 数据实时更新流畅
- ✅ 图表样式统一

---

## 10. 第七阶段：高级特性（4-6 周）

### 9.1 消息队列引入

#### 任务 6.1：使用 Redis Stream
**优先级**：P2  
**工作量**：5 天

**实施步骤**：
1. 创建消息队列
   ```javascript
   // server/lib/message-queue.js
   class MessageQueue {
     constructor(redisClient) {
       this.redis = redisClient;
       this.queues = {
         alerts: 'queue:alerts',
         ai: 'queue:ai',
         notifications: 'queue:notifications'
       };
     }
   
     async produce(queueName, message) {
       const id = await this.redis.xadd(this.queues[queueName], '*', 'data', JSON.stringify(message));
       return id;
     }
   
     async consume(queueName, callback, consumerGroup = 'default') {
       const queueKey = this.queues[queueName];
       
       // 创建消费者组
       try {
         await this.redis.xgroup('CREATE', queueKey, consumerGroup, '0', 'MKSTREAM');
       } catch (error) {
         // 组已存在，忽略
       }
   
       const consumerId = `consumer-${process.pid}`;
     
       while (true) {
         const result = await this.redis.xreadgroup(
           'GROUP', consumerGroup, consumerId,
           'COUNT', 1,
           'BLOCK', 5000,
           'STREAMS', queueKey, '>'
         );
   
         if (result && result.length > 0) {
           const [stream, messages] = result[0];
           for (const [id, fields] of messages) {
             const data = JSON.parse(fields.data);
             try {
               await callback(data);
               await this.redis.xack(queueKey, consumerGroup, id);
             } catch (error) {
               console.error('Message processing failed:', error);
               // 重新入队（最多重试 3 次）
               const retryCount = parseInt(fields.retryCount || '0');
               if (retryCount < 3) {
                 await this.redis.xadd(queueKey, '*', 'data', fields.data, 'retryCount', retryCount + 1);
                 await this.redis.xack(queueKey, consumerGroup, id);
               } else {
                 // 死信队列
                 await this.redis.xadd(`${queueKey}:dlq`, '*', 'data', fields.data, 'error', error.message);
                 await this.redis.xack(queueKey, consumerGroup, id);
               }
             }
           }
         }
       }
     }
   }
   
   const messageQueue = new MessageQueue(redisClient);
   module.exports = messageQueue;
   ```

2. 集成告警通知
   ```javascript
   // 修改告警触发逻辑
   async function triggerAlert(alertData) {
     // 发送到队列
     await messageQueue.produce('alerts', alertData);
   }
   
   // 消费告警通知
   messageQueue.consume('alerts', async (alertData) => {
     await notificationService.sendNotifications(alertData);
   });
   ```

**验收标准**：
- ✅ 消息队列正常工作
- ✅ 消息不丢失
- ✅ 支持重试和死信队列

**测试用例**：
- 消息生产测试
- 消息消费测试
- 重试机制测试
- 死信队列测试

---

### 9.2 通知方式扩展

#### 任务 6.2：插件化架构
**优先级**：P2  
**工作量：5 天

**实施步骤**：
1. 定义通知插件接口
   ```javascript
   // server/lib/notification-plugins/base.js
   class NotificationPlugin {
     constructor(config) {
       this.config = config;
       this.name = this.constructor.name;
     }
   
     async send(recipients, message) {
       throw new Error('send method must be implemented');
     }
   
     async test() {
       throw new Error('test method must be implemented');
     }
   
     validateConfig(config) {
       throw new Error('validateConfig method must be implemented');
     }
   }
   
   module.exports = NotificationPlugin;
   ```

2. 实现机器人通知插件
   ```javascript
   // server/lib/notification-plugins/robot.js
   const NotificationPlugin = require('./base');
   
   class RobotNotificationPlugin extends NotificationPlugin {
     validateConfig(config) {
       if (!config.robotId || !config.apiToken) {
         throw new Error('robotId and apiToken are required');
       }
     }
   
     async send(recipients, message) {
       const { robotId, apiToken } = this.config;
       
       const results = [];
       for (const recipient of recipients) {
         try {
           await worktoolService.sendMessage({
             robotId,
             apiToken,
             ...recipient,
             content: message
           });
           results.push({ recipient, success: true });
         } catch (error) {
           results.push({ recipient, success: false, error: error.message });
         }
       }
       
       return results;
     }
   
     async test() {
       return this.send(
         [{ userName: 'Test User', groupName: 'Test Group' }],
         '这是一条测试消息'
       );
     }
   }
   
   module.exports = RobotNotificationPlugin;
   ```

3. 插件管理器
   ```javascript
   // server/lib/notification-plugins/manager.js
   class NotificationPluginManager {
     constructor() {
       this.plugins = new Map();
       this.loadPlugins();
     }
   
     loadPlugins() {
       const robotPlugin = require('./robot');
       this.register('robot', robotPlugin);
       
       // 加载其他插件
       // this.register('email', require('./email'));
       // this.register('sms', require('./sms'));
     }
   
     register(name, pluginClass) {
       this.plugins.set(name, pluginClass);
     }
   
     async send(methodType, config, recipients, message) {
       const PluginClass = this.plugins.get(methodType);
       if (!PluginClass) {
         throw new Error(`Unknown notification method: ${methodType}`);
       }
   
       const plugin = new PluginClass(config);
       return plugin.send(recipients, message);
     }
   
     async test(methodType, config) {
       const PluginClass = this.plugins.get(methodType);
       if (!PluginClass) {
         throw new Error(`Unknown notification method: ${methodType}`);
       }
   
       const plugin = new PluginClass(config);
       return plugin.test();
     }
   }
   
   const pluginManager = new NotificationPluginManager();
   module.exports = pluginManager;
   ```

**验收标准**：
- ✅ 插件可动态加载
- ✅ 新增通知方式只需实现插件
- ✅ 插件测试功能正常

**测试用例**：
- 插件加载测试
- 插件发送测试
- 插件测试功能测试

---

### 9.3 AI 模型切换

#### 任务 6.3：模型抽象层
**优先级**：P2  
**工作量：5 天

**实施步骤**：
1. 定义 AI 服务接口
   ```javascript
   // server/lib/ai-providers/base.js
   class AIProvider {
     constructor(config) {
       this.config = config;
       this.name = this.constructor.name;
     }
   
     async chat(messages, options = {}) {
       throw new Error('chat method must be implemented');
     }
   
     async getModels() {
       throw new Error('getModels method must be implemented');
     }
   
     validateConfig(config) {
       throw new Error('validateConfig method must be implemented');
     }
   }
   
   module.exports = AIProvider;
   ```

2. 实现 OpenAI 提供者
   ```javascript
   // server/lib/ai-providers/openai.js
   const AIProvider = require('./base');
   const OpenAI = require('openai');
   
   class OpenAIProvider extends AIProvider {
     validateConfig(config) {
       if (!config.apiKey) {
         throw new Error('apiKey is required');
       }
     }
   
     getClient() {
       return new OpenAI({
         apiKey: this.config.apiKey,
         baseURL: this.config.baseURL
       });
     }
   
     async chat(messages, options = {}) {
       const client = this.getClient();
       const response = await client.chat.completions.create({
         model: this.config.model || 'gpt-4',
         messages: messages,
         temperature: options.temperature || 0.7,
         max_tokens: options.maxTokens || 1000
       });
     
       return {
         content: response.choices[0].message.content,
         usage: response.usage,
        model: response.model
       };
     }
   
     async getModels() {
       const client = this.getClient();
      const models = await client.models.list();
       return models.data.map(m => m.id);
     }
   }
   
   module.exports = OpenAIProvider;
   ```

3. 模型路由器
   ```javascript
   // server/lib/ai-router.js
   class AIRouter {
     constructor() {
       this.providers = new Map();
       this.routingRules = [];
       this.loadProviders();
     }
   
     loadProviders() {
     const OpenAIProvider = require('./ai-providers/openai');
     this.providers.set('openai', OpenAIProvider);
   
     // 加载其他提供者
     // this.providers.set('anthropic', require('./ai-providers/anthropic'));
     // this.providers.set('deepseek', require('./ai-providers/deepseek'));
   }
   
     addRoutingRule(rule) {
       this.routingRules.push(rule);
     }
   
     async route(messages, options = {}) {
       // 评估路由规则
       for (const rule of this.routingRules) {
         if (this.matchRule(rule, messages, options)) {
           const provider = this.getProvider(rule.provider);
           return provider.chat(messages, { ...options, model: rule.model });
         }
       }
   
       // 默认使用第一个提供者
       const defaultProvider = this.getProvider('openai');
       return defaultProvider.chat(messages, options);
     }
   
     matchRule(rule, messages, options) {
       // 根据规则匹配
       if (rule.scenario === 'intent_recognition') {
         return options.purpose === 'intent_recognition';
       }
       if (rule.scenario === 'reply_generation') {
         return options.purpose === 'reply_generation';
       }
       return false;
     }
   
     getProvider(name) {
       const ProviderClass = this.providers.get(name);
       if (!ProviderClass) {
         throw new Error(`Unknown AI provider: ${name}`);
       }
   
       const config = this.getProviderConfig(name);
       return new ProviderClass(config);
     }
   
     getProviderConfig(name) {
       switch (name) {
         case 'openai':
           return {
             apiKey: process.env.OPENAI_API_KEY,
             baseURL: process.env.OPENAI_BASE_URL,
             model: process.env.OPENAI_MODEL || 'gpt-4'
           };
         default:
           throw new Error(`No config for provider: ${name}`);
       }
     }
   }
   
   const aiRouter = new AIRouter();
   
   // 添加路由规则
   aiRouter.addRoutingRule({
     scenario: 'intent_recognition',
     provider: 'openai',
     model: 'gpt-4'
   });
   
   aiRouter.addRoutingRule({
     scenario: 'reply_generation',
     provider: 'openai',
     model: 'gpt-3.5-turbo'
   });
   
   module.exports = aiRouter;
   ```

**验收标准**：
- ✅ 模型路由正常工作
- ✅ 支持多提供者
- ✅ 支持场景路由

**测试用例**：
- 模型路由测试
- 提供者切换测试
- 场景匹配测试

---

## 10. 整改实施时间表

### 时间线总览

```
┌────────────────────────────────────────────────────────────┐
│                 整改时间线（共 21-28 周）                  │
├────────────────────────────────────────────────────────────┤
│ 阶段 1: 安全加固     (2-3 周)   ████                      │
│ 阶段 2: 性能优化     (3-4 周)       ██████                  │
│ 阶段 3: 架构代码     (4-6 周)           ████████              │
│ 阶段 4: 扩展维护     (4-5 周)               ████████          │
│ 阶段 5: 监控体验     (3-4 周)                   ██████      │
│ 阶段 6: UI设计完善   (3-4 周)                       ██████  │
│ 阶段 7: 高级特性     (4-6 周)                           ████│
└────────────────────────────────────────────────────────────┘
```

### 详细甘特图

| 周次 | 阶段 1 | 阶段 2 | 阶段 3 | 阶段 4 | 阶段 5 | 阶段 6 | 阶段 7 |
|------|--------|--------|--------|--------|--------|--------|--------|
| 1    | ✓ 认证授权 |        |        |        |        |        |        |
| 2    | ✓ 输入验证 |        |        |        |        |        |        |
| 3    | ✓ 安全加固 | ✓ 数据库优化 |        |        |        |        |        |
| 4    |        | ✓ Redis 优化 | ✓ 前后端分离 |        |        |        |        |
| 5    |        | ✓ AI 优化 | ✓ 状态管理 |        |        |        |        |
| 6    |        | ✓ 错误处理 | ✓ 类型定义 |        |        |        |        |
| 7    |        |        | ✓ 单元测试 | ✓ 规则引擎 |        |        |        |
| 8    |        |        | ✓ 代码去重 | ✓ 日志系统 |        |        |        |
| 9    |        |        |        | ✓ 配置管理 | ✓ 系统监控 |        |        |
| 10   |        |        |        | ✓ 文档完善 | ✓ 告警规则 |        |        |
| 11   |        |        |        | ✓ 健康检查 | ✓ WebSocket |        |        |
| 12   |        |        |        |        | ✓ 前端优化 | ✓ 设计令牌 |        |
| 13   |        |        |        |        | ✓ 数据归档 | ✓ 组件库升级 |        |
| 14   |        |        |        |        |        | ✓ 响应式布局 | ✓ 消息队列 |
| 15   |        |        |        |        |        | ✓ 暗色模式 | ✓ 通知插件 |
| 16   |        |        |        |        |        | ✓ 动画效果 | ✓ AI 路由 |
| 17   |        |        |        |        |        | ✓ 图表组件 | ✓ 测试验证 |
| 18   |        |        |        |        |        | ✓ UI测试 | ✓ 文档更新 |
| 19-22 |        |        |        |        |        | ✓ UI优化 | ✓ 缓冲时间 |

---

## 11. 风险评估和应对措施

### 11.1 风险识别

| 风险 | 概率 | 影响 | 严重度 | 应对措施 |
|------|------|------|--------|----------|
| 改动导致功能回归 | 中 | 高 | 高 | 充分测试、分阶段发布、保留回滚方案 |
| 性能优化效果不达预期 | 低 | 中 | 中 | 持续监控、优化前基准测试、逐步优化 |
| 新功能引入新 Bug | 中 | 高 | 高 | 代码审查、自动化测试、灰度发布 |
| 团队资源不足 | 中 | 中 | 中 | 合理安排优先级、调整时间计划 |
| 依赖服务不稳定 | 低 | 中 | 中 | 降级策略、熔断机制、监控告警 |
| 数据迁移失败 | 低 | 高 | 中 | 充分备份、测试迁移、准备回滚 |

### 11.2 应对策略

#### 策略一：分阶段发布
- 每个阶段独立发布
- 每个阶段完成后进行充分测试
- 确认无问题后再进入下一阶段

#### 策略二：充分测试
- 单元测试覆盖率 > 60%
- 集成测试覆盖关键流程
- 性能测试验证优化效果

#### 策略三：回滚准备
- 每次发布前创建回滚脚本
- 数据库操作前备份
- 保留旧版本代码

#### 策略四：监控告警
- 关键指标实时监控
- 异常情况及时告警
- 快速响应和处理

---

## 12. 资源需求

### 12.1 人力资源

| 角色 | 人数 | 工作量（人周） |
|------|------|----------------|
| 后端开发工程师 | 2 | 32-40 |
| 前端开发工程师 | 1 | 16-20 |
| 测试工程师 | 1 | 8-10 |
| 架构师 | 1 | 4-6 |
| 总计 | 5 | 60-76 |

### 12.2 基础设施

| 资源 | 配置 | 用途 |
|------|------|------|
| 开发环境 | 4 核 CPU, 8GB RAM | 开发和测试 |
| 测试环境 | 4 核 CPU, 16GB RAM | 集成测试 |
| 生产环境 | 8 核 CPU, 32GB RAM | 生产运行 |
| 数据库 | 100GB SSD | PostgreSQL |
| Redis | 10GB 内存 | 缓存和队列 |

### 12.3 工具和服务

| 工具/服务 | 用途 |
|----------|------|
| Git | 版本控制 |
| pnpm | 包管理 |
| Vitest | 单元测试 |
| PostgreSQL | 数据库 |
| Redis | 缓存和队列 |
| Docker（可选） | 容器化 |

---

## 13. 验收标准

### 13.1 功能验收
- ✅ 所有功能按需求实现
- ✅ 无 P0 和 P1 级 Bug
- ✅ 所有测试用例通过
- ✅ 文档完整准确

### 13.2 性能验收
- ✅ API 响应时间 < 200ms (P95)
- ✅ 数据库查询时间 < 100ms (P95)
- ✅ 页面首屏加载时间 < 2s
- ✅ AI 请求缓存命中率 > 40%

### 13.3 安全验收
- ✅ 所有 API 都有认证
- ✅ 所有输入都经过验证
- ✅ 敏感信息不泄露
- ✅ 通过安全扫描

### 13.4 可维护性验收
- ✅ 代码覆盖率 > 60%
- ✅ 所有函数都有注释
- ✅ API 文档完整
- ✅ 配置文档完整

---

## 14. 后续优化建议

### 14.1 持续优化
- 定期性能分析和优化
- 持续监控和告警
- 定期代码审查
- 用户反馈收集和处理

### 14.2 功能迭代
- 根据用户需求添加新功能
- 优化用户体验
- 扩展业务场景
- 提升智能化程度

### 14.3 技术升级
- 定期升级依赖版本
- 关注新技术趋势
- 评估新技术引入
- 技术债务清理

---

## 15. 附录

### 15.1 术语表
- **P0**: 紧急优先级，必须立即处理
- **P1**: 重要优先级，尽快处理
- **P2**: 建议优先级，计划处理
- **RBAC**: 基于角色的访问控制
- **JWT**: JSON Web Token
- **TTL**: Time To Live，过期时间

### 15.2 参考文档
- 系统构造说明书：`docs/系统构造说明书.md`
- 系统优化建议：`docs/系统优化建议.md`
- API 文档：`/docs` （待实现）
- 开发规范：`docs/开发规范.md` （待编写）

---

## 结语

本整改计划书详细规划了 WorkTool AI 中枢系统在各个方面的优化措施，涵盖了安全、性能、架构、代码质量、可维护性、扩展性、监控和用户体验等 9 个维度。

**重要提示**：
1. 本计划书仅作为整改参考，具体实施时应根据实际情况调整
2. 每个阶段完成后应进行充分测试和验证
3. 遇到问题应及时调整计划和策略
4. 保持与团队的沟通和协作
5. 持续监控和优化

**下一步行动**：
1. 组织团队评审本计划书
2. 确认资源分配和时间安排
3. 选择第一阶段的具体任务开始实施
4. 建立进度跟踪和汇报机制

---

**文档版本**：v2.0  
**最后更新**：2026-02-04  
**变更记录**：v2.0 - 新增第六阶段：UI设计完善  
**维护者**：开发团队  
**状态**：待评审
