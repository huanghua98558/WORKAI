# WorkTool AI 中枢系统 - 整改计划书

## 1. 项目概述

### 1.1 项目背景
WorkTool AI 中枢系统经过全面分析，发现了在架构设计、性能、安全、代码质量、可维护性、扩展性、监控和用户体验等多个方面存在需要改进的问题。本计划书旨在系统性地解决这些问题，提升系统的整体质量。

### 1.2 整改目标
- **安全加固**：实现完善的认证授权、输入验证和敏感信息保护
- **性能优化**：提升系统响应速度、并发能力和资源利用率
- **架构优化**：提高系统的可维护性、可扩展性和灵活性
- **代码质量**：提高代码的可读性、可测试性和健壮性
- **监控完善**：建立全面的系统监控和告警机制
- **用户体验**：改善前端性能和错误提示，提升用户体验

### 1.3 整改范围
本次整改涵盖以下方面：
- ✅ 架构设计优化
- ✅ 性能优化
- ✅ 安全加固
- ✅ 代码质量提升
- ✅ 可维护性改进
- ✅ 扩展性增强
- ✅ 监控和告警
- ✅ 数据库优化
- ✅ 用户体验优化

**排除范围**：
- ❌ 自动化部署（CI/CD）
- ❌ 负载均衡
- ❌ 环境隔离和容器化

---

## 2. 整改原则

### 2.1 原则一：安全优先
所有整改必须遵循最小权限原则和安全第一原则，任何可能引入安全风险的改动都必须经过严格审查。

### 2.2 原则二：渐进式改进
按照优先级分阶段实施，优先解决 P0 和 P1 级别问题，避免一次性大规模改动导致风险。

### 2.3 原则三：向后兼容
所有改动必须保证向后兼容，不破坏现有功能，确保平滑过渡。

### 2.4 原则四：可测试性
每个改进都应该有相应的测试用例，确保改动正确且可回归。

### 2.5 原则六：可回滚
每个阶段的改动都应该有回滚方案，一旦出现问题可以快速恢复。

---

## 3. 整改阶段划分

### 3.1 第一阶段：安全加固（P0）
**时间估算**：2-3 周
**目标**：解决最严重的安全问题，建立安全防护体系

**主要任务**：
1. 实现认证授权系统
2. 完善输入验证
3. 敏感信息防护
4. 数据库备份
5. CORS 配置优化

### 3.2 第二阶段：核心性能优化（P0-P1）
**时间估算**：3-4 周
**目标**：提升系统性能，解决瓶颈

**主要任务**：
1. 数据库查询优化
2. Redis 使用优化
3. AI 请求优化
4. 统一错误处理

### 3.3 第三阶段：架构和代码质量（P1）
**时间估算**：4-6 周
**目标**：优化架构，提升代码质量

**主要任务**：
1. 前后端分离优化
2. 统一状态管理
3. 类型定义完善
4. 单元测试添加
5. 代码重复消除

### 3.4 第四阶段：扩展性和可维护性（P1-P2）
**时间估算**：4-5 周
**目标**：提高系统的可扩展性和可维护性

**主要任务**：
1. 告警规则引擎优化
2. 日志系统完善
3. 配置管理优化
4. 文档完善
5. 健康检查完善

### 3.5 第五阶段：监控和体验优化（P1-P2）
**时间估算**：3-4 周
**目标**：建立监控体系，提升用户体验

**主要任务**：
1. 系统监控实现
2. WebSocket 连接优化
3. 前端性能优化
4. 错误提示优化
5. 数据归档策略

### 3.6 第六阶段：高级特性（P2）
**时间估算**：4-6 周
**目标**：实现高级特性，增强系统能力

**主要任务**：
1. 消息队列引入
2. 通知方式扩展
3. AI 模型切换

---

## 4. 第一阶段：安全加固（2-3 周）

### 4.1 实现认证授权系统

#### 任务 1.1：JWT 认证实现
**优先级**：P0  
**工作量**：5 天

**实施步骤**：
1. 设计认证架构
   - 选择 JWT 方案（无状态）
   - 定义 Token 格式和过期时间
   - 设计 Refresh Token 机制

2. 实现认证中间件
   ```javascript
   // server/middleware/auth.js
   module.exports = async function authMiddleware(request, reply, done) {
     const token = request.headers.authorization?.replace('Bearer ', '');
     if (!token) {
       return reply.code(401).send({ error: 'Unauthorized' });
     }
     // 验证 token
     try {
       const decoded = jwt.verify(token, process.env.JWT_SECRET);
       request.user = decoded;
       done();
     } catch (error) {
       reply.code(401).send({ error: 'Invalid token' });
     }
   };
   ```

3. 实现登录接口
   ```javascript
   // server/routes/auth.api.js
   fastify.post('/auth/login', async (request, reply) => {
     const { username, password } = request.body;
     // 验证用户名密码
     // 生成 JWT token
     const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, {
       expiresIn: '24h'
     });
     return { token, user };
   });
   ```

4. 集成到现有 API
   - 添加认证中间件到需要保护的接口
   - 定义公开接口白名单

**验收标准**：
- ✅ 可以成功登录并获取 Token
- ✅ 使用 Token 可以访问受保护的接口
- ✅ 无效 Token 返回 401
- ✅ Token 过期后需要重新登录

**测试用例**：
- 正常登录测试
- 错误密码测试
- 无效 Token 测试
- 过期 Token 测试

---

#### 任务 1.2：RBAC 权限控制实现
**优先级**：P0  
**工作量**：5 天

**实施步骤**：
1. 设计权限模型
   - 定义角色（admin, operator, viewer）
   - 定义权限（read, write, delete, manage）
   - 角色权限映射表

2. 创建权限表
   ```sql
   CREATE TABLE users (
     id VARCHAR(36) PRIMARY KEY,
     username VARCHAR(50) UNIQUE NOT NULL,
     password_hash VARCHAR(255) NOT NULL,
     role VARCHAR(20) NOT NULL,
     created_at TIMESTAMP DEFAULT NOW(),
     updated_at TIMESTAMP DEFAULT NOW()
   );
   
   CREATE TABLE roles (
     id VARCHAR(36) PRIMARY KEY,
     name VARCHAR(20) UNIQUE NOT NULL,
     permissions JSONB NOT NULL
   );
   ```

3. 实现权限检查中间件
   ```javascript
   // server/middleware/permission.js
   const rolePermissions = {
     admin: ['read', 'write', 'delete', 'manage'],
     operator: ['read', 'write'],
     viewer: ['read']
   };
   
   module.exports = function(permissions) {
     return function(request, reply, done) {
       const userRole = request.user.role;
       const userPermissions = rolePermissions[userRole] || [];
       const hasPermission = permissions.every(p => userPermissions.includes(p));
       
       if (!hasPermission) {
         return reply.code(403).send({ error: 'Forbidden' });
       }
       done();
     };
   };
   ```

4. 应用权限控制
   - 为每个 API 路由添加权限要求
   - 前端根据权限控制界面显示

**验收标准**：
- ✅ 不同角色有不同的权限
- ✅ 越权访问返回 403
- ✅ 前端根据权限显示/隐藏功能

**测试用例**：
- 不同角色权限测试
- 越权访问测试
- 权限修改后生效测试

---

#### 任务 1.3：审计日志实现
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 创建审计日志表
   ```sql
   CREATE TABLE audit_logs (
     id VARCHAR(36) PRIMARY KEY,
     user_id VARCHAR(36),
     action VARCHAR(50) NOT NULL,
     resource VARCHAR(100),
     details JSONB,
     ip_address VARCHAR(50),
     user_agent TEXT,
     created_at TIMESTAMP DEFAULT NOW()
   );
   ```

2. 实现审计中间件
   ```javascript
   // server/middleware/audit.js
   module.exports = function auditMiddleware(action) {
     return async function(request, reply, done) {
       const startTime = Date.now();
       const originalSend = reply.send;
       
       reply.send = function(data) {
         if (reply.statusCode < 400) {
           // 记录审计日志
           db.insert(auditLogs).values({
             userId: request.user?.id,
             action: action,
             resource: request.url,
             details: { method: request.method, body: request.body },
             ipAddress: request.ip,
             userAgent: request.headers['user-agent']
           });
         }
         return originalSend.call(this, data);
       };
       done();
     };
   };
   ```

3. 集成到敏感操作
   - 登录/登出
   - 规则创建/删除/修改
   - 通知配置修改

**验收标准**：
- ✅ 所有敏感操作都被记录
- ✅ 可以查询审计日志
- ✅ 日志包含完整信息

**测试用例**：
- 审计日志记录测试
- 审计日志查询测试

---

### 4.2 完善输入验证

#### 任务 1.4：统一输入验证
**优先级**：P0  
**工作量**：5 天

**实施步骤**：
1. 定义统一的 Schema
   ```javascript
   // server/schemas/alerts.js
   const { z } = require('zod');
   
   const alertRuleSchema = z.object({
     id: z.string().uuid().optional(),
     intentType: z.enum(['service', 'help', 'chat', 'welcome', 'risk', 'spam', 'admin', 'keyword']),
     ruleName: z.string().min(1).max(255),
     isEnabled: z.boolean().default(true),
     alertLevel: z.enum(['critical', 'warning', 'info']),
     threshold: z.number().int().min(1).max(100),
     cooldownPeriod: z.number().int().min(1).max(86400),
     messageTemplate: z.string().max(5000).optional(),
     keywords: z.string().max(1000).optional()
   });
   
   module.exports = { alertRuleSchema };
   ```

2. 创建验证中间件
   ```javascript
   // server/middleware/validate.js
   module.exports = function validate(schema) {
     return function(request, reply, done) {
       try {
         const validated = schema.parse(request.body);
         request.validatedBody = validated;
         done();
       } catch (error) {
         reply.code(400).send({
           error: 'Validation error',
           details: error.errors
         });
       }
     };
   };
   ```

3. 应用到所有 API
   - 为每个 API 添加对应的 Schema
   - 统一错误处理

4. XSS 防护
   ```javascript
   // server/lib/sanitize.js
   const sanitizeHtml = require('sanitize-html');
   
   module.exports = function sanitize(input) {
     if (typeof input === 'string') {
       return sanitizeHtml(input, {
         allowedTags: [],
         allowedAttributes: {}
       });
     }
     return input;
   };
   ```

**验收标准**：
- ✅ 所有 API 输入都经过验证
- ✅ 非法输入返回明确的错误信息
- ✅ XSS 攻击被防护
- ✅ SQL 注入被防护（Drizzle ORM 已支持）

**测试用例**：
- 正常输入测试
- 非法输入测试
- XSS 攻击测试
- SQL 注入测试

---

### 4.3 敏感信息防护

#### 任务 1.5：错误信息脱敏
**优先级**：P0  
**工作量**：2 天

**实施步骤**：
1. 定义环境变量
   ```javascript
   const isProduction = process.env.NODE_ENV === 'production';
   ```

2. 统一错误处理
   ```javascript
   // server/middleware/error-handler.js
   module.exports = function errorHandler(error, request, reply) {
     if (isProduction) {
       reply.code(error.statusCode || 500).send({
         error: error.message || 'Internal Server Error',
         code: error.code || 'INTERNAL_ERROR'
       });
     } else {
       reply.code(error.statusCode || 500).send({
         error: error.message,
         stack: error.stack,
         details: error.details
       });
     }
     
     // 记录详细日志到服务器
     logger.error('Error occurred', {
       error: error.message,
       stack: error.stack,
       request: {
         url: request.url,
         method: request.method,
         body: request.body
       }
     });
   };
   ```

3. 敏感字段过滤
   ```javascript
   // server/lib/filter-sensitive.js
   const sensitiveFields = ['password', 'token', 'secret', 'apiKey', 'privateKey'];
   
   module.exports = function filterSensitive(data) {
     const filtered = { ...data };
     sensitiveFields.forEach(field => {
       if (filtered[field]) {
         filtered[field] = '***';
       }
     });
     return filtered;
   };
   ```

**验收标准**：
- ✅ 生产环境不返回详细错误信息
- ✅ 敏感字段在日志和响应中被过滤
- ✅ 错误码统一规范

**测试用例**：
- 生产环境错误返回测试
- 开发环境错误返回测试
- 敏感字段过滤测试

---

### 4.4 数据库备份

#### 任务 1.6：自动备份实现
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 创建备份脚本
   ```bash
   # scripts/backup-db.sh
   #!/bin/bash
   
   BACKUP_DIR="/backups"
   DATE=$(date +%Y%m%d_%H%M%S)
   DB_URL=${DATABASE_URL}
   
   # 全量备份
   pg_dump $DB_URL > $BACKUP_DIR/full_$DATE.sql
   
   # 压缩
   gzip $BACKUP_DIR/full_$DATE.sql
   
   # 删除7天前的备份
   find $BACKUP_DIR -name "*.sql.gz" -mtime +7 -delete
   
   echo "Backup completed: full_$DATE.sql.gz"
   ```

2. 配置定时任务
   ```bash
   # 添加到 crontab
   0 2 * * * /workspace/projects/scripts/backup-db.sh >> /var/log/backup.log 2>&1
   ```

3. 备份验证脚本
   ```bash
   # scripts/verify-backup.sh
   #!/bin/bash
   
   BACKUP_FILE=$1
   gunzip -c $BACKUP_FILE | head -20
   ```

**验收标准**：
- ✅ 每天自动备份数据库
- ✅ 备份文件可正常恢复
- ✅ 备份文件自动清理

**测试用例**：
- 备份脚本执行测试
- 备份恢复测试
- 备份清理测试

---

### 4.5 CORS 配置优化

#### 任务 1.7：CORS 安全配置
**优先级**：P1  
**工作量**：0.5 天

**实施步骤**：
1. 更新 CORS 配置
   ```javascript
   // server/app.js
   fastify.register(cors, {
     origin: function(origin, callback) {
       const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:5000'];
       if (!origin) return callback(null, true);
       if (allowedOrigins.indexOf(origin) !== -1) {
         callback(null, true);
       } else {
         callback(new Error('Not allowed by CORS'), false);
       }
     },
     credentials: true,
     methods: ['GET', 'POST', 'PUT', 'DELETE'],
     allowedHeaders: ['Content-Type', 'Authorization'],
     maxAge: 86400
   });
   ```

**验收标准**：
- ✅ 只有允许的域名可以访问
- ✅ 其他域名被拒绝

**测试用例**：
- 允许域名访问测试
- 拒绝域名访问测试

---

## 5. 第二阶段：核心性能优化（3-4 周）

### 5.1 数据库查询优化

#### 任务 2.1：添加索引
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 分析慢查询
   ```sql
   -- 查看慢查询
   SELECT query, mean_exec_time, calls 
   FROM pg_stat_statements 
   ORDER BY mean_exec_time DESC 
   LIMIT 10;
   ```

2. 添加必要的索引
   ```sql
   -- alert_history 表
   CREATE INDEX idx_alert_history_created_at_level ON alert_history(created_at, alert_level);
   CREATE INDEX idx_alert_history_session_id ON alert_history(session_id);
   
   -- session_messages 表
   CREATE INDEX idx_session_messages_session_created ON session_messages(session_id, created_at);
   
   -- execution_steps 表
   CREATE INDEX idx_execution_steps_processing ON execution_steps(processing_id, step_order);
   
   -- notification_methods 表
   CREATE INDEX idx_notification_methods_rule_enabled ON notification_methods(alert_rule_id, is_enabled);
   ```

3. 验证索引效果
   ```sql
   EXPLAIN ANALYZE SELECT * FROM alert_history WHERE created_at > '2026-02-01';
   ```

**验收标准**：
- ✅ 慢查询响应时间降低 > 50%
- ✅ EXPLAIN 显示使用索引
- ✅ 数据库 CPU 使用率降低

**测试用例**：
- 查询性能测试
- 索引使用验证测试

---

#### 任务 2.2：优化 N+1 查询
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 识别 N+1 查询
   ```javascript
   // 示例：查询告警规则及其通知方式
   const rules = await db.select().from(alertRules);
   
   // ❌ N+1 查询
   for (const rule of rules) {
     const methods = await db.select()
       .from(notificationMethods)
       .where(eq(notificationMethods.alertRuleId, rule.id));
   }
   
   // ✅ 使用 JOIN
   const rulesWithMethods = await db
     .select()
     .from(alertRules)
     .leftJoin(notificationMethods, eq(alertRules.id, notificationMethods.alertRuleId));
   ```

2. 批量查询优化
   ```javascript
   // 使用 IN 查询替代循环查询
   const ruleIds = rules.map(r => r.id);
   const allMethods = await db.select()
     .from(notificationMethods)
     .where(inArray(notificationMethods.alertRuleId, ruleIds));
   
   // 组装数据
   const methodsMap = new Map();
   allMethods.forEach(m => {
     if (!methodsMap.has(m.alertRuleId)) {
       methodsMap.set(m.alertRuleId, []);
     }
     methodsMap.get(m.alertRuleId).push(m);
   });
   ```

**验收标准**：
- ✅ 消除所有 N+1 查询
- ✅ 查询次数明显减少
- ✅ 响应时间降低

**测试用例**：
- 查询次数统计测试
- 性能对比测试

---

#### 任务 2.3：实现分页和限制
**优先级**：P0  
**工作量**：3 天

**实施步骤**：
1. 定义分页参数
   ```javascript
   const paginationSchema = z.object({
     page: z.number().int().min(1).default(1),
     pageSize: z.number().int().min(1).max(100).default(20)
   });
   ```

2. 实现分页查询
   ```javascript
   async function getAlertRulesPaginated(page, pageSize) {
     const db = await getDb();
     const offset = (page - 1) * pageSize;
     
     const rules = await db.select()
       .from(alertRules)
       .limit(pageSize)
       .offset(offset);
     
     const [{ count }] = await db.select({ count: sql`count(*)` })
       .from(alertRules);
     
     return {
       data: rules,
       pagination: {
         page,
         pageSize,
         total: count,
         totalPages: Math.ceil(count / pageSize)
       }
     };
   }
   ```

3. 限制查询时间范围
   ```javascript
   // 历史记录查询限制最近 90 天
   const ninetyDaysAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
   
   const history = await db.select()
     .from(alertHistory)
     .where(gte(alertHistory.createdAt, ninetyDaysAgo))
     .orderBy(desc(alertHistory.createdAt))
     .limit(100);
   ```

**验收标准**：
- ✅ 所有列表查询都支持分页
- ✅ 历史记录查询限制时间范围
- ✅ 查询性能提升

**测试用例**：
- 分页功能测试
- 边界值测试
- 大数据量测试

---

### 5.2 Redis 使用优化

#### 任务 2.4：强制启用 Redis
**优先级**：P1  
**工作量**：2 天

**实施步骤**：
1. 修改启动检查
   ```javascript
   // server/app.js
   async function checkRedis() {
     try {
       await redisClient.ping();
       logger.info('Redis connection verified');
     } catch (error) {
       logger.error('Redis connection failed, system cannot start');
       process.exit(1);
     }
   }
   
   // 在启动时检查
   await checkRedis();
   ```

2. 实现自动重连
   ```javascript
   redisClient.on('error', (error) => {
     logger.error('Redis error:', error);
   });
   
   redisClient.on('close', async () => {
     logger.warn('Redis connection closed, attempting to reconnect...');
     try {
       await redisClient.connect();
       logger.info('Redis reconnected successfully');
     } catch (error) {
       logger.error('Redis reconnection failed:', error);
       // 重试逻辑
       setTimeout(() => redisClient.connect(), 5000);
     }
   });
   ```

3. 实现健康检查
   ```javascript
   fastify.get('/health/redis', async () => {
     try {
       await redisClient.ping();
       return { status: 'ok', latency: Date.now() - startTime };
     } catch (error) {
       reply.code(503).send({ status: 'error', message: error.message });
     }
   });
   ```

**验收标准**：
- ✅ Redis 不可用时系统拒绝启动
- ✅ 连接断开时自动重连
- ✅ 健康检查正常

**测试用例**：
- Redis 连接失败测试
- 自动重连测试
- 健康检查测试

---

#### 任务 2.5：统一缓存策略
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 定义缓存键规范
   ```javascript
   // server/lib/cache.js
   const CACHE_PREFIX = 'worktool:';
   
   function buildKey(module, identifier) {
     return `${CACHE_PREFIX}${module}:${identifier}`;
   }
   
   // 示例
   buildKey('intent', 'service');  // worktool:intent:service
   buildKey('session', 'session_123');  // worktool:session:session_123
   ```

2. 定义 TTL 策略
   ```javascript
   const TTL = {
     SHORT: 300,      // 5 分钟
     MEDIUM: 1800,    // 30 分钟
     LONG: 3600,      // 1 小时
     VERY_LONG: 86400 // 1 天
   };
   
   const MODULE_TTL = {
     intent: TTL.MEDIUM,
     session: TTL.LONG,
     robot: TTL.SHORT,
     alertRule: TTL.SHORT
   };
   ```

3. 实现缓存封装
   ```javascript
   async function getOrSet(key, ttl, factory) {
     const cached = await redisClient.get(key);
     if (cached) {
       return JSON.parse(cached);
     }
     
     const value = await factory();
     await redisClient.setex(key, ttl, JSON.stringify(value));
     return value;
   }
   
   // 使用示例
   const intent = await getOrSet(
     buildKey('intent', intentType),
     TTL.MEDIUM,
     () => getIntentConfigByType(intentType)
   );
   ```

4. 缓存预热
   ```javascript
   async function warmupCache() {
     logger.info('Starting cache warmup...');
     
     // 预加载常用意图配置
     const intents = ['service', 'help', 'chat', 'risk', 'spam'];
     for (const intent of intents) {
       await getOrSet(buildKey('intent', intent), TTL.MEDIUM, () => 
         getIntentConfigByType(intent)
       );
     }
     
     logger.info('Cache warmup completed');
   }
   
   // 在启动时预热
   await warmupCache();
   ```

**验收标准**：
- ✅ 缓存键命名统一
- ✅ TTL 策略合理
- ✅ 缓存命中率 > 70%

**测试用例**：
- 缓存读写测试
- TTL 过期测试
- 缓存穿透测试

---

### 5.3 AI 请求优化

#### 任务 2.6：实现结果缓存
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 内容哈希
   ```javascript
   const crypto = require('crypto');
   
   function hashContent(content, context) {
     const hashInput = JSON.stringify({ content, context });
     return crypto.createHash('sha256').update(hashInput).digest('hex');
   }
   ```

2. 缓存 AI 结果
   ```javascript
   async function recognizeIntentWithCache(content, context) {
     const cacheKey = `ai:intent:${hashContent(content, context)}`;
     const cached = await redisClient.get(cacheKey);
     
     if (cached) {
       logger.debug('AI intent cache hit', { cacheKey });
       return JSON.parse(cached);
     }
     
     const result = await recognizeIntent(content, context);
     await redisClient.setex(cacheKey, 600, JSON.stringify(result)); // 10 分钟
     return result;
   }
   ```

3. 缓存失效策略
   ```javascript
   // 意图配置更新时清除相关缓存
   async function clearIntentCache(intentType) {
     const pattern = `ai:intent:*`;
     const keys = await redisClient.keys(pattern);
     if (keys.length > 0) {
       await redisClient.del(...keys);
       logger.info(`Cleared ${keys.length} AI intent cache entries`);
     }
   }
   ```

**验收标准**：
- ✅ 相同内容直接返回缓存
- ✅ 缓存命中率 > 40%
- ✅ AI API 调用次数降低

**测试用例**：
- 缓存命中测试
- 缓存失效测试
- API 调用次数统计测试

---

#### 任务 2.7：降级策略
**优先级**：P2  
**工作量**：2 天

**实施步骤**：
1. 实现规则匹配
   ```javascript
   async function recognizeIntentWithFallback(content, context) {
     try {
       return await recognizeIntent(content, context);
     } catch (error) {
       logger.warn('AI recognition failed, using fallback', { error });
       
       // 规则匹配降级
       return matchIntentByRules(content);
     }
   }
   
   function matchIntentByRules(content) {
     // 简单的关键词匹配
     if (content.includes('风险') || content.includes('违规')) {
       return { intent: 'risk', confidence: 0.7 };
     }
     if (content.includes('广告') || content.includes('推广')) {
       return { intent: 'spam', confidence: 0.7 };
     }
     // ...
     return { intent: 'chat', confidence: 0.5 };
   }
   ```

**验收标准**：
- ✅ AI 服务不可用时降级到规则匹配
- ✅ 降级后基本功能可用

**测试用例**：
- AI 服务正常测试
- AI 服务不可用测试
- 降级功能测试

---

### 5.4 统一错误处理

#### 任务 2.8：创建统一错误类
**优先级**：P1  
**工作量**：2 天

**实施步骤**：
1. 定义错误类
   ```javascript
   // server/lib/errors.js
   class AppError extends Error {
     constructor(message, code, statusCode = 500) {
       super(message);
       this.name = 'AppError';
       this.code = code;
       this.statusCode = statusCode;
       this.isOperational = true;
       Error.captureStackTrace(this, this.constructor);
     }
   }
   
   // 预定义错误
   class ValidationError extends AppError {
     constructor(message) {
       super(message, 'VALIDATION_ERROR', 400);
     }
   }
   
   class NotFoundError extends AppError {
     constructor(resource) {
       super(`${resource} not found`, 'NOT_FOUND', 404);
     }
   }
   
   class UnauthorizedError extends AppError {
     constructor(message = 'Unauthorized') {
       super(message, 'UNAUTHORIZED', 401);
     }
   }
   
   class ForbiddenError extends AppError {
     constructor(message = 'Forbidden') {
       super(message, 'FORBIDDEN', 403);
     }
   }
   
   module.exports = {
     AppError,
     ValidationError,
     NotFoundError,
     UnauthorizedError,
     ForbiddenError
   };
   ```

2. 定义错误码
   ```javascript
   const ERROR_CODES = {
     // 认证授权 (1000-1999)
     INVALID_TOKEN: 1001,
     TOKEN_EXPIRED: 1002,
     INVALID_CREDENTIALS: 1003,
     FORBIDDEN: 1004,
     
     // 业务逻辑 (2000-2999)
     VALIDATION_ERROR: 2001,
     NOT_FOUND: 2002,
     DUPLICATE_ENTRY: 2003,
     INVALID_STATE: 2004,
     
     // 系统错误 (3000-3999)
     DATABASE_ERROR: 3001,
     REDIS_ERROR: 3002,
     AI_SERVICE_ERROR: 3003,
     EXTERNAL_API_ERROR: 3004
   };
   ```

**验收标准**：
- ✅ 所有错误使用统一的错误类
- ✅ 错误码规范统一
- ✅ 错误信息清晰

**测试用例**：
- 错误类使用测试
- 错误码规范测试

---

## 6. 第三阶段：架构和代码质量（4-6 周）

### 6.1 前后端分离优化

#### 任务 3.1：API 契约定义
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 创建 TypeScript 类型定义
   ```typescript
   // types/api.d.ts
   export interface AlertRule {
     id: string;
     intentType: IntentType;
     ruleName: string;
     isEnabled: boolean;
     alertLevel: AlertLevel;
     threshold: number;
     cooldownPeriod: number;
     messageTemplate?: string;
     keywords?: string;
     createdAt: string;
     updatedAt: string;
   }
   
   export type IntentType = 'service' | 'help' | 'chat' | 'welcome' | 'risk' | 'spam' | 'admin' | 'keyword';
   export type AlertLevel = 'critical' | 'warning' | 'info';
   
   export interface ApiResponse<T> {
     success: boolean;
     data?: T;
     error?: string;
     code?: string;
   }
   
   export interface PaginatedResponse<T> {
     data: T[];
     pagination: {
       page: number;
       pageSize: number;
       total: number;
       totalPages: number;
     };
   }
   ```

2. 创建 API 客户端
   ```typescript
   // lib/api-client.ts
   import axios, { AxiosInstance } from 'axios';
   
   class ApiClient {
     private client: AxiosInstance;
   
     constructor() {
       this.client = axios.create({
         baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5001',
         timeout: 30000
       });
     
       this.client.interceptors.request.use((config) => {
         const token = localStorage.getItem('token');
         if (token) {
           config.headers.Authorization = `Bearer ${token}`;
         }
         return config;
       });
     }
   
     async get<T>(url: string, params?: any): Promise<ApiResponse<T>> {
       const response = await this.client.get<ApiResponse<T>>(url, { params });
       return response.data;
     }
   
     async post<T>(url: string, data: any): Promise<ApiResponse<T>> {
       const response = await this.client.post<ApiResponse<T>>(url, data);
       return response.data;
     }
   
     async put<T>(url: string, data: any): Promise<ApiResponse<T>> {
       const response = await this.client.put<ApiResponse<T>>(url, data);
       return response.data;
     }
   
     async delete<T>(url: string): Promise<ApiResponse<T>> {
       const response = await this.client.delete<ApiResponse<T>>(url);
       return response.data;
     }
   }
   
   export const apiClient = new ApiClient();
   ```

**验收标准**：
- ✅ API 契约清晰定义
- ✅ 类型安全
- ✅ API 客户端统一封装

**测试用例**：
- API 调用测试
- 类型安全测试
- 错误处理测试

---

### 6.2 统一状态管理

#### 任务 3.2：使用 Zustand 管理状态
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 安装 Zustand
   ```bash
   pnpm add zustand
   ```

2. 创建 Store
   ```typescript
   // store/app-store.ts
   import { create } from 'zustand';
   import { persist } from 'zustand/middleware';
   
   interface AppState {
     // 用户信息
     user: User | null;
     setUser: (user: User | null) => void;
     
     // 机器人列表
     robots: Robot[];
     setRobots: (robots: Robot[]) => void;
     
     // 告警规则
     alertRules: AlertRule[];
     setAlertRules: (rules: AlertRule[]) => void;
     updateAlertRule: (id: string, rule: Partial<AlertRule>) => void;
     
     // WebSocket 连接
     wsConnected: boolean;
     setWsConnected: (connected: boolean) => void;
     
     // 重置
     reset: () => void;
   }
   
   export const useAppStore = create<AppState>()(
     persist(
       (set) => ({
         // 初始状态
         user: null,
         robots: [],
         alertRules: [],
         wsConnected: false,
         
         // Actions
         setUser: (user) => set({ user }),
         setRobots: (robots) => set({ robots }),
         setAlertRules: (alertRules) => set({ alertRules }),
         updateAlertRule: (id, updates) => set((state) => ({
           alertRules: state.alertRules.map((rule) =>
             rule.id === id ? { ...rule, ...updates } : rule
           )
         })),
         setWsConnected: (wsConnected) => set({ wsConnected }),
         reset: () => set({
           user: null,
           robots: [],
           alertRules: [],
           wsConnected: false
         })
       }),
       {
         name: 'app-storage',
         partialize: (state) => ({
           user: state.user,
           robots: state.robots
         })
       }
     )
   );
   ```

3. 在组件中使用
   ```typescript
   // components/AlertRulesList.tsx
   import { useAppStore } from '@/store/app-store';
   
   function AlertRulesList() {
     const alertRules = useAppStore((state) => state.alertRules);
     const setAlertRules = useAppStore((state) => state.setAlertRules);
     
     useEffect(() => {
       loadAlertRules();
     }, []);
     
     async function loadAlertRules() {
       const response = await apiClient.get<AlertRule[]>('/api/alerts/rules');
       if (response.success && response.data) {
         setAlertRules(response.data);
       }
     }
     
     return (
       // ...
     );
   }
   ```

**验收标准**：
- ✅ 全局状态统一管理
- ✅ 状态持久化
- ✅ 组件间状态共享正常

**测试用例**：
- 状态读写测试
- 持久化测试
- 组件共享测试

---

### 6.3 类型定义完善

#### 任务 3.3：后端类型定义
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 使用 JSDoc 完善类型
   ```javascript
   /**
    * @typedef {Object} AlertRule
    * @property {string} id - 规则 ID
    * @property {string} intentType - 意图类型
    * @property {string} ruleName - 规则名称
    * @property {boolean} isEnabled - 是否启用
    * @property {'critical'|'warning'|'info'} alertLevel - 告警级别
    * @property {number} threshold - 触发阈值
    * @property {number} cooldownPeriod - 冷却时间（秒）
    * @property {string} [messageTemplate] - 消息模板
    * @property {string} [keywords] - 关键词
    * @property {string} createdAt - 创建时间
    * @property {string} updatedAt - 更新时间
    */
   
   /**
    * @typedef {Object} ApiResponse
    * @property {boolean} success - 是否成功
    * @property {T} [data] - 返回数据
    * @property {string} [error] - 错误信息
    * @property {string} [code] - 错误码
    * @template T
    */
   
   /**
    * 获取所有告警规则
    * @returns {Promise<ApiResponse<AlertRule[]>>}
    */
   async function getAllAlertRules() {
     // ...
   }
   ```

2. 启用严格模式
   ```javascript
   // jsconfig.json
   {
     "compilerOptions": {
       "checkJs": true,
       "strict": true,
       "noImplicitAny": true,
       "strictNullChecks": true
     }
   }
   ```

**验收标准**：
- ✅ 所有函数都有类型定义
- ✅ 类型检查通过
- ✅ 智能提示正常

**测试用例**：
- 类型检查测试
- 智能提示测试

---

### 6.4 单元测试

#### 任务 3.4：添加测试框架
**优先级**：P2  
**工作量**：7 天

**实施步骤**：
1. 安装测试依赖
   ```bash
   pnpm add -D vitest @vitest/ui jsdom @testing-library/react @testing-library/jest-dom
   ```

2. 配置 Vitest
   ```javascript
   // vitest.config.js
   import { defineConfig } from 'vitest/config';
   import react from '@vitejs/plugin-react';
   
   export default defineConfig({
     plugins: [react()],
     test: {
       globals: true,
       environment: 'jsdom',
       setupFiles: ['./test/setup.js'],
       coverage: {
         provider: 'v8',
         reporter: ['text', 'json', 'html'],
         exclude: ['node_modules/', 'test/']
       }
     }
   });
   ```

3. 编写测试用例
   ```javascript
   // test/alert-config.service.test.js
   import { describe, it, expect, vi, beforeEach } from 'vitest';
   import alertConfigService from '../server/services/alert-config.service.js';
   
   describe('AlertConfigService', () => {
     beforeEach(() => {
       vi.clearAllMocks();
     });
   
     describe('getAllAlertRules', () => {
       it('should return all alert rules', async () => {
         const rules = await alertConfigService.getAllAlertRules();
         expect(Array.isArray(rules)).toBe(true);
         expect(rules.length).toBeGreaterThan(0);
       });
   
       it('should return rules with correct structure', async () => {
         const rules = await alertConfigService.getAllAlertRules();
         if (rules.length > 0) {
           expect(rules[0]).toHaveProperty('id');
           expect(rules[0]).toHaveProperty('intentType');
           expect(rules[0]).toHaveProperty('ruleName');
         }
       });
     });
   
     describe('upsertAlertRule', () => {
       it('should create a new rule', async () => {
         const newRule = {
           intentType: 'test',
           ruleName: 'Test Rule',
           isEnabled: true,
           alertLevel: 'info',
           threshold: 1,
           cooldownPeriod: 300
         };
         
         const result = await alertConfigService.upsertAlertRule(newRule);
         expect(result).toHaveProperty('id');
         expect(result.intentType).toBe('test');
       });
     });
   });
   ```

4. 添加到 package.json
   ```json
   {
     "scripts": {
       "test": "vitest",
       "test:ui": "vitest --ui",
       "test:coverage": "vitest --coverage"
     }
   }
   ```

**验收标准**：
- ✅ 核心功能有测试覆盖
- ✅ 测试覆盖率 > 60%
- ✅ CI/CD 中自动运行测试

**测试用例**：
- 测试执行测试
- 覆盖率测试

---

### 6.5 代码重复消除

#### 任务 3.5：提取公共工具
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 创建工具库
   ```javascript
   // lib/utils.js
   
   // 日期格式化
   export function formatDate(date, format = 'YYYY-MM-DD HH:mm:ss') {
     const d = new Date(date);
     const year = d.getFullYear();
     const month = String(d.getMonth() + 1).padStart(2, '0');
     const day = String(d.getDate()).padStart(2, '0');
     const hours = String(d.getHours()).padStart(2, '0');
     const minutes = String(d.getMinutes()).padStart(2, '0');
     const seconds = String(d.getSeconds()).padStart(2, '0');
     
     return format
       .replace('YYYY', year)
       .replace('MM', month)
       .replace('DD', day)
       .replace('HH', hours)
       .replace('mm', minutes)
       .replace('ss', seconds);
   }
   
   // 防抖
   export function debounce(func, wait) {
     let timeout;
     return function executedFunction(...args) {
       const later = () => {
         clearTimeout(timeout);
         func(...args);
       };
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
     };
   }
   
   // 节流
   export function throttle(func, limit) {
     let inThrottle;
     return function(...args) {
       if (!inThrottle) {
         func.apply(this, args);
         inThrottle = true;
         setTimeout(() => inThrottle = false, limit);
       }
     };
   }
   
   // 深拷贝
   export function deepClone(obj) {
     return JSON.parse(JSON.stringify(obj));
   }
   
   // UUID 生成
   export function generateId() {
     return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
       const r = Math.random() * 16 | 0;
       const v = c === 'x' ? r : (r & 0x3 | 0x8);
       return v.toString(16);
     });
   }
   ```

2. 替换重复代码
   - 搜索并替换所有的日期格式化代码
   - 搜索并替换所有的防抖/节流代码
   - 搜索并替换所有的深拷贝代码

**验收标准**：
- ✅ 公共工具统一封装
- ✅ 重复代码消除
- ✅ 工具函数有单元测试

**测试用例**：
- 工具函数测试
- 替换后功能测试

---

## 7. 第四阶段：扩展性和可维护性（4-5 周）

### 7.1 告警规则引擎优化

#### 任务 4.1：实现动态规则引擎
**优先级**：P1  
**工作量**：7 天

**实施步骤**：
1. 设计规则引擎架构
   ```javascript
   // server/lib/rule-engine.js
   
   class RuleEngine {
     constructor() {
       this.rules = new Map();
       this.loadRules();
     }
   
     async loadRules() {
       const db = await getDb();
       const rules = await db.select().from(alertRules);
       
       this.rules.clear();
       rules.forEach(rule => {
         this.rules.set(rule.id, this.parseRule(rule));
       });
     }
   
     parseRule(rule) {
       return {
         id: rule.id,
         name: rule.ruleName,
         conditions: this.parseConditions(rule),
         actions: this.parseActions(rule),
         metadata: {
           intentType: rule.intentType,
           alertLevel: rule.alertLevel,
           threshold: rule.threshold,
           cooldownPeriod: rule.cooldownPeriod
         }
       };
     }
   
     parseConditions(rule) {
       // 解析条件表达式
       const conditions = [];
       
       // 基于意图类型的条件
       conditions.push({
         field: 'intentType',
         operator: '==',
         value: rule.intentType
       });
       
       // 基于关键词的条件（如果有）
       if (rule.keywords) {
         const keywordList = rule.keywords.split(',').map(k => k.trim());
         conditions.push({
           field: 'content',
           operator: 'containsAny',
           value: keywordList
         });
       }
       
       return conditions;
     }
   
     parseActions(rule) {
       return [
         {
           type: 'triggerAlert',
           config: {
             level: rule.alertLevel,
             messageTemplate: rule.messageTemplate
           }
         }
       ];
     }
   
     async evaluate(context) {
       const results = [];
       
       for (const [ruleId, rule] of this.rules) {
         if (!rule.metadata.isEnabled) continue;
         
         if (this.matchesConditions(rule.conditions, context)) {
           results.push({
             ruleId,
             ruleName: rule.name,
             matched: true
           });
         }
       }
       
       return results;
     }
   
     matchesConditions(conditions, context) {
       return conditions.every(condition => {
         switch (condition.operator) {
           case '==':
             return context[condition.field] === condition.value;
           case 'contains':
             return context[condition.field]?.includes(condition.value);
           case 'containsAny':
             return condition.value.some(v => context[condition.field]?.includes(v));
           default:
             return false;
         }
       });
     }
   
     async executeActions(rule, context) {
       for (const action of rule.actions) {
         switch (action.type) {
           case 'triggerAlert':
             await this.triggerAlert(action.config, context);
             break;
           // 其他动作类型
         }
       }
     }
   
     async triggerAlert(config, context) {
       const alertData = {
         level: config.level,
         message: this.renderTemplate(config.messageTemplate, context),
         ...context
       };
       
       await alertTriggerService.triggerAlert(alertData);
     }
   
     renderTemplate(template, context) {
       return template.replace(/\{(\w+)\}/g, (_, key) => {
         return context[key] || '';
       });
     }
   }
   
   const ruleEngine = new RuleEngine();
   module.exports = ruleEngine;
   ```

2. 支持自定义条件
   ```javascript
   // 支持表达式语言
   const conditions = [
     {
       type: 'expression',
       expression: 'intentType == "risk" && confidence > 0.8'
     }
   ];
   ```

3. 支持自定义动作
   ```javascript
   const actions = [
     {
       type: 'sendNotification',
       config: {
         method: 'robot',
         recipients: ['admin'],
         messageTemplate: '告警: {message}'
       }
     }
   ];
   ```

**验收标准**：
- ✅ 规则动态加载
- ✅ 支持自定义条件
- ✅ 支持自定义动作
- ✅ 规则测试功能

**测试用例**：
- 规则加载测试
- 条件匹配测试
- 动作执行测试

---

### 7.2 日志系统完善

#### 任务 4.2：统一日志格式
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 定义日志结构
   ```javascript
   // server/lib/logger.js
   const LOG_LEVELS = {
     ERROR: 'ERROR',
     WARN: 'WARN',
     INFO: 'INFO',
     DEBUG: 'DEBUG'
   };
   
   function log(level, module, message, context = {}) {
     const logEntry = {
       timestamp: new Date().toISOString(),
       level,
       module,
       message,
       context,
       pid: process.pid,
       hostname: require('os').hostname()
     };
     
     // 输出到控制台
     console.log(JSON.stringify(logEntry));
     
     // 保存到数据库（异步）
     saveLogToDatabase(logEntry).catch(err => {
       console.error('Failed to save log:', err);
     });
   }
   
   module.exports = {
     error: (module, message, context) => log(LOG_LEVELS.ERROR, module, message, context),
     warn: (module, message, context) => log(LOG_LEVELS.WARN, module, message, context),
     info: (module, message, context) => log(LOG_LEVELS.INFO, module, message, context),
     debug: (module, message, context) => log(LOG_LEVELS.DEBUG, module, message, context)
   };
   ```

2. 日志级别控制
   ```javascript
   const currentLevel = process.env.LOG_LEVEL || 'INFO';
   const levelOrder = [LOG_LEVELS.DEBUG, LOG_LEVELS.INFO, LOG_LEVELS.WARN, LOG_LEVELS.ERROR];
   
   function shouldLog(level) {
     return levelOrder.indexOf(level) >= levelOrder.indexOf(currentLevel);
   }
   ```

3. 敏感信息过滤
   ```javascript
   function sanitizeContext(context) {
     const sensitiveKeys = ['password', 'token', 'secret', 'apiKey'];
     const sanitized = { ...context };
     
     sensitiveKeys.forEach(key => {
       if (sanitized[key]) {
         sanitized[key] = '***';
       }
     });
     
     return sanitized;
   }
   ```

**验收标准**：
- ✅ 日志格式统一
- ✅ 日志级别可配置
- ✅ 敏感信息被过滤
- ✅ 日志可查询

**测试用例**：
- 日志格式测试
- 日志级别测试
- 敏感信息过滤测试

---

### 7.3 配置管理优化

#### 任务 4.3：统一配置管理
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 创建配置管理
   ```javascript
   // server/lib/config.js
   const { z } = require('zod');
   
   const configSchema = z.object({
     // 数据库配置
     database: z.object({
       url: z.string().url(),
       poolSize: z.number().int().min(1).max(20).default(10)
     }),
   
     // Redis 配置
     redis: z.object({
       url: z.string().url(),
       keyPrefix: z.string().default('worktool:')
     }),
   
     // AI 配置
     ai: z.object({
       apiKey: z.string(),
       baseURL: z.string().url(),
       model: z.string().default('gpt-4'),
       timeout: z.number().int().min(1000).max(60000).default(30000)
     }),
   
     // WorkTool 配置
     worktool: z.object({
       apiUrl: z.string().url(),
       apiToken: z.string()
     }),
   
     // 安全配置
     security: z.object({
       jwtSecret: z.string().min(32),
      jwtExpiresIn: z.string().default('24h'),
      bcryptRounds: z.number().int().min(10).max(15).default(10)
     }),
   
     // 服务器配置
     server: z.object({
       port: z.number().int().min(1).max(65535).default(5001),
      host: z.string().default('0.0.0.0')
     })
   });
   
   function loadConfig() {
     const rawConfig = {
       database: {
         url: process.env.DATABASE_URL,
         poolSize: parseInt(process.env.DB_POOL_SIZE || '10')
       },
       redis: {
         url: process.env.REDIS_URL || 'redis://localhost:6379',
         keyPrefix: process.env.REDIS_KEY_PREFIX || 'worktool:'
       },
       ai: {
         apiKey: process.env.AI_API_KEY,
         baseURL: process.env.AI_API_BASE_URL || 'https://api.openai.com/v1',
         model: process.env.AI_MODEL || 'gpt-4',
         timeout: parseInt(process.env.AI_TIMEOUT || '30000')
       },
       worktool: {
         apiUrl: process.env.WORKTOOL_API_URL,
         apiToken: process.env.WORKTOOL_API_TOKEN
       },
       security: {
         jwtSecret: process.env.JWT_SECRET,
         jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',
         bcryptRounds: parseInt(process.env.BCRYPT_ROUNDS || '10')
       },
       server: {
         port: parseInt(process.env.PORT || '5001'),
         host: process.env.HOST || '0.0.0.0'
       }
     };
     
     try {
       return configSchema.parse(rawConfig);
     } catch (error) {
       console.error('Config validation failed:', error.errors);
       process.exit(1);
     }
   }
   
   const config = loadConfig();
   module.exports = config;
   ```

2. 配置文档
   ```markdown
   # 环境变量配置
   
   ## 数据库配置
   - DATABASE_URL: PostgreSQL 数据库连接字符串
   - DB_POOL_SIZE: 数据库连接池大小 (默认: 10)
   
   ## Redis 配置
   - REDIS_URL: Redis 连接字符串
   - REDIS_KEY_PREFIX: Redis 键前缀 (默认: worktool:)
   
   ## AI 配置
   - AI_API_KEY: AI 服务 API Key
   - AI_API_BASE_URL: AI 服务地址 (默认: https://api.openai.com/v1)
   - AI_MODEL: AI 模型名称 (默认: gpt-4)
   - AI_TIMEOUT: 请求超时时间，毫秒 (默认: 30000)
   
   ## 安全配置
   - JWT_SECRET: JWT 签名密钥（至少32字符）
   - JWT_EXPIRES_IN: Token 过期时间 (默认: 24h)
   - BCRYPT_ROUNDS: bcrypt 加密轮数 (默认: 10)
   ```

**验收标准**：
- ✅ 配置统一管理
- ✅ 配置有验证
- ✅ 配置文档完整

**测试用例**：
- 配置加载测试
- 配置验证测试
- 缺失配置测试

---

### 7.4 文档完善

#### 任务 4.4：API 文档
**优先级**：P2  
**工作量**：5 天

**实施步骤**：
1. 使用 Swagger
   ```javascript
   // server/app.js
   const swagger = require('@fastify/swagger');
   const swaggerUi = require('@fastify/swagger-ui');
   
   fastify.register(swagger, {
     openapi: {
       openapi: '3.0.0',
       info: {
         title: 'WorkTool AI API',
         version: '1.0.0',
         description: 'WorkTool AI 中枢系统 API 文档'
       },
       servers: [
         {
           url: 'http://localhost:5001',
           description: 'Development server'
         }
       ],
       components: {
         securitySchemes: {
           bearerAuth: {
             type: 'http',
             scheme: 'bearer',
             bearerFormat: 'JWT'
           }
         }
       },
       security: [{
         bearerAuth: []
       }]
     }
   });
   
   fastify.register(swaggerUi, {
     routePrefix: '/docs',
     uiConfig: {
       docExpansion: 'list',
       deepLinking: false
     }
   });
   ```

2. 添加 API 注释
   ```javascript
   /**
    * @route GET /api/alerts/rules
    * @summary 获取所有告警规则
    * @tags 告警管理
    * @security BearerAuth
    * @response 200 - 成功返回
    * @response 401 - 未授权
    * @response 500 - 服务器错误
    */
   fastify.get('/api/alerts/rules', async (request, reply) => {
     // ...
   });
   ```

**验收标准**：
- ✅ API 文档可访问
- ✅ 所有 API 都有文档
- ✅ 文档可以在线测试

**测试用例**：
- 文档访问测试
- API 测试功能测试

---

### 7.5 健康检查完善

#### 任务 4.5：增强健康检查
**优先级**：P1  
**工作量**：2 天

**实施步骤**：
1. 实现详细健康检查
   ```javascript
   fastify.get('/health', async async (request, reply) => {
     const checks = {
       status: 'ok',
       timestamp: new Date().toISOString(),
       checks: {}
     };
   
     // 数据库检查
     try {
       const db = await getDb();
       await db.execute(sql`SELECT 1`);
       checks.checks.database = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.database = { status: 'error', message: error.message };
     }
   
     // Redis 检查
     try {
       await redisClient.ping();
       checks.checks.redis = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.redis = { status: 'error', message: error.message };
     }
   
     // AI 服务检查
     try {
       await aiService.checkHealth();
       checks.checks.ai_service = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.ai_service = { status: 'error', message: error.message };
     }
   
     // WorkTool API 检查
     try {
       await worktoolService.checkHealth();
       checks.checks.worktool_api = { status: 'ok' };
     } catch (error) {
       checks.status = 'degraded';
       checks.checks.worktool_api = { status: 'error', message: error.message };
     }
   
     const statusCode = checks.status === 'ok' ? 200 : 503;
     reply.code(statusCode).send(checks);
   });
   ```

**验收标准**：
- ✅ 健康检查包含所有依赖
- ✅ 健康状态准确
- ✅ 响应时间 < 1 秒

**测试用例**：
- 健康检查正常测试
- 依赖故障测试

---

## 8. 第五阶段：监控和体验优化（3-4 周）

### 8.1 系统监控实现

#### 任务 5.1：实现性能监控
**优先级**：P1  
**工作量**：5 天

**实施步骤**：
1. 定义监控指标
   ```javascript
   // server/lib/metrics.js
   const metrics = {
     // 性能指标
     httpRequestDuration: new Map(), // 请求耗时
     aiRequestDuration: new Map(),    // AI 请求耗时
     dbQueryDuration: new Map(),      // 数据库查询耗时
     
     // 业务指标
     messageProcessed: 0,             // 处理的消息数
     alertTriggered: 0,               // 触发的告警数
     aiRequests: 0,                   // AI 请求次数
     failedRequests: 0,               // 失败请求数
     
     // 资源指标
     cpuUsage: 0,
     memoryUsage: 0,
     activeConnections: 0
   };
   
   function recordHttpRequestDuration(duration, endpoint) {
     if (!metrics.httpRequestDuration.has(endpoint)) {
       metrics.httpRequestDuration.set(endpoint, []);
     }
     metrics.httpRequestDuration.get(endpoint).push(duration);
   }
   
   function getMetricsSummary() {
     return {
       performance: {
         avgHttpRequestDuration: calculateAverage(metrics.httpRequestDuration),
         avgAiRequestDuration: calculateAverage(metrics.aiRequestDuration),
         avgDbQueryDuration: calculateAverage(metrics.dbQueryDuration)
       },
       business: {
         messageProcessed: metrics.messageProcessed,
         alertTriggered: metrics.alertTriggered,
         aiRequests: metrics.aiRequests,
         failedRequests: metrics.failedRequests
       },
       resources: {
         cpuUsage: metrics.cpuUsage,
         memoryUsage: metrics.memoryUsage,
         activeConnections: metrics.activeConnections
       }
     };
   }
   
   function calculateAverage(map) {
     let total = 0;
     let count = 0;
     
     for (const values of map.values()) {
       total += values.reduce((a, b) => a + b, 0);
       count += values.length;
     }
     
     return count > 0 ? total / count : 0;
   }
   
   module.exports = {
     metrics,
     recordHttpRequestDuration,
     getMetricsSummary
   };
   ```

2. 集成到 Fastify
   ```javascript
   // server/app.js
   const { metrics, recordHttpRequestDuration } = require('./lib/metrics');
   
   fastify.addHook('onRequest', (request, reply, done) => {
     request.startTime = Date.now();
     done();
   });
   
   fastify.addHook('onResponse', (request, reply, done) => {
     const duration = Date.now() - request.startTime;
     recordHttpRequestDuration(duration, request.url);
     done();
   });
   
   // 监控端点
   fastify.get('/metrics', async (request, reply) => {
     reply.send(getMetricsSummary());
   });
   ```

**验收标准**：
- ✅ 性能指标可查询
- ✅ 业务指标可查询
- ✅ 资源指标可查询

**测试用例**：
- 指标记录测试
- 指标查询测试

---

#### 任务 5.2：告警规则
**优先级**：P1  
**工作量**：3 天

**实施步骤**：
1. 定义告警规则
   ```javascript
   const alertRules = [
     {
       name: 'High Error Rate',
       condition: 'failedRequests / totalRequests > 0.05',
       level: 'critical',
       notification: ['email', 'webhook']
     },
     {
       name: 'Slow Response Time',
       condition: 'avgHttpRequestDuration > 5000',
       level: 'warning',
       notification: ['email']
     },
     {
       name: 'High AI Request Rate',
       condition: 'aiRequests > 1000',
       level: 'info',
       notification: ['email']
     },
     {
       name: 'Database Connection Pool Exhausted',
       condition: 'activeConnections / poolSize > 0.9',
       level: 'critical',
       notification: ['email', 'webhook']
     }
   ];
   ```

2. 实现告警检查
   ```javascript
   async function checkAlerts() {
     const summary = getMetricsSummary();
     
     for (const rule of alertRules) {
       if (evaluateCondition(rule.condition, summary)) {
         await triggerAlert(rule, summary);
       }
     }
   }
   
   function evaluateCondition(condition, context) {
     // 简化的表达式求值
     try {
       // 这里可以使用更安全的表达式求值库
       return eval(condition);
     } catch (error) {
      logger.error('Alert condition evaluation failed:', error);
      return false;
     }
   }
   
   async function triggerAlert(rule, context) {
     logger.warn('Alert triggered', { rule: rule.name, level: rule.level });
     
     // 发送通知
     for (const method of rule.notification) {
       await sendNotification(method, {
         title: `Alert: ${rule.name}`,
         message: `Condition: ${rule.condition}`,
         level: rule.level,
         context
       });
     }
   }
   ```

3. 定时检查
   ```javascript
   // 每分钟检查一次
   setInterval(() => {
     checkAlerts();
   }, 60000);
   ```

**验收标准**：
- ✅ 告警规则正确触发
- ✅ 通知正确发送
- ✅ 避免重复告警

**测试用例**：
- 告警触发测试
- 告警通知测试

---

### 8.2 WebSocket 连接优化

#### 任务 5.3：实现自动重连
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 前端 WebSocket 管理
   ```typescript
   // hooks/use-websocket.ts
   export function useWebSocket(url: string) {
     const [isConnected, setIsConnected] = useState(false);
     const wsRef = useRef<WebSocket | null>(null);
     const reconnectAttempts = useRef(0);
     const maxReconnectAttempts = 5;
     const reconnectDelay = useRef(1000);
   
     const connect = useCallback(() => {
       if (wsRef.current?.readyState === WebSocket.OPEN) {
         return;
       }
   
       const ws = new WebSocket(url);
       wsRef.current = ws;
   
       ws.onopen = () => {
         console.log('WebSocket connected');
         setIsConnected(true);
         reconnectAttempts.current = 0;
         reconnectDelay.current = 1000;
       };
   
       ws.onclose = () => {
         console.log('WebSocket disconnected');
         setIsConnected(false);
         wsRef.current = null;
   
         // 自动重连
         if (reconnectAttempts.current < maxReconnectAttempts) {
           reconnectAttempts.current++;
           const delay = reconnectDelay.current * 2; // 指数退避
           console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts.current})`);
           
           setTimeout(() => {
             connect();
           }, delay);
         } else {
           console.error('Max reconnect attempts reached');
         }
       };
   
       ws.onerror = (error) => {
         console.error('WebSocket error:', error);
       };
   
       ws.onmessage = (event) => {
         // 处理消息
         console.log('WebSocket message:', event.data);
       };
     }, [url]);
   
     useEffect(() => {
       connect();
       
       return () => {
         if (wsRef.current) {
           wsRef.current.close();
         }
       };
     }, [connect]);
   
     const send = useCallback((data: any) => {
       if (wsRef.current?.readyState === WebSocket.OPEN) {
         wsRef.current.send(JSON.stringify(data));
       } else {
         console.warn('WebSocket is not connected');
       }
     }, []);
   
     return { isConnected, send };
   }
   ```

2. 心跳机制
   ```javascript
   // 后端
   fastify.register(async function (fastify) {
     fastify.register(websocket);
     
     const clients = new Set();
     
     fastify.get('/ws', { websocket: true }, (connection, req) => {
       clients.add(connection.socket);
       
       // 心跳检查
       const heartbeatInterval = setInterval(() => {
         connection.socket.ping();
       }, 30000);
     
       connection.socket.on('pong', () => {
         connection.socket.isAlive = true;
       });
     
       connection.socket.on('close', () => {
         clearInterval(heartbeatInterval);
         clients.delete(connection.socket);
       });
     });
     
     // 定期清理死连接
     setInterval(() => {
       clients.forEach(socket => {
         if (!socket.isAlive) {
           socket.terminate();
           clients.delete(socket);
         } else {
           socket.isAlive = false;
           socket.ping();
         }
       });
     }, 60000);
   });
   ```

**验收标准**：
- ✅ 断线自动重连
- ✅ 指数退避策略
- ✅ 心跳机制正常

**测试用例**：
- 断线重连测试
- 心跳测试
- 最大重连次数测试

---

### 8.3 前端性能优化

#### 任务 5.4：代码分割
**优先级**：P2  
**工作量**：3 天

**实施步骤**：
1. 路由级别懒加载
   ```typescript
   // app/monitoring/page.tsx
   import dynamic from 'next/dynamic';
   
   const MonitoringAlertCard = dynamic(() => 
     import('@/components/monitoring/MonitoringAlertCard'), 
     { loading: () => <p>Loading...</p> }
   );
   
   const MonitoringAlertCompact = dynamic(() =>
     import('@/components/monitoring/MonitoringAlertCompact'),
     { loading: () => <p>Loading...</p> }
   );
   ```

2. 组件级别懒加载
   ```typescript
   // components/monitoring/AlertRulesDialog.tsx
   const NotificationSettingsDialog = dynamic(() =>
     import('./NotificationSettingsDialog'),
     { loading: () => <p>Loading...</p> }
   );
   ```

**验收标准**：
- ✅ 首屏加载时间降低
- ✅ 初始包体积减小
- ✅ 懒加载组件正常

**测试用例**：
- 首屏加载测试
- 包体积分析测试
- 懒加载功能测试

---

#### 任务 5.5：图片优化
**优先级**：P2  
**工作量**：1 天

**实施步骤**：
1. 使用 Next.js Image 组件
   ```typescript
   import Image from 'next/image';
   
   <Image
     src="/logo.png"
     alt="Logo"
     width={200}
     height={50}
     priority
   />
   ```

2. 配置图片域名
   ```javascript
   // next.config.js
   module.exports = {
     images: {
       domains: ['example.com'],
       formats: ['image/avif', 'image/webp']
     }
   };
   ```

**验收标准**：
- ✅ 图片使用 CDN
- ✅ 图片格式优化
- ✅ 图片懒加载

**测试用例**：
- 图片加载测试
- 图片格式测试

---

### 8.4 错误提示优化

#### 任务 5.6：友好错误提示
**优先级**：P2  
**工作量**：2 天

**实施步骤**：
1. 定义错误信息映射
   ```typescript
   // lib/error-messages.ts
   const errorMessages: Record<string, string> = {
     // 网络错误
     NETWORK_ERROR: '网络连接失败，请检查网络设置',
     TIMEOUT: '请求超时，请稍后重试',
     
     // 认证错误
     UNAUTHORIZED: '请先登录',
     TOKEN_EXPIRED: '登录已过期，请重新登录',
     FORBIDDEN: '您没有权限执行此操作',
     
     // 业务错误
     VALIDATION_ERROR: '输入数据格式错误',
     NOT_FOUND: '资源不存在',
     DUPLICATE_ENTRY: '数据已存在',
     
     // 系统错误
     INTERNAL_ERROR: '系统错误，请稍后重试',
     DATABASE_ERROR: '数据库错误，请联系管理员',
     AI_SERVICE_ERROR: 'AI 服务暂时不可用，请稍后重试'
   };
   
   export function getErrorMessage(code: string): string {
     return errorMessages[code] || '未知错误';
   }
   ```

2. 统一错误处理
   ```typescript
   // components/ErrorBoundary.tsx
   export function ErrorBoundary({ children, fallback }) {
     return (
       <React.ErrorBoundary
         FallbackComponent={fallback}
         onError={(error) => {
           console.error('Error caught by boundary:', error);
           // 上报错误
           reportError(error);
         }}
       >
         {children}
       </React.ErrorBoundary>
     );
   }
   
   // components/ErrorFallback.tsx
   export function ErrorFallback({ error }) {
     return (
       <div className="p-8 text-center">
         <h2 className="text-2xl font-bold mb-4">出错了</h2>
         <p className="text-gray-600 mb-4">
           {getErrorMessage(error.code) || error.message}
         </p>
         <Button onClick={() => window.location.reload()}>
           重新加载
         </Button>
       </div>
     );
   }
   ```

**验收标准**：
- ✅ 错误信息友好
- ✅ 提供解决方案
- ✅ 错误分类清晰

**测试用例**：
- 错误提示测试
- 错误分类测试

---

### 8.5 数据归档策略

#### 任务 5.7：实现数据归档
**优先级**：P2  
**工作量**：4 天

**实施步骤**：
1. 创建归档表
   ```sql
   CREATE TABLE alert_history_archive (
     LIKE alert_history INCLUDING ALL
   );
   
   CREATE TABLE session_messages_archive (
     LIKE session_messages INCLUDING ALL
   );
   ```

2. 归档脚本
   ```bash
   # scripts/archive-data.sh
   #!/bin/bash
   
   # 归档 90 天前的告警历史
   psql $DATABASE_URL -c "
     INSERT INTO alert_history_archive
     SELECT * FROM alert_history
     WHERE created_at < NOW() - INTERVAL '90 days';
     
     DELETE FROM alert_history
     WHERE created_at < NOW() - INTERVAL '90 days';
   "
   
   # 归档 180 天前的会话消息
   psql $DATABASE_URL -c "
     INSERT INTO session_messages_archive
     SELECT * FROM session_messages
     WHERE created_at < NOW() - INTERVAL '180 days';
     
     DELETE FROM session_messages
     WHERE created_at < NOW() - INTERVAL '180 days';
   "
   
   echo "Archive completed: $(date)"
   ```

3. 定时任务
   ```bash
   # 每周日凌晨 2 点执行
   0 2 * * 0 /workspace/projects/scripts/archive-data.sh >> /var/log/archive.log 2>&1
   ```

**验收标准**：
- ✅ 数据自动归档
- ✅ 归档后查询性能提升
- ✅ 归档数据可恢复

**测试用例**：
- 归档脚本执行测试
- 数据恢复测试
- 性能对比测试

---

## 9. 第六阶段：高级特性（4-6 周）

### 9.1 消息队列引入

#### 任务 6.1：使用 Redis Stream
**优先级**：P2  
**工作量**：5 天

**实施步骤**：
1. 创建消息队列
   ```javascript
   // server/lib/message-queue.js
   class MessageQueue {
     constructor(redisClient) {
       this.redis = redisClient;
       this.queues = {
         alerts: 'queue:alerts',
         ai: 'queue:ai',
         notifications: 'queue:notifications'
       };
     }
   
     async produce(queueName, message) {
       const id = await this.redis.xadd(this.queues[queueName], '*', 'data', JSON.stringify(message));
       return id;
     }
   
     async consume(queueName, callback, consumerGroup = 'default') {
       const queueKey = this.queues[queueName];
       
       // 创建消费者组
       try {
         await this.redis.xgroup('CREATE', queueKey, consumerGroup, '0', 'MKSTREAM');
       } catch (error) {
         // 组已存在，忽略
       }
   
       const consumerId = `consumer-${process.pid}`;
     
       while (true) {
         const result = await this.redis.xreadgroup(
           'GROUP', consumerGroup, consumerId,
           'COUNT', 1,
           'BLOCK', 5000,
           'STREAMS', queueKey, '>'
         );
   
         if (result && result.length > 0) {
           const [stream, messages] = result[0];
           for (const [id, fields] of messages) {
             const data = JSON.parse(fields.data);
             try {
               await callback(data);
               await this.redis.xack(queueKey, consumerGroup, id);
             } catch (error) {
               console.error('Message processing failed:', error);
               // 重新入队（最多重试 3 次）
               const retryCount = parseInt(fields.retryCount || '0');
               if (retryCount < 3) {
                 await this.redis.xadd(queueKey, '*', 'data', fields.data, 'retryCount', retryCount + 1);
                 await this.redis.xack(queueKey, consumerGroup, id);
               } else {
                 // 死信队列
                 await this.redis.xadd(`${queueKey}:dlq`, '*', 'data', fields.data, 'error', error.message);
                 await this.redis.xack(queueKey, consumerGroup, id);
               }
             }
           }
         }
       }
     }
   }
   
   const messageQueue = new MessageQueue(redisClient);
   module.exports = messageQueue;
   ```

2. 集成告警通知
   ```javascript
   // 修改告警触发逻辑
   async function triggerAlert(alertData) {
     // 发送到队列
     await messageQueue.produce('alerts', alertData);
   }
   
   // 消费告警通知
   messageQueue.consume('alerts', async (alertData) => {
     await notificationService.sendNotifications(alertData);
   });
   ```

**验收标准**：
- ✅ 消息队列正常工作
- ✅ 消息不丢失
- ✅ 支持重试和死信队列

**测试用例**：
- 消息生产测试
- 消息消费测试
- 重试机制测试
- 死信队列测试

---

### 9.2 通知方式扩展

#### 任务 6.2：插件化架构
**优先级**：P2  
**工作量：5 天

**实施步骤**：
1. 定义通知插件接口
   ```javascript
   // server/lib/notification-plugins/base.js
   class NotificationPlugin {
     constructor(config) {
       this.config = config;
       this.name = this.constructor.name;
     }
   
     async send(recipients, message) {
       throw new Error('send method must be implemented');
     }
   
     async test() {
       throw new Error('test method must be implemented');
     }
   
     validateConfig(config) {
       throw new Error('validateConfig method must be implemented');
     }
   }
   
   module.exports = NotificationPlugin;
   ```

2. 实现机器人通知插件
   ```javascript
   // server/lib/notification-plugins/robot.js
   const NotificationPlugin = require('./base');
   
   class RobotNotificationPlugin extends NotificationPlugin {
     validateConfig(config) {
       if (!config.robotId || !config.apiToken) {
         throw new Error('robotId and apiToken are required');
       }
     }
   
     async send(recipients, message) {
       const { robotId, apiToken } = this.config;
       
       const results = [];
       for (const recipient of recipients) {
         try {
           await worktoolService.sendMessage({
             robotId,
             apiToken,
             ...recipient,
             content: message
           });
           results.push({ recipient, success: true });
         } catch (error) {
           results.push({ recipient, success: false, error: error.message });
         }
       }
       
       return results;
     }
   
     async test() {
       return this.send(
         [{ userName: 'Test User', groupName: 'Test Group' }],
         '这是一条测试消息'
       );
     }
   }
   
   module.exports = RobotNotificationPlugin;
   ```

3. 插件管理器
   ```javascript
   // server/lib/notification-plugins/manager.js
   class NotificationPluginManager {
     constructor() {
       this.plugins = new Map();
       this.loadPlugins();
     }
   
     loadPlugins() {
       const robotPlugin = require('./robot');
       this.register('robot', robotPlugin);
       
       // 加载其他插件
       // this.register('email', require('./email'));
       // this.register('sms', require('./sms'));
     }
   
     register(name, pluginClass) {
       this.plugins.set(name, pluginClass);
     }
   
     async send(methodType, config, recipients, message) {
       const PluginClass = this.plugins.get(methodType);
       if (!PluginClass) {
         throw new Error(`Unknown notification method: ${methodType}`);
       }
   
       const plugin = new PluginClass(config);
       return plugin.send(recipients, message);
     }
   
     async test(methodType, config) {
       const PluginClass = this.plugins.get(methodType);
       if (!PluginClass) {
         throw new Error(`Unknown notification method: ${methodType}`);
       }
   
       const plugin = new PluginClass(config);
       return plugin.test();
     }
   }
   
   const pluginManager = new NotificationPluginManager();
   module.exports = pluginManager;
   ```

**验收标准**：
- ✅ 插件可动态加载
- ✅ 新增通知方式只需实现插件
- ✅ 插件测试功能正常

**测试用例**：
- 插件加载测试
- 插件发送测试
- 插件测试功能测试

---

### 9.3 AI 模型切换

#### 任务 6.3：模型抽象层
**优先级**：P2  
**工作量：5 天

**实施步骤**：
1. 定义 AI 服务接口
   ```javascript
   // server/lib/ai-providers/base.js
   class AIProvider {
     constructor(config) {
       this.config = config;
       this.name = this.constructor.name;
     }
   
     async chat(messages, options = {}) {
       throw new Error('chat method must be implemented');
     }
   
     async getModels() {
       throw new Error('getModels method must be implemented');
     }
   
     validateConfig(config) {
       throw new Error('validateConfig method must be implemented');
     }
   }
   
   module.exports = AIProvider;
   ```

2. 实现 OpenAI 提供者
   ```javascript
   // server/lib/ai-providers/openai.js
   const AIProvider = require('./base');
   const OpenAI = require('openai');
   
   class OpenAIProvider extends AIProvider {
     validateConfig(config) {
       if (!config.apiKey) {
         throw new Error('apiKey is required');
       }
     }
   
     getClient() {
       return new OpenAI({
         apiKey: this.config.apiKey,
         baseURL: this.config.baseURL
       });
     }
   
     async chat(messages, options = {}) {
       const client = this.getClient();
       const response = await client.chat.completions.create({
         model: this.config.model || 'gpt-4',
         messages: messages,
         temperature: options.temperature || 0.7,
         max_tokens: options.maxTokens || 1000
       });
     
       return {
         content: response.choices[0].message.content,
         usage: response.usage,
        model: response.model
       };
     }
   
     async getModels() {
       const client = this.getClient();
      const models = await client.models.list();
       return models.data.map(m => m.id);
     }
   }
   
   module.exports = OpenAIProvider;
   ```

3. 模型路由器
   ```javascript
   // server/lib/ai-router.js
   class AIRouter {
     constructor() {
       this.providers = new Map();
       this.routingRules = [];
       this.loadProviders();
     }
   
     loadProviders() {
     const OpenAIProvider = require('./ai-providers/openai');
     this.providers.set('openai', OpenAIProvider);
   
     // 加载其他提供者
     // this.providers.set('anthropic', require('./ai-providers/anthropic'));
     // this.providers.set('deepseek', require('./ai-providers/deepseek'));
   }
   
     addRoutingRule(rule) {
       this.routingRules.push(rule);
     }
   
     async route(messages, options = {}) {
       // 评估路由规则
       for (const rule of this.routingRules) {
         if (this.matchRule(rule, messages, options)) {
           const provider = this.getProvider(rule.provider);
           return provider.chat(messages, { ...options, model: rule.model });
         }
       }
   
       // 默认使用第一个提供者
       const defaultProvider = this.getProvider('openai');
       return defaultProvider.chat(messages, options);
     }
   
     matchRule(rule, messages, options) {
       // 根据规则匹配
       if (rule.scenario === 'intent_recognition') {
         return options.purpose === 'intent_recognition';
       }
       if (rule.scenario === 'reply_generation') {
         return options.purpose === 'reply_generation';
       }
       return false;
     }
   
     getProvider(name) {
       const ProviderClass = this.providers.get(name);
       if (!ProviderClass) {
         throw new Error(`Unknown AI provider: ${name}`);
       }
   
       const config = this.getProviderConfig(name);
       return new ProviderClass(config);
     }
   
     getProviderConfig(name) {
       switch (name) {
         case 'openai':
           return {
             apiKey: process.env.OPENAI_API_KEY,
             baseURL: process.env.OPENAI_BASE_URL,
             model: process.env.OPENAI_MODEL || 'gpt-4'
           };
         default:
           throw new Error(`No config for provider: ${name}`);
       }
     }
   }
   
   const aiRouter = new AIRouter();
   
   // 添加路由规则
   aiRouter.addRoutingRule({
     scenario: 'intent_recognition',
     provider: 'openai',
     model: 'gpt-4'
   });
   
   aiRouter.addRoutingRule({
     scenario: 'reply_generation',
     provider: 'openai',
     model: 'gpt-3.5-turbo'
   });
   
   module.exports = aiRouter;
   ```

**验收标准**：
- ✅ 模型路由正常工作
- ✅ 支持多提供者
- ✅ 支持场景路由

**测试用例**：
- 模型路由测试
- 提供者切换测试
- 场景匹配测试

---

## 10. 整改实施时间表

### 时间线总览

```
┌─────────────────────────────────────────────────────────┐
│                   整改时间线（共 18-22 周）             │
├─────────────────────────────────────────────────────────┤
│ 阶段 1: 安全加固     (2-3 周)   ████                   │
│ 阶段 2: 性能优化     (3-4 周)       ██████               │
│ 阶段 3: 架构代码     (4-6 周)           ████████           │
│ 阶段 4: 扩展维护     (4-5 周)               ████████       │
│ 阶段 5: 监控体验     (3-4 周)                   ██████   │
│ 阶段 6: 高级特性     (4-6 周)                       ████│
└─────────────────────────────────────────────────────────┘
```

### 详细甘特图

| 周次 | 阶段 1 | 阶段 2 | 阶段 3 | 阶段 4 | 阶段 5 | 阶段 6 |
|------|--------|--------|--------|--------|--------|--------|
| 1    | ✓ 认证授权 |        |        |        |        |        |
| 2    | ✓ 输入验证 |        |        |        |        |        |
| 3    | ✓ 安全加固 | ✓ 数据库优化 |        |        |        |        |
| 4    |        | ✓ Redis 优化 | ✓ 前后端分离 |        |        |        |
| 5    |        | ✓ AI 优化 | ✓ 状态管理 |        |        |        |
| 6    |        | ✓ 错误处理 | ✓ 类型定义 |        |        |        |
| 7    |        |        | ✓ 单元测试 | ✓ 规则引擎 |        |        |
| 8    |        |        | ✓ 代码去重 | ✓ 日志系统 |        |        |
| 9    |        |        |        | ✓ 配置管理 | ✓ 系统监控 |        |
| 10   |        |        |        | ✓ 文档完善 | ✓ 告警规则 |        |
| 11   |        |        |        | ✓ 健康检查 | ✓ WebSocket |        |
| 12   |        |        |        |        | ✓ 前端优化 |        |
| 13   |        |        |        |        | ✓ 数据归档 |        |
| 14   |        |        |        |        |        | ✓ 消息队列 |
| 15   |        |        |        |        |        | ✓ 通知插件 |
| 16   |        |        |        |        |        | ✓ AI 路由 |
| 17   |        |        |        |        |        | ✓ 测试验证 |
| 18   |        |        |        |        |        | ✓ 文档更新 |
| 19-22 |        |        |        |        |        | ✓ 缓冲时间 |

---

## 11. 风险评估和应对措施

### 11.1 风险识别

| 风险 | 概率 | 影响 | 严重度 | 应对措施 |
|------|------|------|--------|----------|
| 改动导致功能回归 | 中 | 高 | 高 | 充分测试、分阶段发布、保留回滚方案 |
| 性能优化效果不达预期 | 低 | 中 | 中 | 持续监控、优化前基准测试、逐步优化 |
| 新功能引入新 Bug | 中 | 高 | 高 | 代码审查、自动化测试、灰度发布 |
| 团队资源不足 | 中 | 中 | 中 | 合理安排优先级、调整时间计划 |
| 依赖服务不稳定 | 低 | 中 | 中 | 降级策略、熔断机制、监控告警 |
| 数据迁移失败 | 低 | 高 | 中 | 充分备份、测试迁移、准备回滚 |

### 11.2 应对策略

#### 策略一：分阶段发布
- 每个阶段独立发布
- 每个阶段完成后进行充分测试
- 确认无问题后再进入下一阶段

#### 策略二：充分测试
- 单元测试覆盖率 > 60%
- 集成测试覆盖关键流程
- 性能测试验证优化效果

#### 策略三：回滚准备
- 每次发布前创建回滚脚本
- 数据库操作前备份
- 保留旧版本代码

#### 策略四：监控告警
- 关键指标实时监控
- 异常情况及时告警
- 快速响应和处理

---

## 12. 资源需求

### 12.1 人力资源

| 角色 | 人数 | 工作量（人周） |
|------|------|----------------|
| 后端开发工程师 | 2 | 32-40 |
| 前端开发工程师 | 1 | 16-20 |
| 测试工程师 | 1 | 8-10 |
| 架构师 | 1 | 4-6 |
| 总计 | 5 | 60-76 |

### 12.2 基础设施

| 资源 | 配置 | 用途 |
|------|------|------|
| 开发环境 | 4 核 CPU, 8GB RAM | 开发和测试 |
| 测试环境 | 4 核 CPU, 16GB RAM | 集成测试 |
| 生产环境 | 8 核 CPU, 32GB RAM | 生产运行 |
| 数据库 | 100GB SSD | PostgreSQL |
| Redis | 10GB 内存 | 缓存和队列 |

### 12.3 工具和服务

| 工具/服务 | 用途 |
|----------|------|
| Git | 版本控制 |
| pnpm | 包管理 |
| Vitest | 单元测试 |
| PostgreSQL | 数据库 |
| Redis | 缓存和队列 |
| Docker（可选） | 容器化 |

---

## 13. 验收标准

### 13.1 功能验收
- ✅ 所有功能按需求实现
- ✅ 无 P0 和 P1 级 Bug
- ✅ 所有测试用例通过
- ✅ 文档完整准确

### 13.2 性能验收
- ✅ API 响应时间 < 200ms (P95)
- ✅ 数据库查询时间 < 100ms (P95)
- ✅ 页面首屏加载时间 < 2s
- ✅ AI 请求缓存命中率 > 40%

### 13.3 安全验收
- ✅ 所有 API 都有认证
- ✅ 所有输入都经过验证
- ✅ 敏感信息不泄露
- ✅ 通过安全扫描

### 13.4 可维护性验收
- ✅ 代码覆盖率 > 60%
- ✅ 所有函数都有注释
- ✅ API 文档完整
- ✅ 配置文档完整

---

## 14. 后续优化建议

### 14.1 持续优化
- 定期性能分析和优化
- 持续监控和告警
- 定期代码审查
- 用户反馈收集和处理

### 14.2 功能迭代
- 根据用户需求添加新功能
- 优化用户体验
- 扩展业务场景
- 提升智能化程度

### 14.3 技术升级
- 定期升级依赖版本
- 关注新技术趋势
- 评估新技术引入
- 技术债务清理

---

## 15. 附录

### 15.1 术语表
- **P0**: 紧急优先级，必须立即处理
- **P1**: 重要优先级，尽快处理
- **P2**: 建议优先级，计划处理
- **RBAC**: 基于角色的访问控制
- **JWT**: JSON Web Token
- **TTL**: Time To Live，过期时间

### 15.2 参考文档
- 系统构造说明书：`docs/系统构造说明书.md`
- 系统优化建议：`docs/系统优化建议.md`
- API 文档：`/docs` （待实现）
- 开发规范：`docs/开发规范.md` （待编写）

---

## 结语

本整改计划书详细规划了 WorkTool AI 中枢系统在各个方面的优化措施，涵盖了安全、性能、架构、代码质量、可维护性、扩展性、监控和用户体验等 9 个维度。

**重要提示**：
1. 本计划书仅作为整改参考，具体实施时应根据实际情况调整
2. 每个阶段完成后应进行充分测试和验证
3. 遇到问题应及时调整计划和策略
4. 保持与团队的沟通和协作
5. 持续监控和优化

**下一步行动**：
1. 组织团队评审本计划书
2. 确认资源分配和时间安排
3. 选择第一阶段的具体任务开始实施
4. 建立进度跟踪和汇报机制

---

**文档版本**：v1.0  
**最后更新**：2026-02-04  
**维护者**：开发团队  
**状态**：待评审
