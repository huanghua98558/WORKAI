# WorkTool AI ä¸­æ¢ç³»ç»Ÿ - ç³»ç»Ÿå‡çº§æ‰§è¡ŒæŠ¥å‘Š

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¶é—´**: 2026-02-10  
> **ç»´æŠ¤è€…**: WorkTool AI å›¢é˜Ÿ  
> **åŸºäºæ–‡æ¡£**: ç³»ç»Ÿåˆ†ææŠ¥å‘Š Ã— 3 + ä¸šåŠ¡æµç¨‹è¯´æ˜ + å¼€å‘è§„åˆ’æŠ¥å‘Š

---

## ğŸ“‹ ç›®å½•

- [ä¸€ã€å‡çº§ç›®æ ‡ä¸èŒƒå›´](#ä¸€å‡çº§ç›®æ ‡ä¸èŒƒå›´)
- [äºŒã€å‰ç½®å‡†å¤‡](#äºŒå‰ç½®å‡†å¤‡)
- [ä¸‰ã€æ•°æ®åº“å‡çº§](#ä¸‰æ•°æ®åº“å‡çº§)
- [å››ã€åç«¯æœåŠ¡å‡çº§](#å››åç«¯æœåŠ¡å‡çº§)
- [äº”ã€å‰ç«¯é¡µé¢å‡çº§](#äº”å‰ç«¯é¡µé¢å‡çº§)
- [å…­ã€AIæœåŠ¡é›†æˆ](#å…­aiæœåŠ¡é›†æˆ)
- [ä¸ƒã€æµ‹è¯•éªŒè¯](#ä¸ƒæµ‹è¯•éªŒè¯)
- [å…«ã€éƒ¨ç½²ä¸Šçº¿](#å…«éƒ¨ç½²ä¸Šçº¿)
- [ä¹ã€å›æ»šæ–¹æ¡ˆ](#ä¹å›æ»šæ–¹æ¡ˆ)

---

## ä¸€ã€å‡çº§ç›®æ ‡ä¸èŒƒå›´

### 1.1 å‡çº§ç›®æ ‡

æœ¬æ¬¡å‡çº§çš„æ ¸å¿ƒç›®æ ‡æ˜¯å®ç°åŸºäºä¸šåŠ¡æµç¨‹çš„å®Œæ•´ç³»ç»ŸåŠŸèƒ½ï¼ŒåŒ…æ‹¬ï¼š

#### 1.1.1 è§’è‰²ä½“ç³»å®Œå–„
- âœ… å®ç°4ç±»æœºå™¨äººè§’è‰²ç®¡ç†
- âœ… å®ç°å·¥ä½œäººå‘˜è¯†åˆ«å’Œç®¡ç†
- âœ… å®ç°æœºå™¨äººè‡ªåŠ¨è°ƒåº¦
- âœ… å®ç°å·¥ä½œäººå‘˜çŠ¶æ€ç›‘æ§

#### 1.1.2 ä¼šè¯ç®¡ç†å®Œå–„
- âœ… å®ç°ç”¨æˆ·ä¼šè¯ç®¡ç†
- âœ… å®ç°ç¤¾ç¾¤ä¼šè¯ç®¡ç†
- âœ… å®ç°ä¸Šä¸‹æ–‡æ£€ç´¢æœºåˆ¶
- âœ… å®ç°ä¼šè¯çŠ¶æ€ç®¡ç†

#### 1.1.3 å”®åä»»åŠ¡ç®¡ç†
- âœ… å®ç°å”®åä»»åŠ¡åˆ›å»ºå’Œåˆ†é…
- âœ… å®ç°ä»»åŠ¡è·Ÿè¸ªå’Œç›‘æ§
- âœ… å®ç°è¶…æ—¶æé†’
- âœ… å®ç°æ»¡æ„åº¦è¯„ä¼°
- âœ… å®ç°æ—¥æŠ¥ç”Ÿæˆ
- âœ… å¯¹æ¥è…¾è®¯æ–‡æ¡£

#### 1.1.4 æµç¨‹å¼•æ“å®ç°
- âœ… å®ç°æ¶ˆæ¯å¤„ç†å·¥ä½œæµ
- âœ… å®ç°å”®åä»»åŠ¡å·¥ä½œæµ
- âœ… å®ç°AIååŒå·¥ä½œæµ
- âœ… å®ç°å·¥ä½œæµå¯è§†åŒ–

### 1.2 å‡çº§èŒƒå›´

| æ¨¡å— | å‡çº§å†…å®¹ | å½±å“èŒƒå›´ |
|------|---------|---------|
| **æ•°æ®åº“** | æ–°å¢8å¼ è¡¨ï¼Œä¿®æ”¹5å¼ è¡¨ | æ•°æ®åº“ç»“æ„å˜æ›´ |
| **åç«¯æœåŠ¡** | æ–°å¢15ä¸ªæœåŠ¡ï¼Œä¿®æ”¹10ä¸ªæœåŠ¡ | åç«¯APIå˜æ›´ |
| **å‰ç«¯é¡µé¢** | æ–°å¢5ä¸ªé¡µé¢ï¼Œä¿®æ”¹3ä¸ªé¡µé¢ | å‰ç«¯UIå˜æ›´ |
| **AIæœåŠ¡** | æ–°å¢3ä¸ªAIæœåŠ¡é›†æˆ | AIæ¨¡å‹è°ƒç”¨ |
| **ç¬¬ä¸‰æ–¹é›†æˆ** | è…¾è®¯æ–‡æ¡£APIå¯¹æ¥ | æ•°æ®åŒæ­¥ |

---

## äºŒã€å‰ç½®å‡†å¤‡

### 2.1 ç¯å¢ƒæ£€æŸ¥

#### 2.1.1 ç³»ç»Ÿç¯å¢ƒæ£€æŸ¥æ¸…å•

| æ£€æŸ¥é¡¹ | è¦æ±‚ | æ£€æŸ¥å‘½ä»¤ | é¢„æœŸç»“æœ |
|-------|------|---------|---------|
| Node.jsç‰ˆæœ¬ | >= 18.x | `node --version` | v18.x.x |
| PostgreSQLç‰ˆæœ¬ | >= 14.x | `psql --version` | PostgreSQL 14.x |
| Redisç‰ˆæœ¬ | >= 6.x | `redis-server --version` | 6.x.x |
| ç£ç›˜ç©ºé—´ | >= 50GB | `df -h` | >= 50GB |
| å†…å­˜ | >= 8GB | `free -h` | >= 8GB |

#### 2.1.2 æ•°æ®åº“å¤‡ä»½

```bash
# å¤‡ä»½æ•°æ®åº“
pg_dump -h localhost -U postgres -d worktool > /tmp/worktool_backup_$(date +%Y%m%d_%H%M%S).sql

# éªŒè¯å¤‡ä»½æ–‡ä»¶
ls -lh /tmp/worktool_backup_*.sql

# å¤‡ä»½å®Œæˆåï¼Œç¡®è®¤å¤‡ä»½æ–‡ä»¶å¤§å°
```

### 2.2 æ•°æ®è¿ç§»å‡†å¤‡

#### 2.2.1 æ•°æ®åˆ†æ

åœ¨æ‰§è¡Œæ•°æ®åº“å‡çº§å‰ï¼Œéœ€è¦åˆ†æç°æœ‰æ•°æ®ï¼š

```sql
-- åˆ†æç°æœ‰æ¶ˆæ¯æ•°æ®é‡
SELECT COUNT(*) as total_messages, 
       MIN(created_at) as earliest_message, 
       MAX(created_at) as latest_message
FROM session_messages;

-- åˆ†æç°æœ‰æœºå™¨äººæ•°é‡
SELECT COUNT(*) as total_robots 
FROM robots;

-- åˆ†æç°æœ‰ä¼šè¯æ•°é‡
SELECT COUNT(*) as total_sessions,
       COUNT(DISTINCT user_name) as unique_users
FROM sessions;

-- åˆ†æç°æœ‰å·¥ä½œäººå‘˜
SELECT COUNT(*) as total_staff
FROM (SELECT DISTINCT sender_name FROM session_messages WHERE is_from_staff = true) as staff;
```

#### 2.2.2 æ•°æ®è¿ç§»ç­–ç•¥

| æ•°æ®ç±»å‹ | è¿ç§»ç­–ç•¥ | å¤‡ä»½ç­–ç•¥ |
|---------|---------|---------|
| åŸºç¡€æ•°æ®ï¼ˆæœºå™¨äººï¼‰ | è¿ç§»åˆ°æ–°è¡¨ç»“æ„ | å…¨é‡å¤‡ä»½ |
| æ¶ˆæ¯æ•°æ® | ä¿ç•™åŸè¡¨ï¼Œæ–°å¢å­—æ®µ | å¢é‡å¤‡ä»½ |
| ä¼šè¯æ•°æ® | è¿ç§»åˆ°ç”¨æˆ·/ç¤¾ç¾¤ä¼šè¯è¡¨ | å…¨é‡å¤‡ä»½ |
| å·¥ä½œäººå‘˜æ•°æ® | æå–å¹¶æ ‡å‡†åŒ– | å…¨é‡å¤‡ä»½ |

---

## ä¸‰ã€æ•°æ®åº“å‡çº§

### 3.1 æ•°æ®åº“è¡¨ç»“æ„è®¾è®¡

#### 3.1.1 æœºå™¨äººè§’è‰²è¡¨ï¼ˆrobot_rolesï¼‰

```sql
-- åˆ›å»ºæœºå™¨äººè§’è‰²è¡¨
CREATE TABLE robot_roles (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  role_type VARCHAR(50) NOT NULL UNIQUE,
  role_name VARCHAR(100) NOT NULL,
  description TEXT,
  time_start VARCHAR(10),
  time_end VARCHAR(10),
  can_read BOOLEAN DEFAULT true,
  can_send BOOLEAN DEFAULT false,
  can_monitor BOOLEAN DEFAULT false,
  priority INTEGER DEFAULT 5,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_robot_role_type CHECK (role_type IN ('monitor', 'notification', 'day_shift', 'night_shift'))
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_robot_roles_type ON robot_roles(role_type);
CREATE INDEX idx_robot_roles_active ON robot_roles(is_active);

-- æ’å…¥é»˜è®¤è§’è‰²æ•°æ®
INSERT INTO robot_roles (role_type, role_name, description, time_start, time_end, can_read, can_send, can_monitor, priority) VALUES
('monitor', 'ç›‘æ§æœºå™¨äºº', 'ç›‘æ§æ‰€æœ‰æ¶ˆæ¯ï¼Œä¸å›å¤', '00:00', '23:59', true, false, true, 10),
('notification', 'é€šçŸ¥æœºå™¨äºº', 'å‘é€é€šçŸ¥ã€æé†’ã€å‘Šè­¦ï¼ˆ24å°æ—¶ï¼‰', '00:00', '23:59', true, true, false, 5),
('day_shift', 'ç™½ç­å›å¤æœºå™¨äºº', 'æ—©9ç‚¹-æ™š9ç‚¹ï¼Œç¤¾ç¾¤è¿è¥æ¶ˆæ¯å›å¤', '09:00', '21:00', true, true, false, 8),
('night_shift', 'æ™šç­å›å¤æœºå™¨äºº', 'æ™š9ç‚¹-æ¬¡æ—¥9ç‚¹ï¼Œç¤¾ç¾¤è¿è¥æ¶ˆæ¯å›å¤', '21:00', '09:00', true, true, false, 8);

-- éªŒè¯æ•°æ®æ’å…¥
SELECT * FROM robot_roles;
```

#### 3.1.2 æ›´æ–°æœºå™¨äººé…ç½®è¡¨

```sql
-- ä¸ºæœºå™¨äººè¡¨æ·»åŠ è§’è‰²å…³è”
ALTER TABLE robots ADD COLUMN role_id VARCHAR(36) REFERENCES robot_roles(id);
ALTER TABLE robots ADD COLUMN time_start VARCHAR(10);
ALTER TABLE robots ADD COLUMN time_end VARCHAR(10);
ALTER TABLE robots ADD COLUMN auto_schedule BOOLEAN DEFAULT true;
ALTER TABLE robots ADD COLUMN max_concurrent_tasks INTEGER DEFAULT 10;

-- æ›´æ–°ç°æœ‰æœºå™¨äººçš„è§’è‰²ï¼ˆç¤ºä¾‹ï¼‰
UPDATE robots 
SET role_id = (SELECT id FROM robot_roles WHERE role_type = 'monitor' LIMIT 1),
    time_start = '00:00',
    time_end = '23:59'
WHERE robot_name LIKE '%ç›‘æ§%' OR robot_name LIKE '%Monitor%';

UPDATE robots 
SET role_id = (SELECT id FROM robot_roles WHERE role_type = 'day_shift' LIMIT 1),
    time_start = '09:00',
    time_end = '21:00'
WHERE robot_name LIKE '%ç™½ç­%' OR robot_name LIKE '%è¿è¥%';

-- éªŒè¯æ›´æ–°ç»“æœ
SELECT r.robot_id, r.robot_name, rr.role_type, rr.role_name, r.time_start, r.time_end
FROM robots r
LEFT JOIN robot_roles rr ON r.role_id = rr.id;
```

#### 3.1.3 å·¥ä½œäººå‘˜è¡¨ï¼ˆstaff_membersï¼‰

```sql
-- åˆ›å»ºå·¥ä½œäººå‘˜è¡¨
CREATE TABLE staff_members (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  staff_id VARCHAR(64) NOT NULL UNIQUE,
  staff_name VARCHAR(100) NOT NULL,
  staff_type VARCHAR(50),
  company_name VARCHAR(255),
  enterprise_name VARCHAR(255),
  time_start VARCHAR(10),
  time_end VARCHAR(10),
  status VARCHAR(20) DEFAULT 'offline',
  last_active_time TIMESTAMP WITH TIME ZONE,
  current_tasks INTEGER DEFAULT 0,
  max_tasks INTEGER DEFAULT 5,
  notification_robot_id VARCHAR(64),
  notification_method VARCHAR(50) DEFAULT 'robot',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_staff_type CHECK (staff_type IN ('after_sales', 'group_assistant')),
  CONSTRAINT chk_staff_status CHECK (status IN ('online', 'busy', 'offline')),
  CONSTRAINT chk_notification_method CHECK (notification_method IN ('robot', 'email', 'sms'))
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_staff_members_id ON staff_members(staff_id);
CREATE INDEX idx_staff_members_type ON staff_members(staff_type);
CREATE INDEX idx_staff_members_status ON staff_members(status);
CREATE INDEX idx_staff_members_active ON staff_members(is_active);

-- ä»ç°æœ‰æ•°æ®ä¸­æå–å·¥ä½œäººå‘˜ï¼ˆç¤ºä¾‹ï¼‰
INSERT INTO staff_members (staff_id, staff_name, staff_type, company_name, time_start, time_end, status)
SELECT 
  DISTINCT sender_name,
  sender_name,
  'after_sales',
  COALESCE(company_name, 'WorkTool'),
  '09:00',
  '19:00',
  'offline'
FROM session_messages
WHERE is_from_staff = true
AND sender_name IS NOT NULL
ON CONFLICT (staff_id) DO NOTHING;

-- æ‰‹åŠ¨æ·»åŠ é¢„è®¾å·¥ä½œäººå‘˜
INSERT INTO staff_members (staff_id, staff_name, staff_type, company_name, time_start, time_end, status) VALUES
('staff_001', 'å”®åA', 'after_sales', 'WorkTool', '09:00', '19:00', 'offline'),
('staff_002', 'å”®åB', 'after_sales', 'WorkTool', '14:00', '23:00', 'offline'),
('staff_003', 'ç¾¤åŠ©ç†', 'group_assistant', 'WorkTool', '09:00', '19:00', 'offline')
ON CONFLICT (staff_id) DO NOTHING;

-- éªŒè¯æ•°æ®æ’å…¥
SELECT * FROM staff_members;
```

#### 3.1.4 ç”¨æˆ·ä¼šè¯è¡¨ï¼ˆuser_sessionsï¼‰

```sql
-- åˆ›å»ºç”¨æˆ·ä¼šè¯è¡¨
CREATE TABLE user_sessions (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL UNIQUE,
  user_id VARCHAR(255),
  user_name VARCHAR(255),
  company_name VARCHAR(255),
  enterprise_name VARCHAR(255),
  session_type VARCHAR(20) DEFAULT 'user',
  message_count INTEGER DEFAULT 0,
  last_message_time TIMESTAMP WITH TIME ZONE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  satisfaction_score INTEGER DEFAULT 50,
  problem_resolution_rate DECIMAL(5, 2) DEFAULT 0.00,
  is_new_user BOOLEAN DEFAULT true,
  total_sessions INTEGER DEFAULT 0,
  total_messages INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_session_type CHECK (session_type IN ('user', 'group')),
  CONSTRAINT chk_status CHECK (status IN ('active', 'idle', 'inactive', 'archived')),
  CONSTRAINT chk_satisfaction CHECK (satisfaction_score BETWEEN 0 AND 100)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_user_sessions_id ON user_sessions(session_id);
CREATE INDEX idx_user_sessions_user ON user_sessions(user_name);
CREATE INDEX idx_user_sessions_status ON user_sessions(status);
CREATE INDEX idx_user_sessions_last_message ON user_sessions(last_message_time);

-- ä»ç°æœ‰æ•°æ®è¿ç§»ç”¨æˆ·ä¼šè¯ï¼ˆç¤ºä¾‹ï¼‰
INSERT INTO user_sessions (session_id, user_name, company_name, enterprise_name, message_count, last_message_time, is_new_user)
SELECT 
  'user_' || user_name,
  user_name,
  company_name,
  enterprise_name,
  COUNT(*) as message_count,
  MAX(created_at) as last_message_time,
  CASE WHEN COUNT(*) < 5 THEN true ELSE false END as is_new_user
FROM session_messages
WHERE user_name IS NOT NULL
GROUP BY user_name, company_name, enterprise_name
ON CONFLICT (session_id) DO NOTHING;

-- éªŒè¯æ•°æ®è¿ç§»
SELECT * FROM user_sessions LIMIT 10;
```

#### 3.1.5 ç¤¾ç¾¤ä¼šè¯è¡¨ï¼ˆgroup_sessionsï¼‰

```sql
-- åˆ›å»ºç¤¾ç¾¤ä¼šè¯è¡¨
CREATE TABLE group_sessions (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL UNIQUE,
  group_id VARCHAR(255),
  group_name VARCHAR(255),
  member_count INTEGER DEFAULT 0,
  message_count INTEGER DEFAULT 0,
  last_message_time TIMESTAMP WITH TIME ZONE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  active_member_count INTEGER DEFAULT 0,
  inactive_member_count INTEGER DEFAULT 0,
  pending_task_count INTEGER DEFAULT 0,
  completed_task_count INTEGER DEFAULT 0,
  operator_id VARCHAR(255),
  operator_name VARCHAR(255),
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_status CHECK (status IN ('active', 'idle', 'inactive', 'archived'))
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_group_sessions_id ON group_sessions(session_id);
CREATE INDEX idx_group_sessions_group ON group_sessions(group_name);
CREATE INDEX idx_group_sessions_status ON group_sessions(status);
CREATE INDEX idx_group_sessions_last_message ON group_sessions(last_message_time);

-- ä»ç°æœ‰æ•°æ®è¿ç§»ç¤¾ç¾¤ä¼šè¯ï¼ˆç¤ºä¾‹ï¼‰
INSERT INTO group_sessions (session_id, group_id, group_name, message_count, last_message_time)
SELECT 
  'group_' || group_name,
  group_name,
  group_name,
  COUNT(*) as message_count,
  MAX(created_at) as last_message_time
FROM session_messages
WHERE group_name IS NOT NULL
GROUP BY group_name
ON CONFLICT (session_id) DO NOTHING;

-- éªŒè¯æ•°æ®è¿ç§»
SELECT * FROM group_sessions LIMIT 10;
```

#### 3.1.6 å”®åä»»åŠ¡è¡¨ï¼ˆafter_sales_tasksï¼‰

```sql
-- åˆ›å»ºå”®åä»»åŠ¡è¡¨
CREATE TABLE after_sales_tasks (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id VARCHAR(64) NOT NULL UNIQUE,
  session_id VARCHAR(255),
  user_id VARCHAR(255),
  user_name VARCHAR(255),
  group_id VARCHAR(255),
  group_name VARCHAR(255),
  robot_id VARCHAR(64),
  task_type VARCHAR(50) NOT NULL,
  task_name VARCHAR(255),
  task_description TEXT,
  staff_id VARCHAR(36) REFERENCES staff_members(id),
  staff_name VARCHAR(255),
  assigned_at TIMESTAMP WITH TIME ZONE,
  status VARCHAR(50) DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  user_response_at TIMESTAMP WITH TIME ZONE,
  staff_response_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  user_response_timeout INTEGER DEFAULT 3600,
  staff_response_timeout INTEGER DEFAULT 600,
  satisfaction_score INTEGER,
  response_time INTEGER,
  notes TEXT,
  is_active BOOLEAN DEFAULT true,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_task_type CHECK (task_type IN ('scan_qrcode', 'bind_phone', 'real_name', 'send_selfie', 'other')),
  CONSTRAINT chk_status CHECK (status IN ('pending', 'waiting_user', 'in_progress', 'completed', 'failed')),
  CONSTRAINT chk_satisfaction CHECK (satisfaction_score BETWEEN 0 AND 100)
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_after_sales_tasks_id ON after_sales_tasks(task_id);
CREATE INDEX idx_after_sales_tasks_session ON after_sales_tasks(session_id);
CREATE INDEX idx_after_sales_tasks_user ON after_sales_tasks(user_name);
CREATE INDEX idx_after_sales_tasks_group ON after_sales_tasks(group_name);
CREATE INDEX idx_after_sales_tasks_status ON after_sales_tasks(status);
CREATE INDEX idx_after_sales_tasks_staff ON after_sales_tasks(staff_id);
CREATE INDEX idx_after_sales_tasks_created ON after_sales_tasks(created_at);

-- éªŒè¯è¡¨åˆ›å»º
SELECT * FROM after_sales_tasks LIMIT 10;
```

#### 3.1.7 ä¸Šä¸‹æ–‡æ•°æ®è¡¨ï¼ˆsession_contextsï¼‰

```sql
-- åˆ›å»ºä¸Šä¸‹æ–‡æ•°æ®è¡¨
CREATE TABLE session_contexts (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL,
  context_type VARCHAR(20) NOT NULL,
  history_messages JSONB DEFAULT '[]',
  history_count INTEGER DEFAULT 0,
  user_profile JSONB DEFAULT '{}',
  group_profile JSONB DEFAULT '{}',
  staff_status JSONB DEFAULT '{}',
  task_status JSONB DEFAULT '{}',
  cached_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_context_type CHECK (context_type IN ('user', 'group'))
);

-- åˆ›å»ºç´¢å¼•
CREATE INDEX idx_session_contexts_session ON session_contexts(session_id);
CREATE INDEX idx_session_contexts_type ON session_contexts(context_type);
CREATE INDEX idx_session_contexts_expires ON session_contexts(expires_at);

-- éªŒè¯è¡¨åˆ›å»º
SELECT * FROM session_contexts LIMIT 10;
```

### 3.2 æ•°æ®åº“è¿ç§»è„šæœ¬

#### 3.2.1 å®Œæ•´è¿ç§»è„šæœ¬

åˆ›å»ºæ–‡ä»¶ï¼š`server/database/migrations/001_add_role_and_session_system.sql`

```sql
-- ============================================================
-- æ•°æ®åº“è¿ç§»è„šæœ¬: è§’è‰²ä½“ç³»å’Œä¼šè¯ç®¡ç†ç³»ç»Ÿ
-- ç‰ˆæœ¬: 001
-- åˆ›å»ºæ—¶é—´: 2026-02-10
-- è¯´æ˜: æ·»åŠ æœºå™¨äººè§’è‰²è¡¨ã€å·¥ä½œäººå‘˜è¡¨ã€ç”¨æˆ·ä¼šè¯è¡¨ã€ç¤¾ç¾¤ä¼šè¯è¡¨ã€å”®åä»»åŠ¡è¡¨ã€ä¸Šä¸‹æ–‡è¡¨
-- ============================================================

BEGIN;

-- 1. åˆ›å»ºæœºå™¨äººè§’è‰²è¡¨
CREATE TABLE robot_roles (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  role_type VARCHAR(50) NOT NULL UNIQUE,
  role_name VARCHAR(100) NOT NULL,
  description TEXT,
  time_start VARCHAR(10),
  time_end VARCHAR(10),
  can_read BOOLEAN DEFAULT true,
  can_send BOOLEAN DEFAULT false,
  can_monitor BOOLEAN DEFAULT false,
  priority INTEGER DEFAULT 5,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_robot_role_type CHECK (role_type IN ('monitor', 'notification', 'day_shift', 'night_shift'))
);

-- 2. æ›´æ–°æœºå™¨äººè¡¨
ALTER TABLE robots ADD COLUMN IF NOT EXISTS role_id VARCHAR(36) REFERENCES robot_roles(id);
ALTER TABLE robots ADD COLUMN IF NOT EXISTS time_start VARCHAR(10);
ALTER TABLE robots ADD COLUMN IF NOT EXISTS time_end VARCHAR(10);
ALTER TABLE robots ADD COLUMN IF NOT EXISTS auto_schedule BOOLEAN DEFAULT true;
ALTER TABLE robots ADD COLUMN IF NOT EXISTS max_concurrent_tasks INTEGER DEFAULT 10;

-- 3. åˆ›å»ºå·¥ä½œäººå‘˜è¡¨
CREATE TABLE staff_members (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  staff_id VARCHAR(64) NOT NULL UNIQUE,
  staff_name VARCHAR(100) NOT NULL,
  staff_type VARCHAR(50),
  company_name VARCHAR(255),
  enterprise_name VARCHAR(255),
  time_start VARCHAR(10),
  time_end VARCHAR(10),
  status VARCHAR(20) DEFAULT 'offline',
  last_active_time TIMESTAMP WITH TIME ZONE,
  current_tasks INTEGER DEFAULT 0,
  max_tasks INTEGER DEFAULT 5,
  notification_robot_id VARCHAR(64),
  notification_method VARCHAR(50) DEFAULT 'robot',
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_staff_type CHECK (staff_type IN ('after_sales', 'group_assistant')),
  CONSTRAINT chk_staff_status CHECK (status IN ('online', 'busy', 'offline')),
  CONSTRAINT chk_notification_method CHECK (notification_method IN ('robot', 'email', 'sms'))
);

-- 4. åˆ›å»ºç”¨æˆ·ä¼šè¯è¡¨
CREATE TABLE user_sessions (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL UNIQUE,
  user_id VARCHAR(255),
  user_name VARCHAR(255),
  company_name VARCHAR(255),
  enterprise_name VARCHAR(255),
  session_type VARCHAR(20) DEFAULT 'user',
  message_count INTEGER DEFAULT 0,
  last_message_time TIMESTAMP WITH TIME ZONE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  satisfaction_score INTEGER DEFAULT 50,
  problem_resolution_rate DECIMAL(5, 2) DEFAULT 0.00,
  is_new_user BOOLEAN DEFAULT true,
  total_sessions INTEGER DEFAULT 0,
  total_messages INTEGER DEFAULT 0,
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_session_type CHECK (session_type IN ('user', 'group')),
  CONSTRAINT chk_status CHECK (status IN ('active', 'idle', 'inactive', 'archived')),
  CONSTRAINT chk_satisfaction CHECK (satisfaction_score BETWEEN 0 AND 100)
);

-- 5. åˆ›å»ºç¤¾ç¾¤ä¼šè¯è¡¨
CREATE TABLE group_sessions (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL UNIQUE,
  group_id VARCHAR(255),
  group_name VARCHAR(255),
  member_count INTEGER DEFAULT 0,
  message_count INTEGER DEFAULT 0,
  last_message_time TIMESTAMP WITH TIME ZONE,
  joined_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  active_member_count INTEGER DEFAULT 0,
  inactive_member_count INTEGER DEFAULT 0,
  pending_task_count INTEGER DEFAULT 0,
  completed_task_count INTEGER DEFAULT 0,
  operator_id VARCHAR(255),
  operator_name VARCHAR(255),
  status VARCHAR(20) DEFAULT 'active',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_status CHECK (status IN ('active', 'idle', 'inactive', 'archived'))
);

-- 6. åˆ›å»ºå”®åä»»åŠ¡è¡¨
CREATE TABLE after_sales_tasks (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id VARCHAR(64) NOT NULL UNIQUE,
  session_id VARCHAR(255),
  user_id VARCHAR(255),
  user_name VARCHAR(255),
  group_id VARCHAR(255),
  group_name VARCHAR(255),
  robot_id VARCHAR(64),
  task_type VARCHAR(50) NOT NULL,
  task_name VARCHAR(255),
  task_description TEXT,
  staff_id VARCHAR(36) REFERENCES staff_members(id),
  staff_name VARCHAR(255),
  assigned_at TIMESTAMP WITH TIME ZONE,
  status VARCHAR(50) DEFAULT 'pending',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  user_response_at TIMESTAMP WITH TIME ZONE,
  staff_response_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  user_response_timeout INTEGER DEFAULT 3600,
  staff_response_timeout INTEGER DEFAULT 600,
  satisfaction_score INTEGER,
  response_time INTEGER,
  notes TEXT,
  is_active BOOLEAN DEFAULT true,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_task_type CHECK (task_type IN ('scan_qrcode', 'bind_phone', 'real_name', 'send_selfie', 'other')),
  CONSTRAINT chk_status CHECK (status IN ('pending', 'waiting_user', 'in_progress', 'completed', 'failed')),
  CONSTRAINT chk_satisfaction CHECK (satisfaction_score BETWEEN 0 AND 100)
);

-- 7. åˆ›å»ºä¸Šä¸‹æ–‡æ•°æ®è¡¨
CREATE TABLE session_contexts (
  id VARCHAR(36) PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id VARCHAR(255) NOT NULL,
  context_type VARCHAR(20) NOT NULL,
  history_messages JSONB DEFAULT '[]',
  history_count INTEGER DEFAULT 0,
  user_profile JSONB DEFAULT '{}',
  group_profile JSONB DEFAULT '{}',
  staff_status JSONB DEFAULT '{}',
  task_status JSONB DEFAULT '{}',
  cached_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  CONSTRAINT chk_context_type CHECK (context_type IN ('user', 'group'))
);

-- 8. åˆ›å»ºç´¢å¼•
-- robot_roles
CREATE INDEX idx_robot_roles_type ON robot_roles(role_type);
CREATE INDEX idx_robot_roles_active ON robot_roles(is_active);

-- robots
CREATE INDEX idx_robots_role_id ON robots(role_id);

-- staff_members
CREATE INDEX idx_staff_members_id ON staff_members(staff_id);
CREATE INDEX idx_staff_members_type ON staff_members(staff_type);
CREATE INDEX idx_staff_members_status ON staff_members(status);
CREATE INDEX idx_staff_members_active ON staff_members(is_active);

-- user_sessions
CREATE INDEX idx_user_sessions_id ON user_sessions(session_id);
CREATE INDEX idx_user_sessions_user ON user_sessions(user_name);
CREATE INDEX idx_user_sessions_status ON user_sessions(status);
CREATE INDEX idx_user_sessions_last_message ON user_sessions(last_message_time);

-- group_sessions
CREATE INDEX idx_group_sessions_id ON group_sessions(session_id);
CREATE INDEX idx_group_sessions_group ON group_sessions(group_name);
CREATE INDEX idx_group_sessions_status ON group_sessions(status);
CREATE INDEX idx_group_sessions_last_message ON group_sessions(last_message_time);

-- after_sales_tasks
CREATE INDEX idx_after_sales_tasks_id ON after_sales_tasks(task_id);
CREATE INDEX idx_after_sales_tasks_session ON after_sales_tasks(session_id);
CREATE INDEX idx_after_sales_tasks_user ON after_sales_tasks(user_name);
CREATE INDEX idx_after_sales_tasks_group ON after_sales_tasks(group_name);
CREATE INDEX idx_after_sales_tasks_status ON after_sales_tasks(status);
CREATE INDEX idx_after_sales_tasks_staff ON after_sales_tasks(staff_id);
CREATE INDEX idx_after_sales_tasks_created ON after_sales_tasks(created_at);

-- session_contexts
CREATE INDEX idx_session_contexts_session ON session_contexts(session_id);
CREATE INDEX idx_session_contexts_type ON session_contexts(context_type);
CREATE INDEX idx_session_contexts_expires ON session_contexts(expires_at);

-- 9. æ’å…¥é»˜è®¤æ•°æ®
-- æ’å…¥æœºå™¨äººè§’è‰²
INSERT INTO robot_roles (role_type, role_name, description, time_start, time_end, can_read, can_send, can_monitor, priority) VALUES
('monitor', 'ç›‘æ§æœºå™¨äºº', 'ç›‘æ§æ‰€æœ‰æ¶ˆæ¯ï¼Œä¸å›å¤', '00:00', '23:59', true, false, true, 10),
('notification', 'é€šçŸ¥æœºå™¨äºº', 'å‘é€é€šçŸ¥ã€æé†’ã€å‘Šè­¦ï¼ˆ24å°æ—¶ï¼‰', '00:00', '23:59', true, true, false, 5),
('day_shift', 'ç™½ç­å›å¤æœºå™¨äºº', 'æ—©9ç‚¹-æ™š9ç‚¹ï¼Œç¤¾ç¾¤è¿è¥æ¶ˆæ¯å›å¤', '09:00', '21:00', true, true, false, 8),
('night_shift', 'æ™šç­å›å¤æœºå™¨äºº', 'æ™š9ç‚¹-æ¬¡æ—¥9ç‚¹ï¼Œç¤¾ç¾¤è¿è¥æ¶ˆæ¯å›å¤', '21:00', '09:00', true, true, false, 8)
ON CONFLICT (role_type) DO NOTHING;

-- æ’å…¥é¢„è®¾å·¥ä½œäººå‘˜
INSERT INTO staff_members (staff_id, staff_name, staff_type, company_name, time_start, time_end, status) VALUES
('staff_001', 'å”®åA', 'after_sales', 'WorkTool', '09:00', '19:00', 'offline'),
('staff_002', 'å”®åB', 'after_sales', 'WorkTool', '14:00', '23:00', 'offline'),
('staff_003', 'ç¾¤åŠ©ç†', 'group_assistant', 'WorkTool', '09:00', '19:00', 'offline')
ON CONFLICT (staff_id) DO NOTHING;

COMMIT;

-- éªŒè¯è¿ç§»ç»“æœ
SELECT 'robot_roles' as table_name, COUNT(*) as row_count FROM robot_roles
UNION ALL
SELECT 'staff_members', COUNT(*) FROM staff_members
UNION ALL
SELECT 'user_sessions', COUNT(*) FROM user_sessions
UNION ALL
SELECT 'group_sessions', COUNT(*) FROM group_sessions
UNION ALL
SELECT 'after_sales_tasks', COUNT(*) FROM after_sales_tasks
UNION ALL
SELECT 'session_contexts', COUNT(*) FROM session_contexts;
```

#### 3.2.2 æ‰§è¡Œè¿ç§»è„šæœ¬

```bash
# 1. è¿›å…¥é¡¹ç›®ç›®å½•
cd /workspace/projects/

# 2. æ‰§è¡Œè¿ç§»è„šæœ¬
psql -h localhost -U postgres -d worktool -f server/database/migrations/001_add_role_and_session_system.sql

# 3. éªŒè¯è¿ç§»ç»“æœ
psql -h localhost -U postgres -d worktool -c "
  SELECT table_name, column_name, data_type 
  FROM information_schema.columns 
  WHERE table_schema = 'public' 
  AND table_name IN ('robot_roles', 'staff_members', 'user_sessions', 'group_sessions', 'after_sales_tasks', 'session_contexts')
  ORDER BY table_name, ordinal_position;
"
```

---

## å››ã€åç«¯æœåŠ¡å‡çº§

### 4.1 æ ¸å¿ƒæœåŠ¡å¼€å‘

#### 4.1.1 æœºå™¨äººè§’è‰²ç®¡ç†æœåŠ¡

åˆ›å»ºæ–‡ä»¶ï¼š`server/services/robot-role.service.js`

```javascript
/**
 * æœºå™¨äººè§’è‰²ç®¡ç†æœåŠ¡
 * è´Ÿè´£æœºå™¨äººè§’è‰²çš„CRUDæ“ä½œ
 */

class RobotRoleService {
  constructor(db) {
    this.db = db;
  }

  /**
   * è·å–æ‰€æœ‰è§’è‰²
   */
  async getAllRoles() {
    const result = await this.db.execute(`
      SELECT 
        id,
        role_type,
        role_name,
        description,
        time_start,
        time_end,
        can_read,
        can_send,
        can_monitor,
        priority,
        is_active,
        created_at,
        updated_at
      FROM robot_roles
      WHERE is_active = true
      ORDER BY priority DESC
    `);
    
    return result.rows.map(this._convertToCamelCase);
  }

  /**
   * æ ¹æ®ç±»å‹è·å–è§’è‰²
   */
  async getRoleByType(roleType) {
    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          role_type,
          role_name,
          description,
          time_start,
          time_end,
          can_read,
          can_send,
          can_monitor,
          priority,
          is_active,
          created_at,
          updated_at
        FROM robot_roles
        WHERE role_type = $1 AND is_active = true
      `,
      values: [roleType]
    });
    
    if (result.rows.length === 0) {
      return null;
    }
    
    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * æ ¹æ®IDè·å–è§’è‰²
   */
  async getRoleById(roleId) {
    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          role_type,
          role_name,
          description,
          time_start,
          time_end,
          can_read,
          can_send,
          can_monitor,
          priority,
          is_active,
          created_at,
          updated_at
        FROM robot_roles
        WHERE id = $1
      `,
      values: [roleId]
    });
    
    if (result.rows.length === 0) {
      return null;
    }
    
    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * åˆ›å»ºè§’è‰²
   */
  async createRole(roleData) {
    const {
      roleType,
      roleName,
      description,
      timeStart,
      timeEnd,
      canRead,
      canSend,
      canMonitor,
      priority
    } = roleData;

    const result = await this.db.execute({
      text: `
        INSERT INTO robot_roles (
          role_type, role_name, description, time_start, time_end,
          can_read, can_send, can_monitor, priority
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING *
      `,
      values: [
        roleType, roleName, description, timeStart, timeEnd,
        canRead, canSend, canMonitor, priority
      ]
    });

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * æ›´æ–°è§’è‰²
   */
  async updateRole(roleId, roleData) {
    const fields = [];
    const values = [];
    let paramIndex = 1;

    Object.keys(roleData).forEach(key => {
      if (roleData[key] !== undefined) {
        fields.push(`${this._camelToSnake(key)} = $${paramIndex}`);
        values.push(roleData[key]);
        paramIndex++;
      }
    });

    values.push(roleId);

    const result = await this.db.execute({
      text: `
        UPDATE robot_roles
        SET ${fields.join(', ')}, updated_at = NOW()
        WHERE id = $${paramIndex}
        RETURNING *
      `,
      values
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * åˆ é™¤è§’è‰²
   */
  async deleteRole(roleId) {
    const result = await this.db.execute({
      text: `
        UPDATE robot_roles
        SET is_active = false, updated_at = NOW()
        WHERE id = $1
        RETURNING *
      `,
      values: [roleId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * è½¬æ¢ä¸ºé©¼å³°å‘½å
   */
  _convertToCamelCase(row) {
    const result = {};
    Object.keys(row).forEach(key => {
      const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
      result[camelKey] = row[key];
    });
    return result;
  }

  /**
   * é©¼å³°è½¬ä¸‹åˆ’çº¿
   */
  _camelToSnake(str) {
    return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
  }
}

module.exports = RobotRoleService;
```

#### 4.1.2 æœºå™¨äººè°ƒåº¦æœåŠ¡

åˆ›å»ºæ–‡ä»¶ï¼š`server/services/robot-scheduler.service.js`

```javascript
/**
 * æœºå™¨äººè°ƒåº¦æœåŠ¡
 * è´Ÿè´£æ ¹æ®æ—¶æ®µå’Œæ¶ˆæ¯ç±»å‹è‡ªåŠ¨è°ƒåº¦æœºå™¨äºº
 */

class RobotSchedulerService {
  constructor(db, robotRoleService) {
    this.db = db;
    this.robotRoleService = robotRoleService;
  }

  /**
   * æ ¹æ®æ¶ˆæ¯ä¸Šä¸‹æ–‡é€‰æ‹©æœºå™¨äºº
   */
  async selectRobot(messageContext) {
    const currentTime = new Date();
    const currentHour = currentTime.getHours();

    // åˆ¤æ–­æ—¶æ®µ
    const timePeriod = this._getTimePeriod(currentHour);
    
    // åˆ¤æ–­æ¶ˆæ¯ç±»å‹
    const messageType = this._getMessageType(messageContext);
    
    // è°ƒç”¨å¯¹åº”çš„é€‰æ‹©ç­–ç•¥
    switch (messageType) {
      case 'alert':
        return await this._selectAlertRobot();
      case 'monitor':
        return await this._selectMonitorRobot();
      case 'notification':
        return await this._selectNotificationRobot();
      case 'reply':
        return await this._selectReplyRobot(timePeriod, messageContext);
      default:
        return await this._selectDefaultRobot(timePeriod);
    }
  }

  /**
   * è·å–æ—¶æ®µ
   */
  _getTimePeriod(hour) {
    if (hour >= 9 && hour < 21) {
      return 'day_time';
    } else {
      return 'night_time';
    }
  }

  /**
   * è·å–æ¶ˆæ¯ç±»å‹
   */
  _getMessageType(messageContext) {
    if (messageContext.needAlert) {
      return 'alert';
    }
    if (messageContext.isMonitor) {
      return 'monitor';
    }
    if (messageContext.needNotification) {
      return 'notification';
    }
    if (messageContext.needReply) {
      return 'reply';
    }
    return 'default';
  }

  /**
   * é€‰æ‹©å‘Šè­¦æœºå™¨äºº
   */
  async _selectAlertRobot() {
    const notificationRole = await this.robotRoleService.getRoleByType('notification');
    if (!notificationRole) {
      throw new Error('Notification robot role not found');
    }

    const robot = await this._getAvailableRobotByRole(notificationRole.id);
    if (!robot) {
      throw new Error('No available notification robot');
    }

    return robot;
  }

  /**
   * é€‰æ‹©ç›‘æ§æœºå™¨äºº
   */
  async _selectMonitorRobot() {
    const monitorRole = await this.robotRoleService.getRoleByType('monitor');
    if (!monitorRole) {
      throw new Error('Monitor robot role not found');
    }

    const robot = await this._getAvailableRobotByRole(monitorRole.id);
    if (!robot) {
      throw new Error('No available monitor robot');
    }

    return robot;
  }

  /**
   * é€‰æ‹©é€šçŸ¥æœºå™¨äºº
   */
  async _selectNotificationRobot() {
    const notificationRole = await this.robotRoleService.getRoleByType('notification');
    if (!notificationRole) {
      throw new Error('Notification robot role not found');
    }

    const robot = await this._getAvailableRobotByRole(notificationRole.id);
    if (!robot) {
      throw new Error('No available notification robot');
    }

    return robot;
  }

  /**
   * é€‰æ‹©å›å¤æœºå™¨äºº
   */
  async _selectReplyRobot(timePeriod, messageContext) {
    let roleType;
    
    if (timePeriod === 'day_time') {
      roleType = 'day_shift';
    } else {
      roleType = 'night_shift';
    }

    const role = await this.robotRoleService.getRoleByType(roleType);
    if (!role) {
      throw new Error(`Robot role not found: ${roleType}`);
    }

    const robot = await this._getAvailableRobotByRole(role.id);
    if (!robot) {
      throw new Error(`No available ${roleType} robot`);
    }

    return robot;
  }

  /**
   * é€‰æ‹©é»˜è®¤æœºå™¨äºº
   */
  async _selectDefaultRobot(timePeriod) {
    let roleType;
    
    if (timePeriod === 'day_time') {
      roleType = 'day_shift';
    } else {
      roleType = 'night_shift';
    }

    const role = await this.robotRoleService.getRoleByType(roleType);
    if (!role) {
      throw new Error(`Robot role not found: ${roleType}`);
    }

    const robot = await this._getAvailableRobotByRole(role.id);
    if (!robot) {
      throw new Error(`No available ${roleType} robot`);
    }

    return robot;
  }

  /**
   * æ ¹æ®è§’è‰²IDè·å–å¯ç”¨æœºå™¨äºº
   */
  async _getAvailableRobotByRole(roleId) {
    const result = await this.db.execute({
      text: `
        SELECT 
          robot_id,
          robot_name,
          nickname,
          role_id,
          status,
          is_active
        FROM robots
        WHERE role_id = $1
          AND status = 'online'
          AND is_active = true
        ORDER BY RANDOM()
        LIMIT 1
      `,
      values: [roleId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * è½¬æ¢ä¸ºé©¼å³°å‘½å
   */
  _convertToCamelCase(row) {
    const result = {};
    Object.keys(row).forEach(key => {
      const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
      result[camelKey] = row[key];
    });
    return result;
  }
}

module.exports = RobotSchedulerService;
```

#### 4.1.3 å·¥ä½œäººå‘˜ç®¡ç†æœåŠ¡

åˆ›å»ºæ–‡ä»¶ï¼š`server/services/staff-member.service.js`

```javascript
/**
 * å·¥ä½œäººå‘˜ç®¡ç†æœåŠ¡
 * è´Ÿè´£å·¥ä½œäººå‘˜çš„CRUDæ“ä½œå’ŒçŠ¶æ€ç®¡ç†
 */

class StaffMemberService {
  constructor(db) {
    this.db = db;
  }

  /**
   * è·å–æ‰€æœ‰å·¥ä½œäººå‘˜
   */
  async getAllStaffMembers(filters = {}) {
    let query = `
      SELECT 
        id,
        staff_id,
        staff_name,
        staff_type,
        company_name,
        enterprise_name,
        time_start,
        time_end,
        status,
        last_active_time,
        current_tasks,
        max_tasks,
        notification_robot_id,
        notification_method,
        is_active,
        created_at,
        updated_at
      FROM staff_members
      WHERE is_active = true
    `;

    const params = [];
    let paramIndex = 1;

    if (filters.staffType) {
      query += ` AND staff_type = $${paramIndex}`;
      params.push(filters.staffType);
      paramIndex++;
    }

    if (filters.status) {
      query += ` AND status = $${paramIndex}`;
      params.push(filters.status);
      paramIndex++;
    }

    query += ' ORDER BY created_at DESC';

    const result = await this.db.execute({ text: query, values: params });
    return result.rows.map(this._convertToCamelCase);
  }

  /**
   * æ ¹æ®IDè·å–å·¥ä½œäººå‘˜
   */
  async getStaffMemberById(staffId) {
    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          staff_id,
          staff_name,
          staff_type,
          company_name,
          enterprise_name,
          time_start,
          time_end,
          status,
          last_active_time,
          current_tasks,
          max_tasks,
          notification_robot_id,
          notification_method,
          is_active,
          created_at,
          updated_at
        FROM staff_members
        WHERE staff_id = $1 AND is_active = true
      `,
      values: [staffId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * è·å–å½“å‰æ—¶é—´æ®µå†…çš„å·¥ä½œäººå‘˜
   */
  async getActiveStaffMembers() {
    const currentTime = new Date();
    const currentHour = currentTime.getHours();
    const currentMinute = currentTime.getMinutes();
    const currentTimeStr = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;

    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          staff_id,
          staff_name,
          staff_type,
          company_name,
          enterprise_name,
          time_start,
          time_end,
          status,
          last_active_time,
          current_tasks,
          max_tasks,
          notification_robot_id,
          notification_method,
          is_active,
          created_at,
          updated_at
        FROM staff_members
        WHERE is_active = true
          AND (
            (time_start <= time_end AND time_start <= $1 AND $1 <= time_end)
            OR (time_start > time_end AND (time_start <= $1 OR $1 <= time_end))
          )
        ORDER BY current_tasks ASC, last_active_time DESC
      `,
      values: [currentTimeStr]
    });

    return result.rows.map(this._convertToCamelCase);
  }

  /**
   * åˆ†é…å·¥ä½œäººå‘˜ï¼ˆè´Ÿè½½å‡è¡¡ï¼‰
   */
  async assignStaffMember(staffType = 'after_sales') {
    const availableStaff = await this.getActiveStaffMembers();
    
    // è¿‡æ»¤ç¬¦åˆç±»å‹çš„å·¥ä½œäººå‘˜
    const filteredStaff = availableStaff.filter(staff => 
      staff.staffType === staffType && 
      staff.status !== 'offline' &&
      staff.currentTasks < staff.maxTasks
    );

    if (filteredStaff.length === 0) {
      return null;
    }

    // é€‰æ‹©è´Ÿè½½æœ€ä½çš„å·¥ä½œäººå‘˜
    const staff = filteredStaff.reduce((prev, current) => {
      return (prev.currentTasks < current.currentTasks) ? prev : current;
    });

    // æ›´æ–°å·¥ä½œäººå‘˜çŠ¶æ€
    await this.updateStaffTaskCount(staff.staffId, staff.currentTasks + 1);

    return staff;
  }

  /**
   * æ›´æ–°å·¥ä½œäººå‘˜çŠ¶æ€
   */
  async updateStaffStatus(staffId, status) {
    const result = await this.db.execute({
      text: `
        UPDATE staff_members
        SET status = $1, last_active_time = NOW(), updated_at = NOW()
        WHERE staff_id = $2 AND is_active = true
        RETURNING *
      `,
      values: [status, staffId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * æ›´æ–°å·¥ä½œäººå‘˜ä»»åŠ¡æ•°
   */
  async updateStaffTaskCount(staffId, taskCount) {
    const result = await this.db.execute({
      text: `
        UPDATE staff_members
        SET current_tasks = $1, updated_at = NOW()
        WHERE staff_id = $2 AND is_active = true
        RETURNING *
      `,
      values: [taskCount, staffId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * åˆ›å»ºå·¥ä½œäººå‘˜
   */
  async createStaffMember(staffData) {
    const {
      staffId,
      staffName,
      staffType,
      companyName,
      enterpriseName,
      timeStart,
      timeEnd,
      notificationRobotId,
      notificationMethod
    } = staffData;

    const result = await this.db.execute({
      text: `
        INSERT INTO staff_members (
          staff_id, staff_name, staff_type, company_name, enterprise_name,
          time_start, time_end, notification_robot_id, notification_method
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING *
      `,
      values: [
        staffId, staffName, staffType, companyName, enterpriseName,
        timeStart, timeEnd, notificationRobotId, notificationMethod
      ]
    });

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * è½¬æ¢ä¸ºé©¼å³°å‘½å
   */
  _convertToCamelCase(row) {
    const result = {};
    Object.keys(row).forEach(key => {
      const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
      result[camelKey] = row[key];
    });
    return result;
  }
}

module.exports = StaffMemberService;
```

#### 4.1.4 ä¼šè¯ç®¡ç†æœåŠ¡

åˆ›å»ºæ–‡ä»¶ï¼š`server/services/session-management.service.js`

```javascript
/**
 * ä¼šè¯ç®¡ç†æœåŠ¡
 * è´Ÿè´£ç”¨æˆ·ä¼šè¯å’Œç¤¾ç¾¤ä¼šè¯çš„ç®¡ç†
 */

class SessionManagementService {
  constructor(db) {
    this.db = db;
  }

  /**
   * è·å–æˆ–åˆ›å»ºç”¨æˆ·ä¼šè¯
   */
  async getOrCreateUserSession(messageContext) {
    const { userName, companyName, enterpriseName } = messageContext;
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ä¼šè¯
    let session = await this._getUserSession(userName);
    
    if (session) {
      // æ›´æ–°ä¼šè¯
      await this._updateUserSession(session.sessionId, messageContext);
      return session;
    }
    
    // åˆ›å»ºæ–°ä¼šè¯
    session = await this._createUserSession(messageContext);
    return session;
  }

  /**
   * è·å–æˆ–åˆ›å»ºç¤¾ç¾¤ä¼šè¯
   */
  async getOrCreateGroupSession(messageContext) {
    const { groupName } = messageContext;
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ä¼šè¯
    let session = await this._getGroupSession(groupName);
    
    if (session) {
      // æ›´æ–°ä¼šè¯
      await this._updateGroupSession(session.sessionId, messageContext);
      return session;
    }
    
    // åˆ›å»ºæ–°ä¼šè¯
    session = await this._createGroupSession(messageContext);
    return session;
  }

  /**
   * è·å–ç”¨æˆ·ä¼šè¯
   */
  async _getUserSession(userName) {
    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          session_id,
          user_id,
          user_name,
          company_name,
          enterprise_name,
          session_type,
          message_count,
          last_message_time,
          joined_at,
          satisfaction_score,
          problem_resolution_rate,
          is_new_user,
          total_sessions,
          total_messages,
          status,
          created_at,
          updated_at
        FROM user_sessions
        WHERE user_name = $1 AND status != 'archived'
        ORDER BY updated_at DESC
        LIMIT 1
      `,
      values: [userName]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * è·å–ç¤¾ç¾¤ä¼šè¯
   */
  async _getGroupSession(groupName) {
    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          session_id,
          group_id,
          group_name,
          member_count,
          message_count,
          last_message_time,
          joined_at,
          active_member_count,
          inactive_member_count,
          pending_task_count,
          completed_task_count,
          operator_id,
          operator_name,
          status,
          created_at,
          updated_at
        FROM group_sessions
        WHERE group_name = $1 AND status != 'archived'
        ORDER BY updated_at DESC
        LIMIT 1
      `,
      values: [groupName]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * åˆ›å»ºç”¨æˆ·ä¼šè¯
   */
  async _createUserSession(messageContext) {
    const { userName, companyName, enterpriseName } = messageContext;
    const sessionId = `user_${userName}`;

    const result = await this.db.execute({
      text: `
        INSERT INTO user_sessions (
          session_id, user_name, company_name, enterprise_name,
          message_count, last_message_time, is_new_user
        ) VALUES ($1, $2, $3, $4, 1, NOW(), true)
        RETURNING *
      `,
      values: [sessionId, userName, companyName, enterpriseName]
    });

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * åˆ›å»ºç¤¾ç¾¤ä¼šè¯
   */
  async _createGroupSession(messageContext) {
    const { groupId, groupName, memberCount } = messageContext;
    const sessionId = `group_${groupName}`;

    const result = await this.db.execute({
      text: `
        INSERT INTO group_sessions (
          session_id, group_id, group_name, member_count,
          message_count, last_message_time
        ) VALUES ($1, $2, $3, $4, 1, NOW())
        RETURNING *
      `,
      values: [sessionId, groupId, groupName, memberCount]
    });

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * æ›´æ–°ç”¨æˆ·ä¼šè¯
   */
  async _updateUserSession(sessionId, messageContext) {
    const result = await this.db.execute({
      text: `
        UPDATE user_sessions
        SET 
          message_count = message_count + 1,
          last_message_time = NOW(),
          is_new_user = CASE WHEN message_count < 5 THEN true ELSE false END,
          updated_at = NOW()
        WHERE session_id = $1
        RETURNING *
      `,
      values: [sessionId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * æ›´æ–°ç¤¾ç¾¤ä¼šè¯
   */
  async _updateGroupSession(sessionId, messageContext) {
    const result = await this.db.execute({
      text: `
        UPDATE group_sessions
        SET 
          message_count = message_count + 1,
          last_message_time = NOW(),
          updated_at = NOW()
        WHERE session_id = $1
        RETURNING *
      `,
      values: [sessionId]
    });

    if (result.rows.length === 0) {
      return null;
    }

    return this._convertToCamelCase(result.rows[0]);
  }

  /**
   * è·å–æ´»è·ƒä¼šè¯
   */
  async getActiveSessions(sessionType = 'user') {
    let tableName = sessionType === 'user' ? 'user_sessions' : 'group_sessions';
    let fieldName = sessionType === 'user' ? 'user_name' : 'group_name';

    const result = await this.db.execute({
      text: `
        SELECT 
          id,
          session_id,
          ${fieldName} as name,
          message_count,
          last_message_time,
          status
        FROM ${tableName}
        WHERE status = 'active'
          AND last_message_time > NOW() - INTERVAL '1 hour'
        ORDER BY last_message_time DESC
      `
    });

    return result.rows.map(this._convertToCamelCase);
  }

  /**
   * è½¬æ¢ä¸ºé©¼å³°å‘½å
   */
  _convertToCamelCase(row) {
    const result = {};
    Object.keys(row).forEach(key => {
      const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
      result[camelKey] = row[key];
    });
    return result;
  }
}

module.exports = SessionManagementService;
```

ç”±äºå†…å®¹è¿‡é•¿ï¼Œæˆ‘å°†ç»§ç»­åœ¨ä¸‹ä¸€éƒ¨åˆ†æä¾›å‰©ä½™çš„ä»£ç å’ŒæœåŠ¡å®ç°ã€‚</think>