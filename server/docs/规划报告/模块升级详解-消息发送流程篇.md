# WorkTool AI 中枢系统 - 模块升级详解（消息发送流程篇）

## 📋 目录

1. [消息发送系统概述](#1-消息发送系统概述)
2. [机器人选择](#2-机器人选择)
3. [回复延迟计算](#3-回复延迟计算)
4. [消息发送流程](#4-消息发送流程)
5. [机器人管理](#5-机器人管理)

---

## 1. 消息发送系统概述

### 1.1 系统架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           消息发送系统                                       │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  决策层 (Decision Layer)                                              │  │
│  │  - 机器人选择：根据意图、优先级、负载选择合适的机器人                  │  │
│  │  - 延迟计算：根据意图、优先级计算回复延迟                              │  │
│  │  - 消息生成：生成回复内容                                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    ↓                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  排队层 (Queue Layer)                                                 │  │
│  │  - 消息队列：缓存待发送消息                                            │  │
│  │  - 优先级队列：高优先级消息优先发送                                    │  │
│  │  - 延迟队列：延迟到指定时间发送                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    ↓                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  发送层 (Send Layer)                                                  │  │
│  │  - 消息验证：验证消息格式和内容                                        │  │
│  │  - 消息发送：调用企业微信API发送消息                                    │  │
│  │  - 重试机制：失败自动重试                                              │  │
│  │  - 限流控制：控制发送频率                                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    ↓                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  反馈层 (Feedback Layer)                                              │  │
│  │  - 发送结果：记录发送结果                                              │  │
│  │  - 失败处理：处理发送失败                                              │  │
│  │  - 状态更新：更新消息状态                                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 发送能力

```
┌──────────────────┬────────────────┬────────────────┬────────────────┐
│    发送能力       │    功能描述     │    使用场景     │    实现方式     │
├──────────────────┼────────────────┼────────────────┼────────────────┤
│ 机器人选择        | 选择合适机器人   | 多机器人负载均衡 | 选择算法       |
│ 回复延迟          | 计算回复延迟     | 模拟人工响应     | 延迟策略       |
│ 消息队列          | 缓存待发送消息   | 流量控制        | 内存队列/Redis  |
│ 优先级队列        | 高优先级优先     | 紧急消息        | 优先级队列     |
│ 重试机制          | 失败自动重试     | 提高成功率      | 指数退避       |
│ 限流控制          | 控制发送频率     | 防止限流        | 令牌桶/漏桶    │
└──────────────────┴────────────────┴────────────────┴────────────────┘
```

---

## 2. 机器人选择

### 2.1 机器人类型

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              机器人类型                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 主要机器人 (main_bot)                                              │  │
│  │     - 用途：日常聊天、简单咨询                                          │  │
│  │     - 优先级：P2/P3                                                    │  │
│  │     - 负载：70%-90%                                                    │  │
│  │     - 延迟：3-10秒                                                     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 售后机器人 (after_sales_bot)                                       │  │
│  │     - 用途：售后任务、简单售后问题                                      │  │
│  │     - 优先级：P1/P2                                                    │  │
│  │     - 负载：60%-80%                                                    │  │
│  │     - 延迟：2-5秒                                                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 应急机器人 (emergency_bot)                                         │  │
│  │     - 用途：紧急投诉、P0告警                                            │  │
│  │     - 优先级：P0                                                       │  │
│  │     - 负载：30%-50%                                                    │  │
│  │     - 延迟：1-3秒                                                      │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 备用机器人 (backup_bot)                                            │  │
│  │     - 用途：主机器人故障时切换                                          │  │
│  │     - 优先级：P2/P3                                                    │  │
│  │     - 负载：40%-60%                                                    │  │
│  │     - 延迟：5-10秒                                                     │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 选择策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              选择策略                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 基于优先级选择                                                     │  │
│  │  - P0消息：选择应急机器人                                              │  │
│  │  - P1消息：选择售后机器人或主机器人（负载低）                          │  │
│  │  - P2消息：选择主机器人或备用机器人                                    │  │
│  │  - P3消息：选择主机器人或备用机器人                                    │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 基于负载选择                                                       │  │
│  │  - 优先选择负载低的机器人                                              │  │
│  │  - 负载 < 60%：正常使用                                                │  │
│  │  - 负载 60%-80%：谨慎使用                                              │  │
│  │  - 负载 > 80%：避免使用，选择备用机器人                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 基于健康状态选择                                                   │  │
│  │  - 健康状态：正常、异常、离线                                          │  │
│  │  - 正常：优先选择                                                      │  │
│  │  - 异常：避免选择，除非没有可用机器人                                  │  │
│  │  - 离线：不选择                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 基于类型选择                                                       │  │
│  │  - 投诉类消息：选择应急机器人                                          │  │
│  │  - 售后类消息：选择售后机器人                                          │  │
│  │  - 日常聊天：选择主机器人                                              │  │
│  │  - 查询咨询：选择主机器人或售后机器人                                  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.3 详细实现

**文件位置：** `server/services/robot.service.js`

```javascript
const { getDb } = require('coze-coding-dev-sdk');
const { robots, eq, sql, desc } = require('../database/schema');
const logger = require('./system-logger.service');

class RobotService {
  /**
   * 选择机器人
   */
  async selectRobotForReply(intent, priority) {
    try {
      logger.info('[机器人服务] 选择机器人', {
        intent,
        priority,
      });

      // 获取所有可用机器人
      const availableRobots = await this.getAvailableRobots();

      if (availableRobots.length === 0) {
        logger.error('[机器人服务] 没有可用的机器人');
        throw new Error('没有可用的机器人');
      }

      // 根据策略选择机器人
      let selectedRobot;

      // 策略1：基于优先级选择
      selectedRobot = this.selectByPriority(availableRobots, intent, priority);

      if (!selectedRobot) {
        // 策略2：基于负载选择
        selectedRobot = this.selectByLoad(availableRobots);
      }

      if (!selectedRobot) {
        // 策略3：默认选择第一个可用机器人
        selectedRobot = availableRobots[0];
      }

      logger.info('[机器人服务] 机器人选择成功', {
        robotId: selectedRobot.robotId,
        robotName: selectedRobot.robotName,
      });

      return selectedRobot;
    } catch (error) {
      logger.error('[机器人服务] 选择机器人失败', {
        intent,
        priority,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 基于优先级选择机器人
   */
  selectByPriority(robots, intent, priority) {
    // P0消息：选择应急机器人
    if (priority === 'P0') {
      const emergencyRobots = robots.filter(r => r.robotType === 'emergency_bot');
      return this.selectByLoad(emergencyRobots);
    }

    // P1消息：优先选择售后机器人
    if (priority === 'P1') {
      const afterSalesRobots = robots.filter(r => r.robotType === 'after_sales_bot');
      const selected = this.selectByLoad(afterSalesRobots);

      if (selected && selected.currentLoad < 80) {
        return selected;
      }

      // 如果售后机器人负载过高，选择主机器人
      const mainRobots = robots.filter(r => r.robotType === 'main_bot');
      return this.selectByLoad(mainRobots);
    }

    // P2消息：优先选择主机器人
    if (priority === 'P2') {
      const mainRobots = robots.filter(r => r.robotType === 'main_bot');
      const selected = this.selectByLoad(mainRobots);

      if (selected && selected.currentLoad < 80) {
        return selected;
      }

      // 如果主机器人负载过高，选择备用机器人
      const backupRobots = robots.filter(r => r.robotType === 'backup_bot');
      return this.selectByLoad(backupRobots);
    }

    // P3消息：选择主机器人或备用机器人
    if (priority === 'P3') {
      const mainRobots = robots.filter(r => r.robotType === 'main_bot');
      const selected = this.selectByLoad(mainRobots);

      if (selected) {
        return selected;
      }

      const backupRobots = robots.filter(r => r.robotType === 'backup_bot');
      return this.selectByLoad(backupRobots);
    }

    return null;
  }

  /**
   * 基于负载选择机器人
   */
  selectByLoad(robots) {
    if (robots.length === 0) {
      return null;
    }

    // 按负载排序，选择负载最低的
    const sortedRobots = robots.sort((a, b) => a.currentLoad - b.currentLoad);

    // 返回负载 < 90% 的机器人
    return sortedRobots.find(r => r.currentLoad < 90);
  }

  /**
   * 获取所有可用机器人
   */
  async getAvailableRobots() {
    const db = await getDb();

    const availableRobots = await db
      .select()
      .from(robots)
      .where(eq(robots.status, 'active'))
      .orderBy(desc(robots.priority));

    return availableRobots;
  }

  /**
   * 更新机器人负载
   */
  async updateRobotLoad(robotId, delta) {
    const db = await getDb();

    const robot = await db
      .select()
      .from(robots)
      .where(eq(robots.robotId, robotId))
      .limit(1);

    if (robot.length === 0) {
      return;
    }

    const newLoad = Math.max(0, Math.min(100, robot[0].currentLoad + delta));

    await db
      .update(robots)
      .set({
        currentLoad: newLoad,
        lastActiveAt: new Date(),
      })
      .where(eq(robots.robotId, robotId));

    logger.info('[机器人服务] 机器人负载更新', {
      robotId,
      oldLoad: robot[0].currentLoad,
      newLoad,
    });
  }

  /**
   * 获取机器人详情
   */
  async getRobotDetails(robotId) {
    const db = await getDb();

    const robot = await db
      .select()
      .from(robots)
      .where(eq(robots.robotId, robotId))
      .limit(1);

    if (robot.length === 0) {
      return null;
    }

    return robot[0];
  }

  /**
   * 获取机器人列表
   */
  async getRobotList(params) {
    const db = await getDb();

    const { status, robotType, page = 1, pageSize = 20 } = params;
    const offset = (page - 1) * pageSize;

    const conditions = [];

    if (status) {
      conditions.push(eq(robots.status, status));
    }

    if (robotType) {
      conditions.push(eq(robots.robotType, robotType));
    }

    const robotList = await db
      .select()
      .from(robots)
      .where(conditions.length > 0 ? and(...conditions) : sql`1=1`)
      .orderBy(desc(robots.priority))
      .limit(pageSize)
      .offset(offset);

    return {
      list: robotList,
      page,
      pageSize,
    };
  }
}

module.exports = new RobotService();
```

---

## 3. 回复延迟计算

### 3.1 延迟策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              延迟策略                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 基于优先级的延迟                                                   │  │
│  │  - P0消息：1-3秒（快速响应）                                            │  │
│  │  - P1消息：2-5秒（较快响应）                                            │  │
│  │  - P2消息：3-10秒（正常响应）                                           │  │
│  │  - P3消息：5-15秒（慢速响应）                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 基于意图的延迟                                                     │  │
│  │  - 投诉类：1-3秒（快速安抚）                                            │  │
│  │  - 售后类：2-5秒（及时响应）                                            │  │
│  │  - 查询类：3-8秒（正常响应）                                            │  │
│  │  - 日常聊天：5-15秒（自然延迟）                                         │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 基于情感的延迟                                                     │  │
│  │  - 负面高强度：1-3秒（快速安抚）                                        │  │
│  │  - 负面中强度：2-5秒（及时响应）                                        │  │
│  │  - 负面低强度：3-8秒（正常响应）                                        │  │
│  │  - 中性/正面：5-15秒（自然延迟）                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 随机延迟                                                           │  │
│  │  - 在基础延迟上增加±20%的随机值                                        │  │
│  │  - 使回复更自然                                                        │  │
│  │  - 避免机械感                                                          │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 详细实现

**文件位置：** `server/services/message-send.service.js`

```javascript
const robotService = require('./robot.service');
const weChatWorkService = require('./wechat-work.service');
const messageQueueService = require('./message-queue.service');
const logger = require('./system-logger.service');

class MessageSendService {
  /**
   * 发送消息
   */
  async sendMessage(messageData) {
    try {
      logger.info('[消息发送] 准备发送消息', {
        sessionId: messageData.sessionId,
        groupId: messageData.groupId,
      });

      // 1. 选择机器人
      const robot = messageData.robot || await robotService.selectRobotForReply(
        messageData.intent,
        messageData.priority || 'P2'
      );

      // 2. 计算回复延迟
      const delay = messageData.delay !== undefined ? messageData.delay : await this.getReplyDelay(
        messageData.intent,
        messageData.priority || 'P2',
        messageData.sentiment,
        messageData.sentimentIntensity
      );

      // 3. 添加到消息队列
      const queuedMessage = await messageQueueService.enqueue({
        robot,
        sessionId: messageData.sessionId,
        groupId: messageData.groupId,
        content: messageData.content,
        delay,
        priority: messageData.priority || 'P2',
      });

      logger.info('[消息发送] 消息已加入队列', {
        messageId: queuedMessage.id,
        robotId: robot.robotId,
        delay,
      });

      return queuedMessage;
    } catch (error) {
      logger.error('[消息发送] 发送消息失败', {
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 获取回复延迟
   */
  async getReplyDelay(intent, priority, sentiment = 'neutral', sentimentIntensity = 'low') {
    // 基础延迟
    let baseDelay;

    // 策略1：基于优先级
    if (priority === 'P0') {
      baseDelay = this.randomRange(1, 3);
    } else if (priority === 'P1') {
      baseDelay = this.randomRange(2, 5);
    } else if (priority === 'P2') {
      baseDelay = this.randomRange(3, 10);
    } else {
      baseDelay = this.randomRange(5, 15);
    }

    // 策略2：基于意图调整
    if (intent === 'complaint') {
      baseDelay = Math.min(baseDelay, this.randomRange(1, 3));
    } else if (intent === 'after_sales') {
      baseDelay = Math.min(baseDelay, this.randomRange(2, 5));
    } else if (intent === 'query') {
      baseDelay = Math.min(baseDelay, this.randomRange(3, 8));
    } else if (intent === 'daily_chat') {
      baseDelay = Math.max(baseDelay, this.randomRange(5, 15));
    }

    // 策略3：基于情感调整
    if (sentiment === 'negative' && sentimentIntensity === 'high') {
      baseDelay = Math.min(baseDelay, this.randomRange(1, 3));
    } else if (sentiment === 'negative' && sentimentIntensity === 'medium') {
      baseDelay = Math.min(baseDelay, this.randomRange(2, 5));
    } else if (sentiment === 'negative' && sentimentIntensity === 'low') {
      baseDelay = Math.min(baseDelay, this.randomRange(3, 8));
    }

    // 策略4：添加随机值
    const randomFactor = 1 + (Math.random() * 0.4 - 0.2); // ±20%
    const finalDelay = baseDelay * randomFactor;

    logger.info('[消息发送] 计算回复延迟', {
      intent,
      priority,
      sentiment,
      sentimentIntensity,
      baseDelay,
      randomFactor,
      finalDelay,
    });

    return Math.max(1, Math.round(finalDelay));
  }

  /**
   * 生成随机范围
   */
  randomRange(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * 立即发送消息（忽略延迟）
   */
  async sendImmediately(messageData) {
    try {
      logger.info('[消息发送] 立即发送消息', {
        sessionId: messageData.sessionId,
        groupId: messageData.groupId,
      });

      // 1. 选择机器人
      const robot = messageData.robot || await robotService.selectRobotForReply(
        messageData.intent || 'daily_chat',
        'P2'
      );

      // 2. 调用企业微信API发送消息
      const result = await weChatWorkService.sendMessage({
        webhook: robot.webhookUrl,
        message: {
          msgtype: 'text',
          text: {
            content: messageData.content,
          },
        },
      });

      // 3. 更新机器人负载
      await robotService.updateRobotLoad(robot.robotId, 5); // 每次发送增加5%负载

      // 4. 5秒后恢复负载
      setTimeout(() => {
        robotService.updateRobotLoad(robot.robotId, -5);
      }, 5000);

      logger.info('[消息发送] 消息发送成功', {
        robotId: robot.robotId,
        result,
      });

      return result;
    } catch (error) {
      logger.error('[消息发送] 立即发送消息失败', {
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }
}

module.exports = new MessageSendService();
```

---

## 4. 消息发送流程

### 4.1 完整流程

```
AI生成回复
    ↓
准备发送消息
    ├─ 回复内容：AI生成的回复
    ├─ 意图：消息意图
    ├─ 优先级：消息优先级
    ├─ 情感：用户情感
    └─ 情感强度：情感强度
    ↓
选择机器人
    ├─ 获取所有可用机器人
    ├─ 根据优先级筛选
    ├─ 根据负载筛选
    ├─ 根据健康状态筛选
    └─ 选择最优机器人
    ↓
计算回复延迟
    ├─ 根据优先级计算基础延迟
    ├─ 根据意图调整延迟
    ├─ 根据情感调整延迟
    ├─ 添加随机值
    └─ 得到最终延迟
    ↓
添加到消息队列
    ├─ 创建队列消息
    ├─ 设置延迟时间
    ├─ 设置优先级
    └─ 保存到队列
    ↓
延迟等待
    ├─ 延迟N秒
    ├─ 定时器检查
    └─ 到达发送时间
    ↓
从队列取出消息
    ├─ 获取消息内容
    ├─ 获取目标机器人
    ├─ 获取目标群组
    └─ 验证消息
    ↓
调用企业微信API
    ├─ 构建API请求
    ├─ 调用机器人Webhook
    ├─ 获取发送结果
    └─ 记录发送日志
    ↓
发送成功？
    ├─ 是 → 继续
    └─ 否 → 重试
        ├─ 重试次数 < 3 → 重新发送
        └─ 重试次数 >= 3 → 标记失败，通知管理员
    ↓
更新机器人负载
    ├─ 负载 + 5%
    ├─ 记录活动时间
    └─ 5秒后恢复
    ↓
记录发送日志
    ├─ 消息ID
    ├─ 机器人ID
    ├─ 群组ID
    ├─ 发送时间
    ├─ 发送状态
    └─ 发送结果
    ↓
发送完成
```

### 4.2 消息队列

**文件位置：** `server/services/message-queue.service.js`

```javascript
const logger = require('./system-logger.service');

class MessageQueueService {
  constructor() {
    this.queue = [];
    this.processing = false;
  }

  /**
   * 添加消息到队列
   */
  async enqueue(messageData) {
    const message = {
      id: this.generateMessageId(),
      robot: messageData.robot,
      sessionId: messageData.sessionId,
      groupId: messageData.groupId,
      content: messageData.content,
      delay: messageData.delay * 1000, // 转换为毫秒
      priority: messageData.priority,
      enqueuedAt: Date.now(),
      scheduledAt: Date.now() + messageData.delay * 1000,
      status: 'queued',
    };

    this.queue.push(message);

    // 按优先级和发送时间排序
    this.sortQueue();

    logger.info('[消息队列] 消息已加入队列', {
      messageId: message.id,
      priority: message.priority,
      delay: message.delay,
    });

    // 启动处理流程
    this.startProcessing();

    return message;
  }

  /**
   * 启动处理流程
   */
  async startProcessing() {
    if (this.processing) {
      return;
    }

    this.processing = true;

    logger.info('[消息队列] 开始处理队列');

    while (this.queue.length > 0) {
      await this.processNextMessage();
    }

    this.processing = false;

    logger.info('[消息队列] 队列处理完成');
  }

  /**
   * 处理下一条消息
   */
  async processNextMessage() {
    if (this.queue.length === 0) {
      return;
    }

    // 获取下一条消息
    const message = this.queue[0];

    // 检查是否到达发送时间
    const now = Date.now();
    const waitTime = message.scheduledAt - now;

    if (waitTime > 0) {
      // 等待到发送时间
      await this.sleep(waitTime);
    }

    // 从队列中取出消息
    this.queue.shift();

    // 发送消息
    await this.sendMessage(message);
  }

  /**
   * 发送消息
   */
  async sendMessage(message) {
    try {
      logger.info('[消息队列] 发送消息', {
        messageId: message.id,
      });

      const messageSendService = require('./message-send.service');

      // 立即发送消息
      await messageSendService.sendImmediately({
        robot: message.robot,
        sessionId: message.sessionId,
        groupId: message.groupId,
        content: message.content,
      });

      // 更新消息状态
      message.status = 'sent';
      message.sentAt = Date.now();

      logger.info('[消息队列] 消息发送成功', {
        messageId: message.id,
      });
    } catch (error) {
      logger.error('[消息队列] 消息发送失败', {
        messageId: message.id,
        error: error.message,
        stack: error.stack,
      });

      // 重试逻辑
      message.retryCount = (message.retryCount || 0) + 1;

      if (message.retryCount < 3) {
        // 重新加入队列，延迟5秒
        message.scheduledAt = Date.now() + 5000;
        message.status = 'retrying';
        this.queue.push(message);
        this.sortQueue();
      } else {
        // 标记为失败
        message.status = 'failed';
        message.failedAt = Date.now();
        message.error = error.message;
      }
    }
  }

  /**
   * 排序队列
   */
  sortQueue() {
    this.queue.sort((a, b) => {
      // 先按优先级排序
      const priorityOrder = { 'P0': 0, 'P1': 1, 'P2': 2, 'P3': 3 };
      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];

      if (priorityDiff !== 0) {
        return priorityDiff;
      }

      // 再按发送时间排序
      return a.scheduledAt - b.scheduledAt;
    });
  }

  /**
   * 生成消息ID
   */
  generateMessageId() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `MSG-${timestamp}-${random}`;
  }

  /**
   * 睡眠函数
   */
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * 获取队列状态
   */
  getQueueStatus() {
    return {
      total: this.queue.length,
      processing: this.processing,
      messages: this.queue.map(m => ({
        id: m.id,
        priority: m.priority,
        status: m.status,
        scheduledAt: new Date(m.scheduledAt),
      })),
    };
  }
}

module.exports = new MessageQueueService();
```

---

## 5. 机器人管理

### 5.1 机器人健康检查

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              健康检查                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  检查项：                                                              │  │
│  │  1. Webhook可用性：测试Webhook是否可访问                               │  │
│  │  2. 响应时间：测试响应时间是否正常                                      │  │
│  │  3. 发送成功率：最近1小时发送成功率                                      │  │
│  │  4. 负载状态：当前负载是否过高                                           │  │
│  │                                                                        │  │
│  │  健康状态：                                                            │  │
│  │  - 正常：所有检查项正常                                                │  │
│  │  - 异常：部分检查项异常                                                │  │
│  │  - 离线：Webhook不可用                                                 │  │
│  │                                                                        │  │
│  │  检查频率：每5分钟检查一次                                              │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**文档版本**：v1.0

**最后更新**：2024-01-10

**文档作者**：WorkTool AI 团队
