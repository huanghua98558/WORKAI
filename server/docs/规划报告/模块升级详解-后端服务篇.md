# WorkTool AI ä¸­æ¢ç³»ç»Ÿ - æ¨¡å—å‡çº§è¯¦è§£ï¼ˆåç«¯æœåŠ¡ç¯‡ï¼‰

## ğŸ“‹ ç›®å½•

1. [ç”¨æˆ·ç®¡ç†æœåŠ¡](#1-ç”¨æˆ·ç®¡ç†æœåŠ¡)
2. [è§’è‰²ç®¡ç†æœåŠ¡](#2-è§’è‰²ç®¡ç†æœåŠ¡)
3. [æƒé™ç®¡ç†æœåŠ¡](#3-æƒé™ç®¡ç†æœåŠ¡)
4. [å®¡è®¡æ—¥å¿—æœåŠ¡](#4-å®¡è®¡æ—¥å¿—æœåŠ¡)
5. [AIé…ç½®æœåŠ¡](#5-aié…ç½®æœåŠ¡)
6. [å‘Šè­¦é…ç½®æœåŠ¡](#6-å‘Šè­¦é…ç½®æœåŠ¡)
7. [å·¥ä½œäººå‘˜æ´»åŠ¨ç›‘æ§æœåŠ¡](#7-å·¥ä½œäººå‘˜æ´»åŠ¨ç›‘æ§æœåŠ¡)
8. [ç”¨æˆ·æ»¡æ„åº¦åˆ†ææœåŠ¡](#8-ç”¨æˆ·æ»¡æ„åº¦åˆ†ææœåŠ¡)
9. [è…¾è®¯æ–‡æ¡£åŒæ­¥æœåŠ¡](#9-è…¾è®¯æ–‡æ¡£åŒæ­¥æœåŠ¡)
10. [æœºå™¨äººæœåŠ¡ä¼˜åŒ–](#10-æœºå™¨äººæœåŠ¡ä¼˜åŒ–)
11. [æ¶ˆæ¯æœåŠ¡ä¼˜åŒ–](#11-æ¶ˆæ¯æœåŠ¡ä¼˜åŒ–)

---

## 1. ç”¨æˆ·ç®¡ç†æœåŠ¡

### 1.1 æœåŠ¡æ¦‚è¿°

ç”¨æˆ·ç®¡ç†æœåŠ¡è´Ÿè´£ç”¨æˆ·çš„åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ã€æŸ¥è¯¢ã€è§’è‰²åˆ†é…ç­‰æ“ä½œã€‚

### 1.2 æ–‡ä»¶ä½ç½®

`server/services/user.service.js`

### 1.3 æœåŠ¡å®ç°

```javascript
const { getDb } = require('coze-coding-dev-sdk');
const { users, userRoles, roles, eq, and, isNull } = require('../database/schema');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const auditLogService = require('./audit-log.service');

class UserService {
  /**
   * åˆ›å»ºç”¨æˆ·
   */
  async createUser(userData, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥ç”¨æˆ·åæ˜¯å¦å·²å­˜åœ¨
    const existingUser = await db.select().from(users)
      .where(eq(users.username, userData.username))
      .limit(1);

    if (existingUser.length > 0) {
      throw new Error('ç”¨æˆ·åå·²å­˜åœ¨');
    }

    // æ£€æŸ¥é‚®ç®±æ˜¯å¦å·²å­˜åœ¨
    if (userData.email) {
      const existingEmail = await db.select().from(users)
        .where(eq(users.email, userData.email))
        .limit(1);

      if (existingEmail.length > 0) {
        throw new Error('é‚®ç®±å·²å­˜åœ¨');
      }
    }

    // å¯†ç åŠ å¯†
    const hashedPassword = await bcrypt.hash(userData.password, 10);

    // åˆ›å»ºç”¨æˆ·
    const newUser = await db.insert(users).values({
      username: userData.username,
      password: hashedPassword,
      email: userData.email,
      phone: userData.phone,
      realName: userData.realName,
      status: userData.status || 'active',
    }).returning();

    // åˆ†é…é»˜è®¤è§’è‰²
    if (userData.roleIds && userData.roleIds.length > 0) {
      await this.assignRolesToUser(newUser[0].id, userData.roleIds, operatorId);
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'create',
      resourceType: 'user',
      resourceId: newUser[0].id,
      description: `åˆ›å»ºç”¨æˆ·ï¼š${userData.username}`,
      requestData: userData,
      status: 'success',
    });

    return newUser[0];
  }

  /**
   * æ›´æ–°ç”¨æˆ·
   */
  async updateUser(userId, userData, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await db.select().from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (existingUser.length === 0) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // æ›´æ–°ç”¨æˆ·
    const updateData = {
      ...userData,
      updatedAt: new Date(),
    };

    // å¦‚æœæ›´æ–°å¯†ç ï¼Œéœ€è¦åŠ å¯†
    if (userData.password) {
      updateData.password = await bcrypt.hash(userData.password, 10);
    }

    // å¦‚æœæ›´æ–°é‚®ç®±ï¼Œæ£€æŸ¥æ˜¯å¦é‡å¤
    if (userData.email && userData.email !== existingUser[0].email) {
      const existingEmail = await db.select().from(users)
        .where(and(
          eq(users.email, userData.email),
          eq(users.id, userId)
        ))
        .limit(1);

      if (existingEmail.length > 0) {
        throw new Error('é‚®ç®±å·²å­˜åœ¨');
      }
    }

    // åˆ é™¤passwordå­—æ®µï¼Œå¦‚æœä¸éœ€è¦æ›´æ–°å¯†ç 
    if (!userData.password) {
      delete updateData.password;
    }

    await db.update(users)
      .set(updateData)
      .where(eq(users.id, userId));

    // æ›´æ–°è§’è‰²
    if (userData.roleIds) {
      await this.assignRolesToUser(userId, userData.roleIds, operatorId);
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'update',
      resourceType: 'user',
      resourceId: userId,
      description: `æ›´æ–°ç”¨æˆ·ï¼š${existingUser[0].username}`,
      requestData: userData,
      status: 'success',
    });

    return { id: userId, ...updateData };
  }

  /**
   * åˆ é™¤ç”¨æˆ·
   */
  async deleteUser(userId, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await db.select().from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (existingUser.length === 0) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // è½¯åˆ é™¤ï¼šè®¾ç½®deleted_atå­—æ®µ
    await db.update(users)
      .set({ deletedAt: new Date(), status: 'inactive' })
      .where(eq(users.id, userId));

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'delete',
      resourceType: 'user',
      resourceId: userId,
      description: `åˆ é™¤ç”¨æˆ·ï¼š${existingUser[0].username}`,
      status: 'success',
    });

    return { success: true };
  }

  /**
   * è·å–ç”¨æˆ·åˆ—è¡¨
   */
  async getUserList(params) {
    const db = await getDb();
    const { page = 1, pageSize = 20, search, status, roleId } = params;
    const offset = (page - 1) * pageSize;

    let query = db.select({
      id: users.id,
      username: users.username,
      email: users.email,
      phone: users.phone,
      realName: users.realName,
      status: users.status,
      createdAt: users.createdAt,
      updatedAt: users.updatedAt,
    }).from(users).where(isNull(users.deletedAt));

    // æœç´¢æ¡ä»¶
    if (search) {
      query = query.where(
        sql`(${users.username} ILIKE ${`%${search}%`} OR ${users.email} ILIKE ${`%${search}%`} OR ${users.realName} ILIKE ${`%${search}%`})`
      );
    }

    // çŠ¶æ€ç­›é€‰
    if (status) {
      query = query.where(eq(users.status, status));
    }

    // è§’è‰²ç­›é€‰
    if (roleId) {
      query = query.innerJoin(
        userRoles,
        and(eq(userRoles.userId, users.id), eq(userRoles.roleId, roleId))
      );
    }

    // åˆ†é¡µ
    query = query.limit(pageSize).offset(offset);

    // æ‰§è¡ŒæŸ¥è¯¢
    const result = await query;

    // è·å–æ€»æ•°
    let countQuery = db.select({ count: sql`COUNT(*)` }).from(users).where(isNull(users.deletedAt));

    if (search) {
      countQuery = countQuery.where(
        sql`(${users.username} ILIKE ${`%${search}%`} OR ${users.email} ILIKE ${`%${search}%`} OR ${users.realName} ILIKE ${`%${search}%`})`
      );
    }

    if (status) {
      countQuery = countQuery.where(eq(users.status, status));
    }

    const countResult = await countQuery;
    const total = parseInt(countResult[0].count);

    // è·å–ç”¨æˆ·è§’è‰²
    const userIds = result.map(u => u.id);
    const userRoleList = await db.select({
      userId: userRoles.userId,
      roleId: userRoles.roleId,
      roleName: roles.roleName,
      roleCode: roles.roleCode,
    })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(sql`${userRoles.userId} = ANY(${userIds})`);

    // ç»„è£…ç»“æœ
    const userList = result.map(user => {
      const userRoles = userRoleList.filter(ur => ur.userId === user.id);
      return {
        ...user,
        roles: userRoles,
      };
    });

    return {
      list: userList,
      total,
      page,
      pageSize,
    };
  }

  /**
   * è·å–ç”¨æˆ·è¯¦æƒ…
   */
  async getUserById(userId) {
    const db = await getDb();

    // è·å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
    const user = await db.select().from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (user.length === 0) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // è·å–ç”¨æˆ·è§’è‰²
    const userRoles = await db.select({
      roleId: userRoles.roleId,
      roleName: roles.roleName,
      roleCode: roles.roleCode,
    })
      .from(userRoles)
      .innerJoin(roles, eq(userRoles.roleId, roles.id))
      .where(eq(userRoles.userId, userId));

    return {
      ...user[0],
      roles: userRoles,
    };
  }

  /**
   * åˆ†é…è§’è‰²ç»™ç”¨æˆ·
   */
  async assignRolesToUser(userId, roleIds, operatorId) {
    const db = await getDb();

    // åˆ é™¤ç°æœ‰è§’è‰²
    await db.delete(userRoles).where(eq(userRoles.userId, userId));

    // åˆ†é…æ–°è§’è‰²
    for (const roleId of roleIds) {
      await db.insert(userRoles).values({
        userId,
        roleId,
        assignedBy: operatorId,
      });
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'assign',
      resourceType: 'user_role',
      resourceId: userId,
      description: `åˆ†é…è§’è‰²ç»™ç”¨æˆ·`,
      requestData: { userId, roleIds },
      status: 'success',
    });

    return { success: true };
  }

  /**
   * é‡ç½®å¯†ç 
   */
  async resetPassword(userId, newPassword, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await db.select().from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (existingUser.length === 0) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // åŠ å¯†æ–°å¯†ç 
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // æ›´æ–°å¯†ç 
    await db.update(users)
      .set({
        password: hashedPassword,
        updatedAt: new Date(),
      })
      .where(eq(users.id, userId));

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'reset_password',
      resourceType: 'user',
      resourceId: userId,
      description: `é‡ç½®ç”¨æˆ·å¯†ç ï¼š${existingUser[0].username}`,
      status: 'success',
    });

    return { success: true };
  }

  /**
   * é”å®šç”¨æˆ·
   */
  async lockUser(userId, lockMinutes, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await db.select().from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (existingUser.length === 0) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // é”å®šç”¨æˆ·
    const lockedUntil = new Date(Date.now() + lockMinutes * 60 * 1000);

    await db.update(users)
      .set({
        status: 'locked',
        lockedUntil,
        updatedAt: new Date(),
      })
      .where(eq(users.id, userId));

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'lock',
      resourceType: 'user',
      resourceId: userId,
      description: `é”å®šç”¨æˆ·ï¼š${existingUser[0].username}ï¼Œé”å®šæ—¶é•¿ï¼š${lockMinutes}åˆ†é’Ÿ`,
      status: 'success',
    });

    return { success: true, lockedUntil };
  }

  /**
   * è§£é”ç”¨æˆ·
   */
  async unlockUser(userId, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å­˜åœ¨
    const existingUser = await db.select().from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (existingUser.length === 0) {
      throw new Error('ç”¨æˆ·ä¸å­˜åœ¨');
    }

    // è§£é”ç”¨æˆ·
    await db.update(users)
      .set({
        status: 'active',
        lockedUntil: null,
        failedLoginCount: 0,
        updatedAt: new Date(),
      })
      .where(eq(users.id, userId));

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'unlock',
      resourceType: 'user',
      resourceId: userId,
      description: `è§£é”ç”¨æˆ·ï¼š${existingUser[0].username}`,
      status: 'success',
    });

    return { success: true };
  }

  /**
   * ç”¨æˆ·ç™»å½•
   */
  async loginUser(username, password, ipAddress, userAgent) {
    const db = await getDb();

    // æŸ¥æ‰¾ç”¨æˆ·
    const user = await db.select().from(users)
      .where(eq(users.username, username))
      .limit(1);

    if (user.length === 0) {
      throw new Error('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
    }

    const userData = user[0];

    // æ£€æŸ¥è´¦æˆ·æ˜¯å¦è¢«åˆ é™¤
    if (userData.deletedAt) {
      throw new Error('ç”¨æˆ·å·²è¢«åˆ é™¤');
    }

    // æ£€æŸ¥è´¦æˆ·çŠ¶æ€
    if (userData.status === 'inactive') {
      throw new Error('è´¦æˆ·å·²è¢«ç¦ç”¨');
    }

    // æ£€æŸ¥è´¦æˆ·æ˜¯å¦è¢«é”å®š
    if (userData.lockedUntil && new Date() < new Date(userData.lockedUntil)) {
      throw new Error('è´¦æˆ·å·²è¢«é”å®š');
    }

    // éªŒè¯å¯†ç 
    const isPasswordValid = await bcrypt.compare(password, userData.password);

    if (!isPasswordValid) {
      // å¢åŠ å¤±è´¥æ¬¡æ•°
      const failedLoginCount = (userData.failedLoginCount || 0) + 1;

      // å¦‚æœå¤±è´¥æ¬¡æ•°è¶…è¿‡5æ¬¡ï¼Œé”å®šè´¦æˆ·30åˆ†é’Ÿ
      if (failedLoginCount >= 5) {
        await db.update(users)
          .set({
            status: 'locked',
            lockedUntil: new Date(Date.now() + 30 * 60 * 1000),
            failedLoginCount,
          })
          .where(eq(users.id, userData.id));

        // è®°å½•å®¡è®¡æ—¥å¿—
        await auditLogService.log({
          userId: userData.id,
          operationType: 'login_failed',
          resourceType: 'user',
          resourceId: userData.id,
          description: `ç™»å½•å¤±è´¥ï¼Œè´¦æˆ·è¢«é”å®š`,
          ipAddress,
          userAgent,
          status: 'failed',
        });

        throw new Error('ç™»å½•å¤±è´¥æ¬¡æ•°è¿‡å¤šï¼Œè´¦æˆ·å·²è¢«é”å®š30åˆ†é’Ÿ');
      } else {
        await db.update(users)
          .set({ failedLoginCount })
          .where(eq(users.id, userData.id));
      }

      // è®°å½•å®¡è®¡æ—¥å¿—
      await auditLogService.log({
        userId: userData.id,
        operationType: 'login_failed',
        resourceType: 'user',
        resourceId: userData.id,
        description: `ç™»å½•å¤±è´¥`,
        ipAddress,
        userAgent,
        status: 'failed',
      });

      throw new Error('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯');
    }

    // æ¸…é™¤å¤±è´¥æ¬¡æ•°
    await db.update(users)
      .set({
        failedLoginCount: 0,
        lastLoginAt: new Date(),
        lastLoginIp: ipAddress,
      })
      .where(eq(users.id, userData.id));

    // ç”ŸæˆJWT token
    const token = jwt.sign(
      {
        userId: userData.id,
        username: userData.username,
        roleCode: userData.roleCode,
      },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: userData.id,
      operationType: 'login',
      resourceType: 'user',
      resourceId: userData.id,
      description: `ç”¨æˆ·ç™»å½•`,
      ipAddress,
      userAgent,
      status: 'success',
    });

    return {
      token,
      user: {
        id: userData.id,
        username: userData.username,
        email: userData.email,
        realName: userData.realName,
        status: userData.status,
      },
    };
  }
}

module.exports = new UserService();
```

---

## 2. è§’è‰²ç®¡ç†æœåŠ¡

### 2.1 æœåŠ¡æ¦‚è¿°

è§’è‰²ç®¡ç†æœåŠ¡è´Ÿè´£è§’è‰²çš„åˆ›å»ºã€æ›´æ–°ã€åˆ é™¤ã€æŸ¥è¯¢ã€æƒé™åˆ†é…ç­‰æ“ä½œã€‚

### 2.2 æ–‡ä»¶ä½ç½®

`server/services/role.service.js`

### 2.3 æœåŠ¡å®ç°

```javascript
const { getDb } = require('coze-coding-dev-sdk');
const { roles, rolePermissions, permissions, users, userRoles, eq } = require('../database/schema');
const auditLogService = require('./audit-log.service');

class RoleService {
  /**
   * åˆ›å»ºè§’è‰²
   */
  async createRole(roleData, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥è§’è‰²ä»£ç æ˜¯å¦å·²å­˜åœ¨
    const existingRole = await db.select().from(roles)
      .where(eq(roles.roleCode, roleData.roleCode))
      .limit(1);

    if (existingRole.length > 0) {
      throw new Error('è§’è‰²ä»£ç å·²å­˜åœ¨');
    }

    // åˆ›å»ºè§’è‰²
    const newRole = await db.insert(roles).values({
      roleName: roleData.roleName,
      roleCode: roleData.roleCode,
      description: roleData.description,
      isSystem: roleData.isSystem || false,
    }).returning();

    // åˆ†é…æƒé™
    if (roleData.permissionIds && roleData.permissionIds.length > 0) {
      await this.assignPermissionsToRole(newRole[0].id, roleData.permissionIds, operatorId);
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'create',
      resourceType: 'role',
      resourceId: newRole[0].id,
      description: `åˆ›å»ºè§’è‰²ï¼š${roleData.roleName}`,
      requestData: roleData,
      status: 'success',
    });

    return newRole[0];
  }

  /**
   * æ›´æ–°è§’è‰²
   */
  async updateRole(roleId, roleData, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
    const existingRole = await db.select().from(roles)
      .where(eq(roles.id, roleId))
      .limit(1);

    if (existingRole.length === 0) {
      throw new Error('è§’è‰²ä¸å­˜åœ¨');
    }

    // ç³»ç»Ÿè§’è‰²ä¸èƒ½ä¿®æ”¹
    if (existingRole[0].isSystem) {
      throw new Error('ç³»ç»Ÿè§’è‰²ä¸èƒ½ä¿®æ”¹');
    }

    // æ›´æ–°è§’è‰²
    await db.update(roles)
      .set({
        roleName: roleData.roleName,
        description: roleData.description,
        updatedAt: new Date(),
      })
      .where(eq(roles.id, roleId));

    // æ›´æ–°æƒé™
    if (roleData.permissionIds) {
      await this.assignPermissionsToRole(roleId, roleData.permissionIds, operatorId);
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'update',
      resourceType: 'role',
      resourceId: roleId,
      description: `æ›´æ–°è§’è‰²ï¼š${existingRole[0].roleName}`,
      requestData: roleData,
      status: 'success',
    });

    return { id: roleId, ...roleData };
  }

  /**
   * åˆ é™¤è§’è‰²
   */
  async deleteRole(roleId, operatorId) {
    const db = await getDb();

    // æ£€æŸ¥è§’è‰²æ˜¯å¦å­˜åœ¨
    const existingRole = await db.select().from(roles)
      .where(eq(roles.id, roleId))
      .limit(1);

    if (existingRole.length === 0) {
      throw new Error('è§’è‰²ä¸å­˜åœ¨');
    }

    // ç³»ç»Ÿè§’è‰²ä¸èƒ½åˆ é™¤
    if (existingRole[0].isSystem) {
      throw new Error('ç³»ç»Ÿè§’è‰²ä¸èƒ½åˆ é™¤');
    }

    // æ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·ä½¿ç”¨è¯¥è§’è‰²
    const userCount = await db.select({ count: sql`COUNT(*)` })
      .from(userRoles)
      .where(eq(userRoles.roleId, roleId));

    if (parseInt(userCount[0].count) > 0) {
      throw new Error('è¯¥è§’è‰²æ­£åœ¨è¢«ä½¿ç”¨ï¼Œæ— æ³•åˆ é™¤');
    }

    // åˆ é™¤è§’è‰²
    await db.delete(roles).where(eq(roles.id, roleId));

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'delete',
      resourceType: 'role',
      resourceId: roleId,
      description: `åˆ é™¤è§’è‰²ï¼š${existingRole[0].roleName}`,
      status: 'success',
    });

    return { success: true };
  }

  /**
   * è·å–è§’è‰²åˆ—è¡¨
   */
  async getRoleList(params) {
    const db = await getDb();
    const { page = 1, pageSize = 20, search, isSystem } = params;
    const offset = (page - 1) * pageSize;

    let query = db.select().from(roles);

    // æœç´¢æ¡ä»¶
    if (search) {
      query = query.where(
        sql`(${roles.roleName} ILIKE ${`%${search}%`} OR ${roles.roleCode} ILIKE ${`%${search}%`})`
      );
    }

    // ç³»ç»Ÿè§’è‰²ç­›é€‰
    if (isSystem !== undefined) {
      query = query.where(eq(roles.isSystem, isSystem));
    }

    // åˆ†é¡µ
    query = query.limit(pageSize).offset(offset);

    // æ‰§è¡ŒæŸ¥è¯¢
    const result = await query;

    // è·å–æ€»æ•°
    let countQuery = db.select({ count: sql`COUNT(*)` }).from(roles);

    if (search) {
      countQuery = countQuery.where(
        sql`(${roles.roleName} ILIKE ${`%${search}%`} OR ${roles.roleCode} ILIKE ${`%${search}%`})`
      );
    }

    if (isSystem !== undefined) {
      countQuery = countQuery.where(eq(roles.isSystem, isSystem));
    }

    const countResult = await countQuery;
    const total = parseInt(countResult[0].count);

    // è·å–è§’è‰²æƒé™æ•°é‡
    const roleIds = result.map(r => r.id);
    const permissionCounts = await db.select({
      roleId: rolePermissions.roleId,
      count: sql`COUNT(*)`,
    })
      .from(rolePermissions)
      .where(sql`${rolePermissions.roleId} = ANY(${roleIds})`)
      .groupBy(rolePermissions.roleId);

    // è·å–è§’è‰²ç”¨æˆ·æ•°é‡
    const userCounts = await db.select({
      roleId: userRoles.roleId,
      count: sql`COUNT(*)`,
    })
      .from(userRoles)
      .where(sql`${userRoles.roleId} = ANY(${roleIds})`)
      .groupBy(userRoles.roleId);

    // ç»„è£…ç»“æœ
    const roleList = result.map(role => {
      const permCount = permissionCounts.find(pc => pc.roleId === role.id);
      const usrCount = userCounts.find(uc => uc.roleId === role.id);
      return {
        ...role,
        permissionCount: permCount ? parseInt(permCount.count) : 0,
        userCount: usrCount ? parseInt(usrCount.count) : 0,
      };
    });

    return {
      list: roleList,
      total,
      page,
      pageSize,
    };
  }

  /**
   * è·å–è§’è‰²è¯¦æƒ…
   */
  async getRoleById(roleId) {
    const db = await getDb();

    // è·å–è§’è‰²åŸºæœ¬ä¿¡æ¯
    const role = await db.select().from(roles)
      .where(eq(roles.id, roleId))
      .limit(1);

    if (role.length === 0) {
      throw new Error('è§’è‰²ä¸å­˜åœ¨');
    }

    // è·å–è§’è‰²æƒé™
    const rolePermissions = await db.select({
      permissionId: permissions.id,
      permissionName: permissions.permissionName,
      permissionCode: permissions.permissionCode,
      resourceType: permissions.resourceType,
      actionType: permissions.actionType,
    })
      .from(rolePermissions)
      .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
      .where(eq(rolePermissions.roleId, roleId));

    // è·å–è§’è‰²ç”¨æˆ·
    const roleUsers = await db.select({
      userId: users.id,
      username: users.username,
      realName: users.realName,
      email: users.email,
    })
      .from(userRoles)
      .innerJoin(users, eq(userRoles.userId, users.id))
      .where(eq(userRoles.roleId, roleId));

    return {
      ...role[0],
      permissions: rolePermissions,
      users: roleUsers,
    };
  }

  /**
   * åˆ†é…æƒé™ç»™è§’è‰²
   */
  async assignPermissionsToRole(roleId, permissionIds, operatorId) {
    const db = await getDb();

    // åˆ é™¤ç°æœ‰æƒé™
    await db.delete(rolePermissions).where(eq(rolePermissions.roleId, roleId));

    // åˆ†é…æ–°æƒé™
    for (const permissionId of permissionIds) {
      await db.insert(rolePermissions).values({
        roleId,
        permissionId,
        assignedBy: operatorId,
      });
    }

    // è®°å½•å®¡è®¡æ—¥å¿—
    await auditLogService.log({
      userId: operatorId,
      operationType: 'assign',
      resourceType: 'role_permission',
      resourceId: roleId,
      description: `åˆ†é…æƒé™ç»™è§’è‰²`,
      requestData: { roleId, permissionIds },
      status: 'success',
    });

    return { success: true };
  }

  /**
   * è·å–è§’è‰²çš„æ‰€æœ‰æƒé™
   */
  async getRolePermissions(roleId) {
    const db = await getDb();

    const permissions = await db.select({
      permissionId: permissions.id,
      permissionName: permissions.permissionName,
      permissionCode: permissions.permissionCode,
      resourceType: permissions.resourceType,
      actionType: permissions.actionType,
    })
      .from(rolePermissions)
      .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
      .where(eq(rolePermissions.roleId, roleId));

    return permissions;
  }
}

module.exports = new RoleService();
```

---

## 3. æƒé™ç®¡ç†æœåŠ¡

### 3.1 æœåŠ¡æ¦‚è¿°

æƒé™ç®¡ç†æœåŠ¡è´Ÿè´£æƒé™çš„æŸ¥è¯¢ã€æƒé™æ ‘æ„å»ºã€ç”¨æˆ·æƒé™æ£€æŸ¥ç­‰æ“ä½œã€‚

### 3.2 æ–‡ä»¶ä½ç½®

`server/services/permission.service.js`

### 3.3 æœåŠ¡å®ç°

```javascript
const { getDb } = require('coze-coding-dev-sdk');
const { userRoles, roles, rolePermissions, permissions, users, eq, sql } = require('../database/schema');
const { redis } = require('../lib/redis');

class PermissionService {
  /**
   * è·å–ç”¨æˆ·æ‰€æœ‰æƒé™ï¼ˆå¸¦ç¼“å­˜ï¼‰
   */
  async getUserPermissions(userId) {
    const cacheKey = `user:permissions:${userId}`;

    // å°è¯•ä»ç¼“å­˜è·å–
    if (redis) {
      try {
        const cached = await redis.get(cacheKey);
        if (cached) {
          return JSON.parse(cached);
        }
      } catch (error) {
        console.error('è¯»å–æƒé™ç¼“å­˜å¤±è´¥:', error);
      }
    }

    // ä»æ•°æ®åº“æŸ¥è¯¢
    const db = await getDb();
    const result = await db
      .select({ permissionCode: permissions.permissionCode })
      .from(userRoles)
      .innerJoin(rolePermissions, eq(userRoles.roleId, rolePermissions.roleId))
      .innerJoin(permissions, eq(rolePermissions.permissionId, permissions.id))
      .where(eq(userRoles.userId, userId));

    const perms = result.map(p => p.permissionCode);

    // ç¼“å­˜1å°æ—¶
    if (redis) {
      try {
        await redis.set(cacheKey, JSON.stringify(perms), 'EX', 3600);
      } catch (error) {
        console.error('ä¿å­˜æƒé™ç¼“å­˜å¤±è´¥:', error);
      }
    }

    return perms;
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æŒ‡å®šæƒé™
   */
  async hasPermission(userId, permissionCode) {
    const permissions = await this.getUserPermissions(userId);
    return permissions.includes(permissionCode);
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ä»»ä¸€æƒé™
   */
  async hasAnyPermission(userId, permissionCodes) {
    const permissions = await this.getUserPermissions(userId);
    return permissionCodes.some(code => permissions.includes(code));
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æ‰€æœ‰æƒé™
   */
  async hasAllPermissions(userId, permissionCodes) {
    const permissions = await this.getUserPermissions(userId);
    return permissionCodes.every(code => permissions.includes(code));
  }

  /**
   * æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜
   */
  async clearUserPermissionsCache(userId) {
    const cacheKey = `user:permissions:${userId}`;

    if (redis) {
      try {
        await redis.del(cacheKey);
      } catch (error) {
        console.error('æ¸…é™¤æƒé™ç¼“å­˜å¤±è´¥:', error);
      }
    }
  }

  /**
   * æ‰¹é‡æ¸…é™¤ç”¨æˆ·æƒé™ç¼“å­˜ï¼ˆè§’è‰²å˜æ›´æ—¶ï¼‰
   */
  async clearRolePermissionsCache(roleId) {
    // æŸ¥è¯¢æ‹¥æœ‰è¯¥è§’è‰²çš„æ‰€æœ‰ç”¨æˆ·
    const db = await getDb();
    const users = await db.select({ userId: userRoles.userId })
      .from(userRoles)
      .where(eq(userRoles.roleId, roleId));

    // æ¸…é™¤æ‰€æœ‰ç”¨æˆ·çš„æƒé™ç¼“å­˜
    for (const user of users) {
      await this.clearUserPermissionsCache(user.userId);
    }
  }

  /**
   * è·å–æƒé™æ ‘
   */
  async getPermissionTree() {
    const db = await getDb();

    const allPermissions = await db.select().from(permissions);

    // æŒ‰èµ„æºç±»å‹åˆ†ç»„
    const tree = {};
    allPermissions.forEach(p => {
      if (!tree[p.resourceType]) {
        tree[p.resourceType] = [];
      }
      tree[p.resourceType].push({
        id: p.id,
        name: p.permissionName,
        code: p.permissionCode,
        action: p.actionType,
      });
    });

    return tree;
  }

  /**
   * è·å–æƒé™åˆ—è¡¨
   */
  async getPermissionList(params) {
    const db = await getDb();
    const { page = 1, pageSize = 20, resourceType, actionType } = params;
    const offset = (page - 1) * pageSize;

    let query = db.select().from(permissions);

    // èµ„æºç±»å‹ç­›é€‰
    if (resourceType) {
      query = query.where(eq(permissions.resourceType, resourceType));
    }

    // æ“ä½œç±»å‹ç­›é€‰
    if (actionType) {
      query = query.where(eq(permissions.actionType, actionType));
    }

    // åˆ†é¡µ
    query = query.limit(pageSize).offset(offset).orderBy(permissions.resourceType, permissions.actionType);

    // æ‰§è¡ŒæŸ¥è¯¢
    const result = await query;

    // è·å–æ€»æ•°
    let countQuery = db.select({ count: sql`COUNT(*)` }).from(permissions);

    if (resourceType) {
      countQuery = countQuery.where(eq(permissions.resourceType, resourceType));
    }

    if (actionType) {
      countQuery = countQuery.where(eq(permissions.actionType, actionType));
    }

    const countResult = await countQuery;
    const total = parseInt(countResult[0].count);

    return {
      list: result,
      total,
      page,
      pageSize,
    };
  }
}

module.exports = new PermissionService();
```

---

**ç”±äºæ–‡æ¡£è¿‡é•¿ï¼Œåç»­å†…å®¹å°†åœ¨å…¶ä»–æ–‡ä»¶ä¸­ç»§ç»­...**

**æŸ¥çœ‹å…¶ä»–è¯¦ç»†æ–‡æ¡£ï¼š**
- `æ¨¡å—å‡çº§è¯¦è§£-å®¡è®¡æ—¥å¿—æœåŠ¡.md`
- `æ¨¡å—å‡çº§è¯¦è§£-AIé…ç½®æœåŠ¡.md`
- `æ¨¡å—å‡çº§è¯¦è§£-å‘Šè­¦é…ç½®æœåŠ¡.md`
- `æ¨¡å—å‡çº§è¯¦è§£-å·¥ä½œäººå‘˜æ´»åŠ¨ç›‘æ§æœåŠ¡.md`
- `æ¨¡å—å‡çº§è¯¦è§£-ç”¨æˆ·æ»¡æ„åº¦åˆ†ææœåŠ¡.md`
- `æ¨¡å—å‡çº§è¯¦è§£-è…¾è®¯æ–‡æ¡£åŒæ­¥æœåŠ¡.md`
- `æ¨¡å—å‡çº§è¯¦è§£-æœºå™¨äººæœåŠ¡ä¼˜åŒ–.md`
- `æ¨¡å—å‡çº§è¯¦è§£-æ¶ˆæ¯æœåŠ¡ä¼˜åŒ–.md`

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0

**æœ€åæ›´æ–°**ï¼š2024-01-10

**æ–‡æ¡£ä½œè€…**ï¼šWorkTool AI å›¢é˜Ÿ
