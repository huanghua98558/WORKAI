# 系统设计报告 - 最优解建议

## 更新时间

2024-01-10

## 说明

根据专业知识和经验，给出剩余6个待确认事项的最优解建议。

---

## 1. 机器人选择规则 - 最优解

### 当前规则

- 哪个机器人上报消息，哪个机器人回复（日常社群运营）
- 售后协助和运营老板除外（可以跨机器人回复）

### 最优解建议

#### 1.1 机器人职责明确化

| 机器人 | 职责 | 是否回复社群消息 | 备注 |
|-------|------|----------------|------|
| 监控机器人 | 监控所有消息，上报系统 | ❌ 不回复 | 只监控，不上报给其他机器人 |
| 通知机器人 | 发送通知、提醒、告警 | ❌ 不回复 | 只发送通知给人工 |
| 白班回复机器人 | 社群运营、疑虑解答、辅助人工、群里配合 | ✅ 回复 | 9:00-21:00在线 |
| 晚班回复机器人 | 社群运营、疑虑解答、辅助人工、群里配合 | ✅ 回复 | 21:00-次日9:00在线 |

#### 1.2 机器人选择规则细化

**规则1：监控机器人上报的消息**
- 监控机器人上报消息后，系统根据当前时段选择回复机器人
- 白班（9:00-21:00）：选择白班回复机器人
- 晚班（21:00-次日9:00）：选择晚班回复机器人

**规则2：通知机器人的消息**
- 通知机器人只发送通知给人工，不回复社群消息
- 通知对象：售后人工、管理层
- 通知内容：任务提醒、告警信息

**规则3：回复机器人的回复规则**

| 场景 | 选择机器人 | 说明 |
|------|-----------|------|
| 日常社群运营消息 | 白班/晚班回复机器人（根据时段） | 群里配合，辅助人工 |
| 售后任务通知 | 通知机器人 | 通知售后人工 |
| 售后任务协同 | 售后人工处理 | 系统监控、提醒、协同 |
| 运营老板消息 | 白班/晚班回复机器人（根据时段） | 辅助运营安抚用户 |
| P0紧急告警 | 通知机器人 | 通知管理层 |

**规则4：跨机器人回复的场景**
- **运营老板的消息**：由回复机器人协助（安抚），不跨机器人
- **售后任务**：不涉及机器人回复，由售后人工处理
- **P0紧急告警**：由通知机器人通知管理层，不涉及回复

#### 1.3 机器人选择流程图

```
新消息 → 识别发送者类型 → 判断消息类型 → 选择机器人

┌─────────────────────────────────────────────────────────────────────┐
│  1. 识别发送者类型                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │  用户（号主） → 判断消息类型                                     │  │
│  │  运营（老板） → 选择回复机器人（根据时段）                       │  │
│  │  售后人工 → 只记录，不回复                                       │  │
│  │  群助理 → 只记录，不回复                                         │  │
│  │  机器人 → 识别机器人类型                                         │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  2. 判断消息类型（如果是用户消息）                                    │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │  日常社群运营 → 选择回复机器人（根据时段）                       │  │
│  │  售后任务 → 创建售后任务，通知售后人工                           │  │
│  │  用户投诉 → 触发P0告警，通知管理层                              │  │
│  │  其他 → 判断是否需要回复，是则选择回复机器人                    │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│  3. 选择机器人                                                       │
│  ┌─────────────────────────────────────────────────────────────────┐  │
│  │  当前时段 = 白班（9:00-21:00） → 选择白班回复机器人              │  │
│  │  当前时段 = 晚班（21:00-次日9:00） → 选择晚班回复机器人           │  │
│  │  需要通知 → 选择通知机器人                                       │  │
│  └─────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

#### 1.4 配置化规则

为了提高灵活性，建议将机器人选择规则配置化：

**配置表：`robot_selection_rules`**

| 配置项 | 配置键 | 默认值 | 说明 |
|-------|-------|--------|------|
| 白班时间段 | `day_shift_time_range` | "09:00-21:00" | 白班时间段 |
| 晚班时间段 | `night_shift_time_range` | "21:00-09:00" | 晚班时间段 |
| 售后任务通知机器人 | `after_sales_notify_robot` | "notify_robot" | 售后任务通知机器人 |
| P0告警通知机器人 | `p0_alert_notify_robot` | "notify_robot" | P0告警通知机器人 |

---

## 2. 回复延迟设置 - 最优解

### 当前设置

- 白班（9:00-21:00）：3-10秒
- 晚班（21:00-次日9:00）：5-30秒

### 最优解建议

#### 2.1 回复延迟策略优化

| 场景 | 时段 | 延迟范围 | 说明 |
|------|------|---------|------|
| 日常社群运营 | 白班 | 2-8秒 | 更快速，提升用户体验 |
| 日常社群运营 | 晚班 | 5-30秒 | 保持不变，增加人性化 |
| 紧急消息（P0告警） | 全天 | 1-2秒 | 立即回复 |
| 售后任务提醒 | 全天 | 1-2秒 | 立即提醒 |
| 复杂问题解答 | 白班 | 5-15秒 | 给AI更多思考时间 |
| 复杂问题解答 | 晚班 | 10-30秒 | 晚间可以更慢 |

#### 2.2 回复延迟配置化

**配置表：`reply_delay_settings`**

| 配置项 | 配置键 | 默认值 | 说明 | 可调节范围 |
|-------|-------|--------|------|-----------|
| 白班运营消息延迟 | `day_shift_operation_delay` | 2-8（秒） | 日常运营消息 | 1-15（秒） |
| 晚班运营消息延迟 | `night_shift_operation_delay` | 5-30（秒） | 日常运营消息 | 3-60（秒） |
| 紧急消息延迟 | `urgent_message_delay` | 1-2（秒） | P0告警等紧急消息 | 0-5（秒） |
| 售后任务提醒延迟 | `after_sales_notify_delay` | 1-2（秒） | 售后任务提醒 | 0-5（秒） |
| 白班复杂问题延迟 | `day_shift_complex_delay` | 5-15（秒） | 复杂问题解答 | 3-30（秒） |
| 晚班复杂问题延迟 | `night_shift_complex_delay` | 10-30（秒） | 复杂问题解答 | 5-60（秒） |

#### 2.3 回复延迟实现策略

**策略1：随机延迟**
- 在设定的延迟范围内随机选择一个延迟时间
- 例如：白班运营消息延迟2-8秒，随机选择5秒

**策略2：固定延迟**
- 使用固定的延迟时间
- 例如：紧急消息延迟1秒

**策略3：动态延迟**
- 根据消息类型和优先级动态调整延迟时间
- 例如：P0告警1秒，P1告警3秒，P2告警5秒

**推荐策略：随机延迟 + 动态延迟**

```javascript
// 伪代码
function getReplyDelay(messageType, priority, timeSlot) {
  // P0紧急消息：立即回复
  if (priority === 'P0') {
    return randomBetween(1, 2);
  }

  // 售后任务提醒：立即提醒
  if (messageType === 'after_sales_notify') {
    return randomBetween(1, 2);
  }

  // 根据时段和消息类型确定延迟范围
  if (timeSlot === 'day_shift') {
    if (messageType === 'complex') {
      return randomBetween(5, 15);
    } else {
      return randomBetween(2, 8);
    }
  } else { // night_shift
    if (messageType === 'complex') {
      return randomBetween(10, 30);
    } else {
      return randomBetween(5, 30);
    }
  }
}
```

---

## 3. 售后任务表与腾讯文档的对接细节 - 最优解

### 当前设计

- 实时同步，通过腾讯文档API

### 最优解建议

#### 3.1 同步策略

**策略1：实时同步 + 异步队列**
- 售后任务状态变更时，立即将同步任务加入消息队列
- 异步消费队列，调用腾讯文档API
- 如果同步失败，自动重试（最多3次）

**策略2：批量同步**
- 非关键字段变更（如任务描述），采用批量同步
- 每15分钟批量同步一次
- 减少API调用次数

**策略3：全量校验**
- 每天凌晨进行一次全量校验
- 对比数据库和腾讯文档的数据
- 如果不一致，自动同步

#### 3.2 同步规则

| 操作 | 同步方式 | 同步时机 | 说明 |
|------|---------|---------|------|
| 创建售后任务 | 实时同步 | 任务创建时立即同步 | 优先级高 |
| 更新任务状态 | 实时同步 | 状态变更时立即同步 | 优先级高 |
| 更新任务描述 | 批量同步 | 每15分钟批量同步 | 优先级中 |
| 完成任务 | 实时同步 | 任务完成时立即同步 | 优先级高 |
| 删除任务 | 实时同步 | 任务删除时立即同步 | 优先级高 |
| 全量校验 | 定时同步 | 每天凌晨3点 | 优先级低 |

#### 3.3 同步频率配置

**配置表：`tencent_doc_sync_settings`**

| 配置项 | 配置键 | 默认值 | 说明 | 可调节范围 |
|-------|-------|--------|------|-----------|
| 批量同步间隔 | `batch_sync_interval` | 15（分钟） | 批量同步间隔 | 5-60（分钟） |
| 全量校验时间 | `full_sync_time` | "03:00" | 全量校验时间 | 00:00-23:59 |
| 同步重试次数 | `sync_retry_count` | 3 | 同步失败重试次数 | 1-10 |
| 同步重试间隔 | `sync_retry_interval` | 5（秒） | 同步重试间隔 | 1-60（秒） |
| 同步超时时间 | `sync_timeout` | 30（秒） | 同步超时时间 | 10-300（秒） |

#### 3.4 同步数据字段

| 字段 | 同步方式 | 说明 |
|------|---------|------|
| task_id | 实时同步 | 任务ID（唯一标识） |
| user_id | 实时同步 | 用户ID |
| user_name | 实时同步 | 用户昵称 |
| group_id | 实时同步 | 群聊ID |
| group_name | 实时同步 | 群聊名称 |
| task_type | 实时同步 | 任务类型 |
| task_status | 实时同步 | 任务状态（优先级高） |
| task_description | 批量同步 | 任务描述（优先级中） |
| assigned_staff_id | 实时同步 | 分配的工作人员ID |
| assigned_staff_name | 实时同步 | 分配的工作人员姓名 |
| created_at | 实时同步 | 创建时间 |
| updated_at | 实时同步 | 更新时间 |
| completed_at | 实时同步 | 完成时间 |

#### 3.5 同步错误处理

**错误类型1：API调用失败**
- 自动重试（最多3次）
- 如果仍失败，记录错误日志
- 通知管理员

**错误类型2：数据不一致**
- 记录错误日志
- 自动进行全量校验
- 通知管理员

**错误类型3：网络超时**
- 自动重试（最多3次）
- 如果仍失败，记录错误日志
- 通知管理员

---

## 4. 前端页面设计 - 最优解

### 当前设计

- 9个主要页面：首页、会话管理、告警管理、售后任务、机器人管理、工作人员管理、数据分析、系统设置

### 最优解建议

#### 4.1 页面优化建议

**1. 首页（Dashboard）优化**
- ✅ 增加实时消息流（WebSocket推送）
- ✅ 增加实时告警面板（WebSocket推送）
- ✅ 增加实时工作人员状态（WebSocket推送）
- ✅ 增加实时机器人状态（WebSocket推送）
- ✅ 增加数据刷新按钮（手动刷新）

**2. 会话管理页面优化**
- ✅ 增加搜索功能（支持用户昵称、企业名称、群聊名称）
- ✅ 增加筛选功能（按会话状态、消息数、满意度）
- ✅ 增加排序功能（按最后消息时间、消息数、满意度）
- ✅ 增加导出功能（导出会话数据为Excel）
- ✅ 增加批量操作功能（批量归档、批量删除）

**3. 告警管理页面优化**
- ✅ 增加声音提醒（P0告警播放提示音）
- ✅ 增加弹窗提醒（P0告警弹出提醒）
- ✅ 增加批量处理功能（批量取消告警）
- ✅ 增加告警统计（按告警等级、类型统计）
- ✅ 增加告警趋势图（最近7天、30天告警趋势）

**4. 售后任务页面优化**
- ✅ 增加拖拽排序功能（拖拽任务调整优先级）
- ✅ 增加任务看板（看板视图：待处理、进行中、已完成）
- ✅ 增加任务分配功能（快速分配给售后人工）
- ✅ 增加任务提醒功能（设置任务提醒时间）
- ✅ 增加任务统计（按任务类型、状态统计）

**5. 机器人管理页面优化**
- ✅ 增加机器人状态监控（实时显示机器人在线/离线状态）
- ✅ 增加机器人消息发送统计（今日发送数、成功率）
- ✅ 增加机器人响应时间统计（平均响应时间、最长响应时间）
- ✅ 增加机器人配置功能（配置机器人参数、时段）

**6. 数据分析页面优化**
- ✅ 增加数据可视化（图表展示：折线图、柱状图、饼图）
- ✅ 增加数据导出功能（导出为Excel、PDF）
- ✅ 增加数据筛选功能（按日期范围、筛选条件）
- ✅ 增加数据对比功能（对比不同时间段的数据）

**7. 系统设置页面优化**
- ✅ 增加配置预览功能（预览配置效果）
- ✅ 增加配置备份功能（备份当前配置）
- ✅ 增加配置恢复功能（恢复备份配置）
- ✅ 增加配置测试功能（测试配置是否生效）

#### 4.2 用户体验优化

**1. 实时更新**
- ✅ 使用WebSocket推送实时数据
- ✅ 减少页面刷新次数
- ✅ 提升用户体验

**2. 加载优化**
- ✅ 使用懒加载（Lazy Loading）
- ✅ 使用虚拟滚动（Virtual Scrolling）
- ✅ 使用分页加载（Pagination）

**3. 响应式设计**
- ✅ 支持PC端（1920x1080、1366x768）
- ✅ 支持平板端（1024x768）
- ✅ 支持移动端（375x667、414x896）

**4. 暗黑模式**
- ✅ 支持亮色模式
- ✅ 支持暗黑模式
- ✅ 自动切换（根据系统设置）

**5. 国际化**
- ✅ 支持中文
- ✅ 支持英文
- ✅ 支持切换语言

#### 4.3 性能优化

**1. 首屏加载优化**
- ✅ 使用SSR（Server-Side Rendering）
- ✅ 使用代码分割（Code Splitting）
- ✅ 使用静态资源CDN

**2. 页面渲染优化**
- ✅ 使用虚拟DOM（React）
- ✅ 使用缓存策略（浏览器缓存、HTTP缓存）
- ✅ 使用防抖节流（Debounce、Throttle）

**3. 数据请求优化**
- ✅ 使用HTTP缓存
- ✅ 使用请求合并
- ✅ 使用请求取消

---

## 5. 数据库表结构 - 最优解

### 当前设计

- 13个核心业务表 + 6个用户管理表 = 19个表

### 最优解建议

#### 5.1 表结构优化建议

**1. 字段类型优化**

| 字段类型 | 当前类型 | 优化建议 | 说明 |
|---------|---------|---------|------|
| 时间戳 | TIMESTAMP | TIMESTAMP WITH TIME ZONE | 支持时区 |
| 状态 | VARCHAR(20) | ENUM | 更严格的类型约束 |
| 金额 | DECIMAL(10,2) | DECIMAL(18,4) | 更高的精度 |
| JSON | JSON | JSONB | 更高效的查询性能 |

**2. 索引优化**

```sql
-- 复合索引（优化查询性能）
CREATE INDEX idx_session_messages_user_timestamp ON session_messages(user_id, timestamp DESC);
CREATE INDEX idx_alerts_level_status_created ON alerts(alert_level, status, created_at);
CREATE INDEX idx_after_sales_tasks_status_assigned ON after_sales_tasks(task_status, assigned_staff_id);

-- 部分索引（优化存储和查询性能）
CREATE INDEX idx_session_messages_active ON session_messages(timestamp DESC) WHERE status = 'active';
CREATE INDEX idx_alerts_active ON alerts(created_at) WHERE status = 'active';

-- 表达式索引（优化特定查询）
CREATE INDEX idx_audit_logs_date ON audit_logs((DATE(created_at)));
```

**3. 分区表（优化大数据量查询性能）**

```sql
-- 按时间分区（按月分区）
CREATE TABLE session_messages (
  -- 字段定义
) PARTITION BY RANGE (created_at);

-- 创建分区
CREATE TABLE session_messages_202401 PARTITION OF session_messages
  FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');

CREATE TABLE session_messages_202402 PARTITION OF session_messages
  FOR VALUES FROM ('2024-02-01') TO ('2024-03-01');
```

**4. 数据归档（优化存储空间）**

```sql
-- 创建归档表
CREATE TABLE session_messages_archive (LIKE session_messages);

-- 归档6个月前的数据
INSERT INTO session_messages_archive
SELECT * FROM session_messages
WHERE created_at < NOW() - INTERVAL '6 months';

-- 删除已归档的数据
DELETE FROM session_messages
WHERE created_at < NOW() - INTERVAL '6 months';
```

#### 5.2 新增建议表

**1. 系统配置表（`system_configs`）**

| 字段名 | 类型 | 说明 | 索引 |
|-------|------|------|------|
| id | BIGINT | 主键 | PRIMARY |
| config_key | VARCHAR(100) | 配置键（唯一） | UNIQUE |
| config_value | TEXT | 配置值（JSON格式） | - |
| config_type | VARCHAR(20) | 配置类型（alert/reply_delay/sync） | INDEX |
| description | TEXT | 配置描述 | - |
| is_system | BOOLEAN | 是否系统配置（不可删除） | - |
| created_at | TIMESTAMP | 创建时间 | INDEX |
| updated_at | TIMESTAMP | 更新时间 | - |

**2. 操作日志表（`operation_logs`）**

| 字段名 | 类型 | 说明 | 索引 |
|-------|------|------|------|
| id | BIGINT | 主键 | PRIMARY |
| log_id | VARCHAR(100) | 日志ID（唯一） | UNIQUE |
| user_id | VARCHAR(100) | 操作用户ID | INDEX |
| operation_type | VARCHAR(50) | 操作类型 | INDEX |
| operation_module | VARCHAR(50) | 操作模块 | INDEX |
| operation_data | JSONB | 操作数据 | - |
| operation_result | VARCHAR(20) | 操作结果（success/failed） | INDEX |
| error_message | TEXT | 错误消息 | - |
| ip_address | VARCHAR(50) | IP地址 | - |
| user_agent | VARCHAR(500) | 用户代理 | - |
| created_at | TIMESTAMP | 创建时间 | INDEX |

#### 5.3 数据库性能优化

**1. 连接池配置**

```javascript
// 连接池配置示例
const poolConfig = {
  max: 20, // 最大连接数
  min: 5, // 最小连接数
  idle: 10000, // 空闲连接超时时间（毫秒）
  connectionTimeoutMillis: 2000, // 连接超时时间（毫秒）
};
```

**2. 查询优化**

```sql
-- 使用EXPLAIN分析查询计划
EXPLAIN ANALYZE
SELECT * FROM session_messages
WHERE user_id = 'user_001'
ORDER BY timestamp DESC
LIMIT 20;

-- 使用CTE优化复杂查询
WITH user_messages AS (
  SELECT * FROM session_messages
  WHERE user_id = 'user_001'
)
SELECT * FROM user_messages
WHERE timestamp > NOW() - INTERVAL '7 days';
```

**3. 缓存策略**

```javascript
// Redis缓存策略
const cacheConfig = {
  // 会话数据缓存（1小时）
  session_cache: { ttl: 3600 },

  // 告警数据缓存（5分钟）
  alert_cache: { ttl: 300 },

  // 统计数据缓存（10分钟）
  statistics_cache: { ttl: 600 },
};
```

---

## 6. 部署方案 - 最优解

### 当前设计

- Nginx + Next.js + PostgreSQL + Redis

### 最优解建议

#### 6.1 部署架构优化

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              负载均衡层（Nginx）                              │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  Nginx（端口80/443）                                                  │  │
│  │  - 负载均衡                                                            │  │
│  │  - 静态资源服务                                                        │  │
│  │  - SSL终端                                                             │  │
│  │  - 反向代理                                                            │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
          │
          ├─────────────────────────────────────────────────────────────┐
          │                                                             │
┌─────────▼─────────────────┐  ┌────────────────────────────────────────┐
│  应用层（Next.js集群）     │  │  系统监控层                            │
│  ┌─────────────────────┐  │  │  ┌──────────────────────────────────┐  │
│  │  Next.js实例1（5001）│  │  │  │ Prometheus（监控数据采集）      │  │
│  │  Next.js实例2（5002）│  │  │  │ Grafana（监控数据可视化）       │  │
│  │  Next.js实例3（5003）│  │  │  │ AlertManager（告警管理）        │  │
│  └─────────────────────┘  │  │  └──────────────────────────────────┘  │
└──────────────────────────┘  └────────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────────────────────────────────┐
│  中间件层                                                                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────────────────────────────────┐   │
│  │ Redis    │  │ 消息队列  │  │ 对象存储                            │   │
│  │ （缓存）  │  │ （RabbitMQ │  │ （OSS/MinIO）                       │   │
│  └──────────┘  │ /Kafka）  │  └──────────────────────────────────────┘   │
│                 └──────────┘                                               │
└─────────────────────────────────────────────────────────────────────────────┘
          │
┌─────────▼───────────────────────────────────────────────────────────────────┐
│  数据层                                                                   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  PostgreSQL集群                                                     │   │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐             │   │
│  │  │ 主库（读写） │  │ 从库1（只读）│  │ 从库2（只读）│             │   │
│  │  └──────────────┘  └──────────────┘  └──────────────┘             │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  PostgreSQL备份                                                     │   │
│  │  - 每天全量备份（凌晨3点）                                          │   │
│  │  - 每小时增量备份                                                  │   │
│  │  - 保留30天备份                                                    │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────────┘
```

#### 6.2 部署方案详细配置

**1. 负载均衡（Nginx）**

```nginx
# /etc/nginx/nginx.conf
upstream nextjs_cluster {
    least_conn;
    server 127.0.0.1:5001 max_fails=3 fail_timeout=30s;
    server 127.0.0.1:5002 max_fails=3 fail_timeout=30s;
    server 127.0.0.1:5003 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name example.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name example.com;

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;

    location / {
        proxy_pass http://nextjs_cluster;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /static/ {
        alias /var/www/static/;
        expires 30d;
    }
}
```

**2. 应用层（Next.js集群）**

```yaml
# docker-compose.yml
version: '3.8'
services:
  nextjs-1:
    build: .
    ports:
      - "5001:5000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@postgres-primary:5432/worktool_ai
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres-primary
      - redis

  nextjs-2:
    build: .
    ports:
      - "5002:5000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@postgres-primary:5432/worktool_ai
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres-primary
      - redis

  nextjs-3:
    build: .
    ports:
      - "5003:5000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@postgres-primary:5432/worktool_ai
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres-primary
      - redis
```

**3. 数据层（PostgreSQL集群）**

```yaml
# docker-compose.yml
services:
  postgres-primary:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=worktool_ai
    volumes:
      - postgres-primary-data:/var/lib/postgresql/data
      - ./postgres-replication.conf:/etc/postgresql/postgresql.conf

  postgres-replica-1:
    image: postgres:15
    ports:
      - "5433:5432"
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=worktool_ai
      - PGSTANDBY=1
    volumes:
      - postgres-replica-1-data:/var/lib/postgresql/data
    depends_on:
      - postgres-primary

  postgres-replica-2:
    image: postgres:15
    ports:
      - "5434:5432"
    environment:
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=worktool_ai
      - PGSTANDBY=1
    volumes:
      - postgres-replica-2-data:/var/lib/postgresql/data
    depends_on:
      - postgres-primary

volumes:
  postgres-primary-data:
  postgres-replica-1-data:
  postgres-replica-2-data:
```

**4. 中间件层（Redis + RabbitMQ）**

```yaml
# docker-compose.yml
services:
  redis:
    image: redis:7
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=password
    volumes:
      - rabbitmq-data:/var/lib/rabbitmq

volumes:
  redis-data:
  rabbitmq-data:
```

**5. 监控层（Prometheus + Grafana）**

```yaml
# docker-compose.yml
services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana-data:/var/lib/grafana
    depends_on:
      - prometheus

volumes:
  prometheus-data:
  grafana-data:
```

#### 6.3 自动扩缩容

**策略：基于CPU和内存使用率自动扩缩容**

```yaml
# Kubernetes Horizontal Pod Autoscaler (HPA)
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: nextjs-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: nextjs
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

#### 6.4 备份策略

**数据库备份**

```bash
#!/bin/bash
# 数据库备份脚本

# 全量备份（每天凌晨3点）
pg_dump -h localhost -U user -d worktool_ai > /backup/worktool_ai_$(date +%Y%m%d).sql

# 增量备份（每小时）
pg_dump -h localhost -U user -d worktool_ai --format=d -f /backup/worktool_ai_$(date +%Y%m%d_%H%M%S)

# 保留30天备份
find /backup -name "*.sql" -mtime +30 -delete
```

**文件备份**

```bash
#!/bin/bash
# 文件备份脚本

# 备份静态文件
rsync -avz /var/www/static/ /backup/static/

# 备份上传文件
rsync -avz /var/www/uploads/ /backup/uploads/

# 保留7天备份
find /backup -type f -mtime +7 -delete
```

---

## 总结

### 6个待确认事项的最优解总结

| 事项 | 最优解建议 | 优先级 |
|------|-----------|--------|
| 1. 机器人选择规则 | 明确机器人职责，细化选择规则，配置化 | 高 |
| 2. 回复延迟设置 | 优化延迟策略，配置化，随机延迟+动态延迟 | 中 |
| 3. 售后任务与腾讯文档对接 | 实时同步+异步队列，批量同步，全量校验 | 高 |
| 4. 前端页面设计 | 实时更新，性能优化，用户体验优化 | 中 |
| 5. 数据库表结构 | 字段类型优化，索引优化，分区表，数据归档 | 高 |
| 6. 部署方案 | 负载均衡，集群部署，自动扩缩容，备份策略 | 高 |

### 下一步建议

1. 确认以上6个最优解建议
2. 更新系统设计报告
3. 开始技术实现（后端、前端）

---

**文档版本**：v1.0

**最后更新**：2024-01-10

**文档作者**：WorkTool AI 团队
