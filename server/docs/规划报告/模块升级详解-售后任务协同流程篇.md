# WorkTool AI 中枢系统 - 模块升级详解（售后任务协同流程篇）

## 📋 目录

1. [售后任务协同系统概述](#1-售后任务协同系统概述)
2. [腾讯文档对接](#2-腾讯文档对接)
3. [售后任务管理](#3-售后任务管理)
4. [售后任务协同流程](#4-售后任务协同流程)
5. [腾讯文档同步](#5-腾讯文档同步)

---

## 1. 售后任务协同系统概述

### 1.1 系统架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         售后任务协同系统                                      │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  任务创建层 (Task Creation Layer)                                      │  │
│  │  - AI自动创建：AI检测到售后需求                                         │  │
│  │  - 工作人员创建：工作人员手动创建                                       │  │
│  │  - 用户提交：用户提交售后申请                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    ↓                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  任务处理层 (Task Processing Layer)                                    │  │
│  │  - 任务分配：自动分配或手动分配给工作人员                               │  │
│  │  - 任务追踪：实时追踪任务进度                                           │  │
│  │  - 任务提醒：超时提醒、升级提醒                                         │  │
│  │  - 任务完成：任务完成、验证、关闭                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    ↓                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  协同层 (Collaboration Layer)                                          │  │
│  │  - 腾讯文档同步：任务信息同步到腾讯文档                                 │  │
│  │  - 多人协同：多人同时编辑、评论                                         │  │
│  │  - 实时更新：任务状态实时同步                                           │  │
│  │  - 历史记录：记录所有操作历史                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│                                    ↓                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  通知层 (Notification Layer)                                          │  │
│  │  - 任务分配通知：通知工作人员                                           │  │
│  │  - 任务更新通知：通知相关人员                                           │  │
│  │  - 任务完成通知：通知用户和管理层                                       │  │
│  │  - 腾讯文档更新通知：文档变更通知                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 1.2 协同能力

```
┌──────────────────┬────────────────┬────────────────┬────────────────┐
│    协同能力       │    功能描述     │    使用场景     │    集成方式     │
├──────────────────┼────────────────┼────────────────┼────────────────┤
│ 腾讯文档对接      | 任务信息同步    | 任务管理、协作   | 腾讯文档API     |
│ 多人协同编辑      | 同时编辑任务    | 团队协作        | 腾讯文档实时编辑  |
│ 实时状态同步      | 状态实时更新    | 任务追踪        | Webhook        |
│ 历史记录追溯      | 记录操作历史    | 审计、追溯      | 数据库日志      │
└──────────────────┴────────────────┴────────────────┴────────────────┘
```

---

## 2. 腾讯文档对接

### 2.1 腾讯文档功能

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              腾讯文档功能                                    │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 文档创建                                                           │  │
│  │     - 创建表格文档                                                     │  │
│  │     - 设置文档权限（可编辑、只读）                                      │  │
│  │     - 初始化表格结构                                                    │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 数据同步                                                           │  │
│  │     - 创建任务记录：插入新行                                           │  │
│  │     - 更新任务记录：更新单元格                                          │  │
│  │     - 删除任务记录：删除行                                             │  │
│  │     - 批量操作：批量插入、批量更新                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 实时更新                                                           │  │
│  │     - 监听文档变更                                                     │  │
│  │     - 实时同步状态                                                     │  │
│  │     - 防止数据冲突                                                     │  │
│  │     - 乐观锁机制                                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 权限管理                                                           │  │
│  │     - 设置用户权限                                                     │  │
│  │     - 分享链接生成                                                     │  │
│  │     - 权限继承                                                         │  │
│  │     - 权限撤销                                                         │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 腾讯文档API集成

**文件位置：** `server/services/tencent-docs.service.js`

```javascript
const axios = require('axios');
const logger = require('./system-logger.service');

class TencentDocsService {
  constructor() {
    this.baseURL = 'https://docs.qq.com/openapi';
    this.appId = process.env.TENCENT_DOCS_APP_ID;
    this.appSecret = process.env.TENCENT_DOCS_APP_SECRET;
    this.accessToken = null;
    this.tokenExpireTime = null;
  }

  /**
   * 获取访问令牌
   */
  async getAccessToken() {
    // 如果令牌未过期，直接返回
    if (this.accessToken && this.tokenExpireTime && Date.now() < this.tokenExpireTime) {
      return this.accessToken;
    }

    try {
      logger.info('[腾讯文档] 获取访问令牌');

      const response = await axios.post(`${this.baseURL}/token`, {
        appId: this.appId,
        appSecret: this.appSecret,
      });

      if (response.data.code !== 0) {
        throw new Error(`获取访问令牌失败：${response.data.msg}`);
      }

      this.accessToken = response.data.data.accessToken;
      this.tokenExpireTime = Date.now() + (response.data.data.expireIn - 60) * 1000;

      logger.info('[腾讯文档] 访问令牌获取成功');

      return this.accessToken;
    } catch (error) {
      logger.error('[腾讯文档] 获取访问令牌失败', {
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 创建文档
   */
  async createDocument(documentData) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 创建文档', {
        title: documentData.title,
      });

      const response = await axios.post(`${this.baseURL}/doc/create`, {
        token: accessToken,
        type: 'sheet', // 表格类型
        title: documentData.title,
        folderId: documentData.folderId,
      });

      if (response.data.code !== 0) {
        throw new Error(`创建文档失败：${response.data.msg}`);
      }

      const document = response.data.data;

      logger.info('[腾讯文档] 文档创建成功', {
        documentId: document.id,
      });

      return document;
    } catch (error) {
      logger.error('[腾讯文档] 创建文档失败', {
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 初始化表格结构
   */
  async initTableStructure(documentId, columns) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 初始化表格结构', {
        documentId,
        columnsCount: columns.length,
      });

      const response = await axios.post(`${this.baseURL}/sheet/update`, {
        token: accessToken,
        docId: documentId,
        sheetId: 0,
        updates: [
          {
            // 设置表头
            type: 'setCell',
            row: 1,
            col: 1,
            data: {
              v: columns.map(col => col.name).join('\t'),
              style: { bold: true },
            },
          },
        ],
      });

      if (response.data.code !== 0) {
        throw new Error(`初始化表格结构失败：${response.data.msg}`);
      }

      logger.info('[腾讯文档] 表格结构初始化成功', {
        documentId,
      });

      return response.data;
    } catch (error) {
      logger.error('[腾讯文档] 初始化表格结构失败', {
        documentId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 插入任务记录
   */
  async insertTaskRecord(documentId, task, columns) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 插入任务记录', {
        documentId,
        taskId: task.id,
      });

      // 构建任务数据
      const rowData = columns.map(col => {
        const value = task[col.field];
        return value || '';
      }).join('\t');

      // 获取当前表格行数
      const rowCount = await this.getTableRowCount(documentId);

      // 插入新行
      const response = await axios.post(`${this.baseURL}/sheet/update`, {
        token: accessToken,
        docId: documentId,
        sheetId: 0,
        updates: [
          {
            type: 'setCell',
            row: rowCount + 1,
            col: 1,
            data: {
              v: rowData,
            },
          },
        ],
      });

      if (response.data.code !== 0) {
        throw new Error(`插入任务记录失败：${response.data.msg}`);
      }

      logger.info('[腾讯文档] 任务记录插入成功', {
        documentId,
        taskId: task.id,
        row: rowCount + 1,
      });

      return response.data;
    } catch (error) {
      logger.error('[腾讯文档] 插入任务记录失败', {
        documentId,
        taskId: task.id,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 更新任务记录
   */
  async updateTaskRecord(documentId, task, columns, rowNumber) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 更新任务记录', {
        documentId,
        taskId: task.id,
        rowNumber,
      });

      // 构建任务数据
      const rowData = columns.map(col => {
        const value = task[col.field];
        return value || '';
      }).join('\t');

      // 更新行
      const response = await axios.post(`${this.baseURL}/sheet/update`, {
        token: accessToken,
        docId: documentId,
        sheetId: 0,
        updates: [
          {
            type: 'setCell',
            row: rowNumber,
            col: 1,
            data: {
              v: rowData,
            },
          },
        ],
      });

      if (response.data.code !== 0) {
        throw new Error(`更新任务记录失败：${response.data.msg}`);
      }

      logger.info('[腾讯文档] 任务记录更新成功', {
        documentId,
        taskId: task.id,
        rowNumber,
      });

      return response.data;
    } catch (error) {
      logger.error('[腾讯文档] 更新任务记录失败', {
        documentId,
        taskId: task.id,
        rowNumber,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 获取表格行数
   */
  async getTableRowCount(documentId) {
    try {
      const accessToken = await this.getAccessToken();

      const response = await axios.post(`${this.baseURL}/sheet/read`, {
        token: accessToken,
        docId: documentId,
        sheetId: 0,
        range: 'A1:A10000',
      });

      if (response.data.code !== 0) {
        throw new Error(`获取表格行数失败：${response.data.msg}`);
      }

      const rows = response.data.data.values;
      return rows.length;
    } catch (error) {
      logger.error('[腾讯文档] 获取表格行数失败', {
        documentId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 设置文档权限
   */
  async setDocumentPermission(documentId, permissions) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 设置文档权限', {
        documentId,
      });

      const response = await axios.post(`${this.baseURL}/doc/permission`, {
        token: accessToken,
        docId: documentId,
        permissions,
      });

      if (response.data.code !== 0) {
        throw new Error(`设置文档权限失败：${response.data.msg}`);
      }

      logger.info('[腾讯文档] 文档权限设置成功', {
        documentId,
      });

      return response.data;
    } catch (error) {
      logger.error('[腾讯文档] 设置文档权限失败', {
        documentId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 生成分享链接
   */
  async generateShareLink(documentId) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 生成分享链接', {
        documentId,
      });

      const response = await axios.post(`${this.baseURL}/doc/share`, {
        token: accessToken,
        docId: documentId,
        type: 'edit', // 可编辑
      });

      if (response.data.code !== 0) {
        throw new Error(`生成分享链接失败：${response.data.msg}`);
      }

      const shareLink = response.data.data.url;

      logger.info('[腾讯文档] 分享链接生成成功', {
        documentId,
        shareLink,
      });

      return shareLink;
    } catch (error) {
      logger.error('[腾讯文档] 生成分享链接失败', {
        documentId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 监听文档变更
   */
  async watchDocumentChanges(documentId, webhookUrl) {
    try {
      const accessToken = await this.getAccessToken();

      logger.info('[腾讯文档] 监听文档变更', {
        documentId,
        webhookUrl,
      });

      const response = await axios.post(`${this.baseURL}/doc/watch`, {
        token: accessToken,
        docId: documentId,
        webhook: webhookUrl,
      });

      if (response.data.code !== 0) {
        throw new Error(`监听文档变更失败：${response.data.msg}`);
      }

      logger.info('[腾讯文档] 文档变更监听已设置', {
        documentId,
      });

      return response.data;
    } catch (error) {
      logger.error('[腾讯文档] 监听文档变更失败', {
        documentId,
        webhookUrl,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }
}

module.exports = new TencentDocsService();
```

---

## 3. 售后任务管理

### 3.1 任务类型

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              任务类型                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 退款任务 (refund)                                                  │  │
│  │     - 用户申请退款                                                     │  │
│  │     - 退款金额、退款原因、退款方式                                       │  │
│  │     - 优先级：P1                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 产品问题 (product_issue)                                           │  │
│  │     - 产品质量问题、功能故障                                             │  │
│  │     - 产品描述、问题现象、复现步骤                                       │  │
│  │     - 优先级：P1 或 P2                                                  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 服务问题 (service_issue)                                           │  │
│  │     - 服务态度、服务时效、服务质量                                       │  │
│  │     - 服务描述、问题详情、期望结果                                       │  │
│  │     - 优先级：P1 或 P2                                                  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 订单问题 (order_issue)                                             │  │
│  │     - 订单信息、发货问题、到货问题                                       │  │
│  │     - 订单号、问题描述、期望处理方式                                     │  │
│  │     - 优先级：P2                                                        │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  5. 其他问题 (other)                                                   │  │
│  │     - 其他类型的售后问题                                                │  │
│  │     - 问题描述、期望处理方式                                             │  │
│  │     - 优先级：P2 或 P3                                                  │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 任务状态

```
pending（待处理） → in_progress（处理中） → completed（已完成）
                          ↓
                   cancelled（已取消）
```

### 3.3 详细实现

**文件位置：** `server/services/after-sales-task.service.js`

```javascript
const { getDb } = require('coze-coding-dev-sdk');
const { afterSalesTasks, tencentDocsSyncLogs, eq, sql, desc } = require('../database/schema');
const tencentDocsService = require('./tencent-docs.service');
const notificationService = require('./notification.service');
const logger = require('./system-logger.service');

class AfterSalesTaskService {
  /**
   * 创建售后任务
   */
  async createTask(taskData) {
    const db = await getDb();

    try {
      logger.info('[售后任务] 创建售后任务', {
        taskType: taskData.taskType,
        userId: taskData.userId,
      });

      // 1. 创建任务记录
      const task = await db.insert(afterSalesTasks).values({
        taskId: this.generateTaskId(),
        taskType: taskData.taskType,
        sessionId: taskData.sessionId,
        userId: taskData.userId,
        userName: taskData.userName,
        groupId: taskData.groupId,
        groupName: taskData.groupName,
        description: taskData.description,
        details: taskData.details || {},
        priority: taskData.priority || 'P2',
        status: 'pending',
        assignedTo: null,
        assignedAt: null,
        completedBy: null,
        completedAt: null,
        cancelledBy: null,
        cancelledAt: null,
        cancelReason: null,
        source: taskData.source || 'manual',
        syncToTencentDocs: true,
        tencentDocsId: null,
        tencentDocsRowNumber: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      }).returning();

      // 2. 同步到腾讯文档
      if (taskData.syncToTencentDocs !== false) {
        await this.syncToTencentDocs(task[0]);
      }

      // 3. 发送通知
      await notificationService.sendTaskCreatedNotification(task[0]);

      logger.info('[售后任务] 售后任务创建成功', {
        taskId: task[0].taskId,
      });

      return task[0];
    } catch (error) {
      logger.error('[售后任务] 创建售后任务失败', {
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 分配任务
   */
  async assignTask(taskId, assignedTo) {
    const db = await getDb();

    try {
      logger.info('[售后任务] 分配任务', {
        taskId,
        assignedTo,
      });

      const task = await db
        .update(afterSalesTasks)
        .set({
          assignedTo,
          assignedAt: new Date(),
          status: 'in_progress',
          updatedAt: new Date(),
        })
        .where(eq(afterSalesTasks.taskId, taskId))
        .returning();

      // 同步到腾讯文档
      await this.syncToTencentDocs(task[0]);

      // 发送通知
      await notificationService.sendTaskAssignedNotification(task[0]);

      logger.info('[售后任务] 任务分配成功', {
        taskId,
        assignedTo,
      });

      return task[0];
    } catch (error) {
      logger.error('[售后任务] 分配任务失败', {
        taskId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 更新任务
   */
  async updateTask(taskId, updates) {
    const db = await getDb();

    try {
      logger.info('[售后任务] 更新任务', {
        taskId,
      });

      const task = await db
        .update(afterSalesTasks)
        .set({
          ...updates,
          updatedAt: new Date(),
        })
        .where(eq(afterSalesTasks.taskId, taskId))
        .returning();

      // 同步到腾讯文档
      if (task[0].syncToTencentDocs) {
        await this.syncToTencentDocs(task[0]);
      }

      logger.info('[售后任务] 任务更新成功', {
        taskId,
      });

      return task[0];
    } catch (error) {
      logger.error('[售后任务] 更新任务失败', {
        taskId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 完成任务
   */
  async completeTask(taskId, completedBy, completionNotes) {
    const db = await getDb();

    try {
      logger.info('[售后任务] 完成任务', {
        taskId,
        completedBy,
      });

      const task = await db
        .update(afterSalesTasks)
        .set({
          status: 'completed',
          completedBy,
          completedAt: new Date(),
          completionNotes,
          updatedAt: new Date(),
        })
        .where(eq(afterSalesTasks.taskId, taskId))
        .returning();

      // 同步到腾讯文档
      if (task[0].syncToTencentDocs) {
        await this.syncToTencentDocs(task[0]);
      }

      // 发送通知
      await notificationService.sendTaskCompletedNotification(task[0]);

      logger.info('[售后任务] 任务完成成功', {
        taskId,
      });

      return task[0];
    } catch (error) {
      logger.error('[售后任务] 完成任务失败', {
        taskId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 取消任务
   */
  async cancelTask(taskId, cancelledBy, cancelReason) {
    const db = await getDb();

    try {
      logger.info('[售后任务] 取消任务', {
        taskId,
        cancelledBy,
      });

      const task = await db
        .update(afterSalesTasks)
        .set({
          status: 'cancelled',
          cancelledBy,
          cancelledAt: new Date(),
          cancelReason,
          updatedAt: new Date(),
        })
        .where(eq(afterSalesTasks.taskId, taskId))
        .returning();

      // 同步到腾讯文档
      if (task[0].syncToTencentDocs) {
        await this.syncToTencentDocs(task[0]);
      }

      // 发送通知
      await notificationService.sendTaskCancelledNotification(task[0]);

      logger.info('[售后任务] 任务取消成功', {
        taskId,
      });

      return task[0];
    } catch (error) {
      logger.error('[售后任务] 取消任务失败', {
        taskId,
        error: error.message,
        stack: error.stack,
      });
      throw error;
    }
  }

  /**
   * 获取任务列表
   */
  async getTaskList(params) {
    const db = await getDb();

    const {
      status,
      taskType,
      priority,
      assignedTo,
      userId,
      startTime,
      endTime,
      page = 1,
      pageSize = 20,
    } = params;

    const offset = (page - 1) * pageSize;

    // 构建查询条件
    const conditions = [];

    if (status) {
      conditions.push(eq(afterSalesTasks.status, status));
    }

    if (taskType) {
      conditions.push(eq(afterSalesTasks.taskType, taskType));
    }

    if (priority) {
      conditions.push(eq(afterSalesTasks.priority, priority));
    }

    if (assignedTo) {
      conditions.push(eq(afterSalesTasks.assignedTo, assignedTo));
    }

    if (userId) {
      conditions.push(eq(afterSalesTasks.userId, userId));
    }

    if (startTime) {
      conditions.push(sql`created_at >= ${new Date(startTime)}`);
    }

    if (endTime) {
      conditions.push(sql`created_at <= ${new Date(endTime)}`);
    }

    // 执行查询
    const tasks = await db
      .select()
      .from(afterSalesTasks)
      .where(conditions.length > 0 ? and(...conditions) : sql`1=1`)
      .orderBy(desc(afterSalesTasks.createdAt))
      .limit(pageSize)
      .offset(offset);

    return {
      list: tasks,
      page,
      pageSize,
    };
  }

  /**
   * 获取任务详情
   */
  async getTaskDetails(taskId) {
    const db = await getDb();

    const task = await db
      .select()
      .from(afterSalesTasks)
      .where(eq(afterSalesTasks.taskId, taskId))
      .limit(1);

    if (task.length === 0) {
      return null;
    }

    return task[0];
  }

  /**
   * 同步到腾讯文档
   */
  async syncToTencentDocs(task) {
    try {
      logger.info('[售后任务] 同步到腾讯文档', {
        taskId: task.taskId,
      });

      // 如果已经有腾讯文档ID，更新记录
      if (task.tencentDocsId) {
        await tencentDocsService.updateTaskRecord(
          task.tencentDocsId,
          task,
          this.getTableColumns(),
          task.tencentDocsRowNumber
        );
      } else {
        // 如果没有腾讯文档ID，创建新文档或使用现有文档
        const documentId = process.env.TENCENT_DOCS_SHEET_ID;

        if (!documentId) {
          throw new Error('未配置腾讯文档ID');
        }

        // 插入新记录
        await tencentDocsService.insertTaskRecord(
          documentId,
          task,
          this.getTableColumns()
        );

        // 获取行号
        const rowNumber = await tencentDocsService.getTableRowCount(documentId);

        // 更新任务记录
        const db = await getDb();
        await db
          .update(afterSalesTasks)
          .set({
            tencentDocsId: documentId,
            tencentDocsRowNumber: rowNumber,
          })
          .where(eq(afterSalesTasks.taskId, task.taskId));

        // 记录同步日志
        await this.recordSyncLog(task.taskId, documentId, rowNumber, 'insert');
      }

      logger.info('[售后任务] 腾讯文档同步成功', {
        taskId: task.taskId,
      });
    } catch (error) {
      logger.error('[售后任务] 腾讯文档同步失败', {
        taskId: task.taskId,
        error: error.message,
        stack: error.stack,
      });

      // 记录同步失败日志
      await this.recordSyncLog(task.taskId, null, null, 'failed', error.message);
    }
  }

  /**
   * 记录同步日志
   */
  async recordSyncLog(taskId, documentId, rowNumber, status, error = null) {
    const db = await getDb();

    await db.insert(tencentDocsSyncLogs).values({
      taskId,
      documentId,
      rowNumber,
      status,
      error,
      syncedAt: new Date(),
    });
  }

  /**
   * 获取表格列定义
   */
  getTableColumns() {
    return [
      { name: '任务ID', field: 'taskId' },
      { name: '任务类型', field: 'taskType' },
      { name: '用户', field: 'userName' },
      { name: '群组', field: 'groupName' },
      { name: '描述', field: 'description' },
      { name: '优先级', field: 'priority' },
      { name: '状态', field: 'status' },
      { name: '分配给', field: 'assignedTo' },
      { name: '创建时间', field: 'createdAt' },
      { name: '分配时间', field: 'assignedAt' },
      { name: '完成时间', field: 'completedAt' },
    ];
  }

  /**
   * 生成任务ID
   */
  generateTaskId() {
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    return `TSK-${timestamp}-${random}`;
  }
}

module.exports = new AfterSalesTaskService();
```

---

## 4. 售后任务协同流程

### 4.1 完整流程

```
AI检测到售后需求
    ↓
创建售后任务
    ├─ 任务ID：自动生成
    ├─ 任务类型：refund/product_issue/service_issue
    ├─ 任务优先级：P1/P2/P3
    ├─ 任务状态：pending
    └─ 同步到腾讯文档：true
    ↓
同步到腾讯文档
    ├─ 插入任务记录到表格
    ├─ 获取行号
    ├─ 更新任务记录
    └─ 记录同步日志
    ↓
自动分配工作人员
    ├─ 根据优先级分配
    ├─ 根据工作负载分配
    ├─ 根据质量评分分配
    └─ 选择最优工作人员
    ↓
分配任务
    ├─ 更新任务状态为in_progress
    ├─ 更新分配人
    ├─ 更新分配时间
    └─ 同步到腾讯文档
    ↓
通知工作人员
    ├─ 企业微信通知
    ├- 告知任务ID
    ├─ 告知任务类型
    ├─ 告知优先级
    ├─ 提供腾讯文档链接
    └─ 提供任务详情
    ↓
工作人员处理任务
    ├─ 查看腾讯文档
    ├─ 编辑任务记录
    ├─ 添加处理备注
    ├─ 更新任务状态
    └─ 与用户沟通
    ↓
任务状态更新
    ├─ 腾讯文档实时同步
    ├─ 更新任务记录
    ├─ 同步到数据库
    └─ 记录同步日志
    ↓
任务完成
    ├─ 工作人员标记完成
    ├─ 填写完成备注
    ├─ 更新任务状态为completed
    ├─ 更新完成时间
    └─ 同步到腾讯文档
    ↓
通知用户
    ├─ 企业微信通知
    ├─ 告知任务已完成
    ├─ 提供处理结果
    └─ 收集用户反馈
    ↓
分析处理效果
    ├─ 计算处理时长
    ├─ 计算响应时长
    ├─ 计算用户满意度
    └─ 生成报表
```

### 4.2 协同规则

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              协同规则                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 任务分配规则                                                       │  │
│  │  - P0/P1任务：优先分配给质量评分高的工作人员                           │  │
│  │  - P2任务：分配给工作负载低的工作人员                                   │  │
│  │  - P3任务：按照负载均衡分配                                             │  │
│  │  - 工作人员拒绝任务：自动重新分配                                       │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 任务升级规则                                                       │  │
│  │  - 超时未处理：自动升级优先级                                           │  │
│  │  - 3次超时：升级到P0                                                   │  │
│  │  - 用户投诉：升级到P0                                                   │  │
│  │  - 处理困难：申请支援                                                   │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 任务协同规则                                                       │  │
│  │  - 多人协同：多个工作人员可以同时查看和处理任务                        │  │
│  │  - 任务交接：支持任务交接给其他工作人员                                 │  │
│  │  - 任务合并：支持合并相似任务                                           │  │
│  │  - 任务拆分：支持拆分复杂任务                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 腾讯文档同步规则                                                   │  │
│  │  - 实时同步：任务变更实时同步到腾讯文档                                 │  │
│  │  - 双向同步：支持从腾讯文档回写到数据库                                 │  │
│  │  - 冲突解决：最后写入优先，保留历史记录                                 │  │
│  │  - 同步日志：记录所有同步操作                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. 腾讯文档同步

### 5.1 同步策略

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              同步策略                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 实时同步                                                           │  │
│  │  - 触发时机：任务创建、更新、完成、取消                                  │  │
│  │  - 同步方式：立即调用API更新腾讯文档                                     │  │
│  │  - 延迟：< 1秒                                                         │  │
│  │  - 可靠性：高                                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 批量同步                                                           │  │
│  │  - 触发时机：系统维护、数据迁移                                         │  │
│  │  - 同步方式：批量插入或更新                                             │  │
│  │  - 延迟：根据数据量决定                                                 │  │
│  │  - 可靠性：中                                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 定时同步                                                           │  │
│  │  - 触发时机：定时任务                                                   │  │
│  │  - 同步方式：检查未同步的任务                                           │  │
│  │  - 频率：每5分钟                                                        │  │
│  │  - 可靠性：高（兜底方案）                                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. Webhook同步                                                        │  │
│  │  - 触发时机：腾讯文档被编辑                                             │  │
│  │  - 同步方式：腾讯文档推送变更通知                                       │  │
│  │  - 延迟：< 1秒                                                         │  │
│  │  - 可靠性：高（双向同步）                                               │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 同步日志

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              同步日志                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  日志内容：                                                            │  │
│  │  - 任务ID                                                             │  │
│  │  - 文档ID                                                             │  │
│  │  - 行号                                                               │  │
│  │  - 同步状态（insert/update/failed）                                    │  │
│  │  - 同步时间                                                           │  │
│  │  - 错误信息（如果失败）                                                 │  │
│  │                                                                        │  │
│  │  日志用途：                                                            │  │
│  │  - 追踪同步状态                                                       │  │
│  │  - 定位同步问题                                                       │  │
│  │  - 统计同步成功率                                                     │  │
│  │  - 故障恢复                                                           │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.3 冲突解决

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              冲突解决                                        │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  1. 最后写入优先                                                       │  │
│  │  - 原理：以最后修改时间为准                                             │  │
│  │  - 优点：简单、高效                                                    │  │
│  │  - 缺点：可能丢失数据                                                   │  │
│  │  - 适用场景：大多数场景                                                 │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  2. 版本号机制                                                         │  │
│  │  - 原理：每次更新增加版本号                                             │  │
│  │  - 优点：避免覆盖                                                      │  │
│  │  - 缺点：需要维护版本号                                                │  │
│  │  - 适用场景：重要任务                                                 │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  3. 保留历史记录                                                       │  │
│  │  - 原理：每次修改保留历史版本                                           │  │
│  │  - 优点：可追溯、可恢复                                                │  │
│  │  - 缺点：占用存储空间                                                  │  │
│  │  - 适用场景：审计、追溯                                                │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
│  ┌───────────────────────────────────────────────────────────────────────┐  │
│  │  4. 人工审核                                                           │  │
│  │  - 原理：冲突时通知工作人员审核                                         │  │
│  │  - 优点：可控、准确                                                    │  │
│  │  - 缺点：需要人工干预                                                  │  │
│  │  - 适用场景：重要任务、冲突频繁                                         │  │
│  └───────────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

**文档版本**：v1.0

**最后更新**：2024-01-10

**文档作者**：WorkTool AI 团队
